{"ast":null,"code":"import _inherits from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Annotation, StateEffect, EditorSelection, codePointAt, codePointSize, fromCodePoint, Facet, combineConfig, StateField, Prec, Text, Transaction, MapMode, RangeValue, RangeSet, CharCategory } from '@codemirror/state';\nimport { Direction, logException, showTooltip, EditorView, ViewPlugin, getTooltip, Decoration, WidgetType, keymap } from '@codemirror/view';\nimport { syntaxTree, indentUnit } from '@codemirror/language';\n/**\nAn instance of this is passed to completion source functions.\n*/\n\nvar CompletionContext = /*#__PURE__*/function () {\n  /**\n  Create a new completion context. (Mostly useful for testing\n  completion sources—in the editor, the extension will create\n  these for you.)\n  */\n  function CompletionContext(\n  /**\n  The editor state that the completion happens in.\n  */\n  state,\n  /**\n  The position at which the completion is happening.\n  */\n  pos,\n  /**\n  Indicates whether completion was activated explicitly, or\n  implicitly by typing. The usual way to respond to this is to\n  only return completions when either there is part of a\n  completable entity before the cursor, or `explicit` is true.\n  */\n  explicit,\n  /**\n  The editor view. May be undefined if the context was created\n  in a situation where there is no such view available, such as\n  in synchronous updates via\n  [`CompletionResult.update`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.update)\n  or when called by test code.\n  */\n  view) {\n    _classCallCheck(this, CompletionContext);\n\n    this.state = state;\n    this.pos = pos;\n    this.explicit = explicit;\n    this.view = view;\n    /**\n    @internal\n    */\n\n    this.abortListeners = [];\n    /**\n    @internal\n    */\n\n    this.abortOnDocChange = false;\n  }\n  /**\n  Get the extent, content, and (if there is a token) type of the\n  token before `this.pos`.\n  */\n\n\n  _createClass(CompletionContext, [{\n    key: \"tokenBefore\",\n    value: function tokenBefore(types) {\n      var token = syntaxTree(this.state).resolveInner(this.pos, -1);\n\n      while (token && types.indexOf(token.name) < 0) {\n        token = token.parent;\n      }\n\n      return token ? {\n        from: token.from,\n        to: this.pos,\n        text: this.state.sliceDoc(token.from, this.pos),\n        type: token.type\n      } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */\n\n  }, {\n    key: \"matchBefore\",\n    value: function matchBefore(expr) {\n      var line = this.state.doc.lineAt(this.pos);\n      var start = Math.max(line.from, this.pos - 250);\n      var str = line.text.slice(start - line.from, this.pos - line.from);\n      var found = str.search(ensureAnchor(expr, false));\n      return found < 0 ? null : {\n        from: start + found,\n        to: this.pos,\n        text: str.slice(found)\n      };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */\n\n  }, {\n    key: \"aborted\",\n    get: function get() {\n      return this.abortListeners == null;\n    }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    \n    By default, running queries will not be aborted for regular\n    typing or backspacing, on the assumption that they are likely to\n    return a result with a\n    [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that\n    allows the result to be used after all. Passing `onDocChange:\n    true` will cause this query to be aborted for any document\n    change.\n    */\n\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener, options) {\n      if (type == \"abort\" && this.abortListeners) {\n        this.abortListeners.push(listener);\n        if (options && options.onDocChange) this.abortOnDocChange = true;\n      }\n    }\n  }]);\n\n  return CompletionContext;\n}();\n\nfunction toSet(chars) {\n  var flat = Object.keys(chars).join(\"\");\n  var words = /\\w/.test(flat);\n  if (words) flat = flat.replace(/\\w/g, \"\");\n  return \"[\".concat(words ? \"\\\\w\" : \"\").concat(flat.replace(/[^\\w\\s]/g, \"\\\\$&\"), \"]\");\n}\n\nfunction prefixMatch(options) {\n  var first = Object.create(null),\n      rest = Object.create(null);\n\n  var _iterator = _createForOfIteratorHelper(options),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var label = _step.value.label;\n      first[label[0]] = true;\n\n      for (var i = 1; i < label.length; i++) {\n        rest[label[i]] = true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var source = toSet(first) + toSet(rest) + \"*$\";\n  return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\n\n\nfunction completeFromList(list) {\n  var options = list.map(function (o) {\n    return typeof o == \"string\" ? {\n      label: o\n    } : o;\n  });\n\n  var _ref = options.every(function (o) {\n    return /^\\w+$/.test(o.label);\n  }) ? [/\\w*$/, /\\w+$/] : prefixMatch(options),\n      _ref2 = _slicedToArray(_ref, 2),\n      validFor = _ref2[0],\n      match = _ref2[1];\n\n  return function (context) {\n    var token = context.matchBefore(match);\n    return token || context.explicit ? {\n      from: token ? token.from : context.pos,\n      options: options,\n      validFor: validFor\n    } : null;\n  };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/\n\n\nfunction ifIn(nodes, source) {\n  return function (context) {\n    for (var pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n      if (nodes.indexOf(pos.name) > -1) return source(context);\n      if (pos.type.isTop) break;\n    }\n\n    return null;\n  };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\n\n\nfunction ifNotIn(nodes, source) {\n  return function (context) {\n    for (var pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n      if (nodes.indexOf(pos.name) > -1) return null;\n      if (pos.type.isTop) break;\n    }\n\n    return source(context);\n  };\n}\n\nvar Option = function Option(completion, source, match, score) {\n  _classCallCheck(this, Option);\n\n  this.completion = completion;\n  this.source = source;\n  this.match = match;\n  this.score = score;\n};\n\nfunction cur(state) {\n  return state.selection.main.from;\n} // Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\n\n\nfunction ensureAnchor(expr, start) {\n  var _a;\n\n  var source = expr.source;\n  var addStart = start && source[0] != \"^\",\n      addEnd = source[source.length - 1] != \"$\";\n  if (!addStart && !addEnd) return expr;\n  return new RegExp(\"\".concat(addStart ? \"^\" : \"\", \"(?:\").concat(source, \")\").concat(addEnd ? \"$\" : \"\"), (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/\n\n\nvar pickedCompletion = /*@__PURE__*/Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/\n\nfunction insertCompletionText(state, text, from, to) {\n  var main = state.selection.main,\n      fromOff = from - main.from,\n      toOff = to - main.from;\n  return Object.assign(Object.assign({}, state.changeByRange(function (range) {\n    if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to)) return {\n      range: range\n    };\n    var lines = state.toText(text);\n    return {\n      changes: {\n        from: range.from + fromOff,\n        to: to == main.from ? range.to : range.from + toOff,\n        insert: lines\n      },\n      range: EditorSelection.cursor(range.from + fromOff + lines.length)\n    };\n  })), {\n    scrollIntoView: true,\n    userEvent: \"input.complete\"\n  });\n}\n\nvar SourceCache = /*@__PURE__*/new WeakMap();\n\nfunction asSource(source) {\n  if (!Array.isArray(source)) return source;\n  var known = SourceCache.get(source);\n  if (!known) SourceCache.set(source, known = completeFromList(source));\n  return known;\n}\n\nvar startCompletionEffect = /*@__PURE__*/StateEffect.define();\nvar closeCompletionEffect = /*@__PURE__*/StateEffect.define(); // A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\n\nvar FuzzyMatcher = /*#__PURE__*/function () {\n  function FuzzyMatcher(pattern) {\n    _classCallCheck(this, FuzzyMatcher);\n\n    this.pattern = pattern;\n    this.chars = [];\n    this.folded = []; // Buffers reused by calls to `match` to track matched character\n    // positions.\n\n    this.any = [];\n    this.precise = [];\n    this.byWord = [];\n    this.score = 0;\n    this.matched = [];\n\n    for (var p = 0; p < pattern.length;) {\n      var char = codePointAt(pattern, p),\n          size = codePointSize(char);\n      this.chars.push(char);\n      var part = pattern.slice(p, p + size),\n          upper = part.toUpperCase();\n      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));\n      p += size;\n    }\n\n    this.astral = pattern.length != this.chars.length;\n  }\n\n  _createClass(FuzzyMatcher, [{\n    key: \"ret\",\n    value: function ret(score, matched) {\n      this.score = score;\n      this.matched = matched;\n      return this;\n    } // Matches a given word (completion) against the pattern (input).\n    // Will return a boolean indicating whether there was a match and,\n    // on success, set `this.score` to the score, `this.matched` to an\n    // array of `from, to` pairs indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n\n  }, {\n    key: \"match\",\n    value: function match(word) {\n      if (this.pattern.length == 0) return this.ret(-100\n      /* Penalty.NotFull */\n      , []);\n      if (word.length < this.pattern.length) return null;\n      var chars = this.chars,\n          folded = this.folded,\n          any = this.any,\n          precise = this.precise,\n          byWord = this.byWord; // For single-character queries, only match when they occur right\n      // at the start\n\n      if (chars.length == 1) {\n        var first = codePointAt(word, 0),\n            firstSize = codePointSize(first);\n\n        var _score = firstSize == word.length ? 0 : -100\n        /* Penalty.NotFull */\n        ;\n\n        if (first == chars[0]) ;else if (first == folded[0]) _score += -200\n        /* Penalty.CaseFold */\n        ;else return null;\n        return this.ret(_score, [0, firstSize]);\n      }\n\n      var direct = word.indexOf(this.pattern);\n      if (direct == 0) return this.ret(word.length == this.pattern.length ? 0 : -100\n      /* Penalty.NotFull */\n      , [0, this.pattern.length]);\n      var len = chars.length,\n          anyTo = 0;\n\n      if (direct < 0) {\n        for (var i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n          var next = codePointAt(word, i);\n          if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n          i += codePointSize(next);\n        } // No match, exit immediately\n\n\n        if (anyTo < len) return null;\n      } // This tracks the extent of the precise (non-folded, not\n      // necessarily adjacent) match\n\n\n      var preciseTo = 0; // Tracks whether there is a match that hits only characters that\n      // appear to be starting words. `byWordFolded` is set to true when\n      // a case folded character is encountered in such a match\n\n      var byWordTo = 0,\n          byWordFolded = false; // If we've found a partial adjacent match, these track its state\n\n      var adjacentTo = 0,\n          adjacentStart = -1,\n          adjacentEnd = -1;\n      var hasLower = /[a-z]/.test(word),\n          wordAdjacent = true; // Go over the option's text, scanning for the various kinds of matches\n\n      for (var _i = 0, _e = Math.min(word.length, 200), prevType = 0\n      /* Tp.NonWord */\n      ; _i < _e && byWordTo < len;) {\n        var _next = codePointAt(word, _i);\n\n        if (direct < 0) {\n          if (preciseTo < len && _next == chars[preciseTo]) precise[preciseTo++] = _i;\n\n          if (adjacentTo < len) {\n            if (_next == chars[adjacentTo] || _next == folded[adjacentTo]) {\n              if (adjacentTo == 0) adjacentStart = _i;\n              adjacentEnd = _i + 1;\n              adjacentTo++;\n            } else {\n              adjacentTo = 0;\n            }\n          }\n        }\n\n        var ch = void 0,\n            type = _next < 0xff ? _next >= 48 && _next <= 57 || _next >= 97 && _next <= 122 ? 2\n        /* Tp.Lower */\n        : _next >= 65 && _next <= 90 ? 1\n        /* Tp.Upper */\n        : 0\n        /* Tp.NonWord */\n        : (ch = fromCodePoint(_next)) != ch.toLowerCase() ? 1\n        /* Tp.Upper */\n        : ch != ch.toUpperCase() ? 2\n        /* Tp.Lower */\n        : 0\n        /* Tp.NonWord */\n        ;\n\n        if (!_i || type == 1\n        /* Tp.Upper */\n        && hasLower || prevType == 0\n        /* Tp.NonWord */\n        && type != 0\n        /* Tp.NonWord */\n        ) {\n            if (chars[byWordTo] == _next || folded[byWordTo] == _next && (byWordFolded = true)) byWord[byWordTo++] = _i;else if (byWord.length) wordAdjacent = false;\n          }\n\n        prevType = type;\n        _i += codePointSize(_next);\n      }\n\n      if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100\n      /* Penalty.ByWord */\n      + (byWordFolded ? -200\n      /* Penalty.CaseFold */\n      : 0), byWord, word);\n      if (adjacentTo == len && adjacentStart == 0) return this.ret(-200\n      /* Penalty.CaseFold */\n      - word.length + (adjacentEnd == word.length ? 0 : -100\n      /* Penalty.NotFull */\n      ), [0, adjacentEnd]);\n      if (direct > -1) return this.ret(-700\n      /* Penalty.NotStart */\n      - word.length, [direct, direct + this.pattern.length]);\n      if (adjacentTo == len) return this.ret(-200\n      /* Penalty.CaseFold */\n      + -700\n      /* Penalty.NotStart */\n      - word.length, [adjacentStart, adjacentEnd]);\n      if (byWordTo == len) return this.result(-100\n      /* Penalty.ByWord */\n      + (byWordFolded ? -200\n      /* Penalty.CaseFold */\n      : 0) + -700\n      /* Penalty.NotStart */\n      + (wordAdjacent ? 0 : -1100\n      /* Penalty.Gap */\n      ), byWord, word);\n      return chars.length == 2 ? null : this.result((any[0] ? -700\n      /* Penalty.NotStart */\n      : 0) + -200\n      /* Penalty.CaseFold */\n      + -1100\n      /* Penalty.Gap */\n      , any, word);\n    }\n  }, {\n    key: \"result\",\n    value: function result(score, positions, word) {\n      var result = [],\n          i = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(positions),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var pos = _step2.value;\n          var to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);\n          if (i && result[i - 1] == pos) result[i - 1] = to;else {\n            result[i++] = pos;\n            result[i++] = to;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return this.ret(score - word.length, result);\n    }\n  }]);\n\n  return FuzzyMatcher;\n}();\n\nvar StrictMatcher = /*#__PURE__*/function () {\n  function StrictMatcher(pattern) {\n    _classCallCheck(this, StrictMatcher);\n\n    this.pattern = pattern;\n    this.matched = [];\n    this.score = 0;\n    this.folded = pattern.toLowerCase();\n  }\n\n  _createClass(StrictMatcher, [{\n    key: \"match\",\n    value: function match(word) {\n      if (word.length < this.pattern.length) return null;\n      var start = word.slice(0, this.pattern.length);\n      var match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200\n      /* Penalty.CaseFold */\n      : null;\n      if (match == null) return null;\n      this.matched = [0, start.length];\n      this.score = match + (word.length == this.pattern.length ? 0 : -100\n      /* Penalty.NotFull */\n      );\n      return this;\n    }\n  }]);\n\n  return StrictMatcher;\n}();\n\nvar completionConfig = /*@__PURE__*/Facet.define({\n  combine: function combine(configs) {\n    return combineConfig(configs, {\n      activateOnTyping: true,\n      activateOnCompletion: function activateOnCompletion() {\n        return false;\n      },\n      activateOnTypingDelay: 100,\n      selectOnOpen: true,\n      override: null,\n      closeOnBlur: true,\n      maxRenderedOptions: 100,\n      defaultKeymap: true,\n      tooltipClass: function tooltipClass() {\n        return \"\";\n      },\n      optionClass: function optionClass() {\n        return \"\";\n      },\n      aboveCursor: false,\n      icons: true,\n      addToOptions: [],\n      positionInfo: defaultPositionInfo,\n      filterStrict: false,\n      compareCompletions: function compareCompletions(a, b) {\n        return a.label.localeCompare(b.label);\n      },\n      interactionDelay: 75,\n      updateSyncTime: 100\n    }, {\n      defaultKeymap: function defaultKeymap(a, b) {\n        return a && b;\n      },\n      closeOnBlur: function closeOnBlur(a, b) {\n        return a && b;\n      },\n      icons: function icons(a, b) {\n        return a && b;\n      },\n      tooltipClass: function tooltipClass(a, b) {\n        return function (c) {\n          return joinClass(a(c), b(c));\n        };\n      },\n      optionClass: function optionClass(a, b) {\n        return function (c) {\n          return joinClass(a(c), b(c));\n        };\n      },\n      addToOptions: function addToOptions(a, b) {\n        return a.concat(b);\n      },\n      filterStrict: function filterStrict(a, b) {\n        return a || b;\n      }\n    });\n  }\n});\n\nfunction joinClass(a, b) {\n  return a ? b ? a + \" \" + b : a : b;\n}\n\nfunction defaultPositionInfo(view, list, option, info, space, tooltip) {\n  var rtl = view.textDirection == Direction.RTL,\n      left = rtl,\n      narrow = false;\n  var side = \"top\",\n      offset,\n      maxWidth;\n  var spaceLeft = list.left - space.left,\n      spaceRight = space.right - list.right;\n  var infoWidth = info.right - info.left,\n      infoHeight = info.bottom - info.top;\n  if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false;else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true;\n\n  if (infoWidth <= (left ? spaceLeft : spaceRight)) {\n    offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;\n    maxWidth = Math.min(400\n    /* Info.Width */\n    , left ? spaceLeft : spaceRight);\n  } else {\n    narrow = true;\n    maxWidth = Math.min(400\n    /* Info.Width */\n    , (rtl ? list.right : space.right - list.left) - 30\n    /* Info.Margin */\n    );\n    var spaceBelow = space.bottom - list.bottom;\n\n    if (spaceBelow >= infoHeight || spaceBelow > list.top) {\n      // Below the completion\n      offset = option.bottom - list.top;\n    } else {\n      // Above it\n      side = \"bottom\";\n      offset = list.bottom - option.top;\n    }\n  }\n\n  var scaleY = (list.bottom - list.top) / tooltip.offsetHeight;\n  var scaleX = (list.right - list.left) / tooltip.offsetWidth;\n  return {\n    style: \"\".concat(side, \": \").concat(offset / scaleY, \"px; max-width: \").concat(maxWidth / scaleX, \"px\"),\n    class: \"cm-completionInfo-\" + (narrow ? rtl ? \"left-narrow\" : \"right-narrow\" : left ? \"left\" : \"right\")\n  };\n}\n\nfunction optionContent(config) {\n  var content = config.addToOptions.slice();\n  if (config.icons) content.push({\n    render: function render(completion) {\n      var _icon$classList;\n\n      var icon = document.createElement(\"div\");\n      icon.classList.add(\"cm-completionIcon\");\n      if (completion.type) (_icon$classList = icon.classList).add.apply(_icon$classList, _toConsumableArray(completion.type.split(/\\s+/g).map(function (cls) {\n        return \"cm-completionIcon-\" + cls;\n      })));\n      icon.setAttribute(\"aria-hidden\", \"true\");\n      return icon;\n    },\n    position: 20\n  });\n  content.push({\n    render: function render(completion, _s, _v, match) {\n      var labelElt = document.createElement(\"span\");\n      labelElt.className = \"cm-completionLabel\";\n      var label = completion.displayLabel || completion.label,\n          off = 0;\n\n      for (var j = 0; j < match.length;) {\n        var from = match[j++],\n            to = match[j++];\n        if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n        var span = labelElt.appendChild(document.createElement(\"span\"));\n        span.appendChild(document.createTextNode(label.slice(from, to)));\n        span.className = \"cm-completionMatchedText\";\n        off = to;\n      }\n\n      if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n      return labelElt;\n    },\n    position: 50\n  }, {\n    render: function render(completion) {\n      if (!completion.detail) return null;\n      var detailElt = document.createElement(\"span\");\n      detailElt.className = \"cm-completionDetail\";\n      detailElt.textContent = completion.detail;\n      return detailElt;\n    },\n    position: 80\n  });\n  return content.sort(function (a, b) {\n    return a.position - b.position;\n  }).map(function (a) {\n    return a.render;\n  });\n}\n\nfunction rangeAroundSelected(total, selected, max) {\n  if (total <= max) return {\n    from: 0,\n    to: total\n  };\n  if (selected < 0) selected = 0;\n\n  if (selected <= total >> 1) {\n    var _off = Math.floor(selected / max);\n\n    return {\n      from: _off * max,\n      to: (_off + 1) * max\n    };\n  }\n\n  var off = Math.floor((total - selected) / max);\n  return {\n    from: total - (off + 1) * max,\n    to: total - off * max\n  };\n}\n\nvar CompletionTooltip = /*#__PURE__*/function () {\n  function CompletionTooltip(view, stateField, applyCompletion) {\n    var _this = this;\n\n    _classCallCheck(this, CompletionTooltip);\n\n    this.view = view;\n    this.stateField = stateField;\n    this.applyCompletion = applyCompletion;\n    this.info = null;\n    this.infoDestroy = null;\n    this.placeInfoReq = {\n      read: function read() {\n        return _this.measureInfo();\n      },\n      write: function write(pos) {\n        return _this.placeInfo(pos);\n      },\n      key: this\n    };\n    this.space = null;\n    this.currentClass = \"\";\n    var cState = view.state.field(stateField);\n    var _cState$open = cState.open,\n        options = _cState$open.options,\n        selected = _cState$open.selected;\n    var config = view.state.facet(completionConfig);\n    this.optionContent = optionContent(config);\n    this.optionClass = config.optionClass;\n    this.tooltipClass = config.tooltipClass;\n    this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-tooltip-autocomplete\";\n    this.updateTooltipClass(view.state);\n    this.dom.addEventListener(\"mousedown\", function (e) {\n      var options = view.state.field(stateField).open.options;\n\n      for (var dom = e.target, match; dom && dom != _this.dom; dom = dom.parentNode) {\n        if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n          _this.applyCompletion(view, options[+match[1]]);\n\n          e.preventDefault();\n          return;\n        }\n      }\n    });\n    this.dom.addEventListener(\"focusout\", function (e) {\n      var state = view.state.field(_this.stateField, false);\n      if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM) view.dispatch({\n        effects: closeCompletionEffect.of(null)\n      });\n    });\n    this.showOptions(options, cState.id);\n  }\n\n  _createClass(CompletionTooltip, [{\n    key: \"mount\",\n    value: function mount() {\n      this.updateSel();\n    }\n  }, {\n    key: \"showOptions\",\n    value: function showOptions(options, id) {\n      var _this2 = this;\n\n      if (this.list) this.list.remove();\n      this.list = this.dom.appendChild(this.createListBox(options, id, this.range));\n      this.list.addEventListener(\"scroll\", function () {\n        if (_this2.info) _this2.view.requestMeasure(_this2.placeInfoReq);\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update) {\n      var _a;\n\n      var cState = _update.state.field(this.stateField);\n\n      var prevState = _update.startState.field(this.stateField);\n\n      this.updateTooltipClass(_update.state);\n\n      if (cState != prevState) {\n        var _cState$open2 = cState.open,\n            options = _cState$open2.options,\n            selected = _cState$open2.selected,\n            disabled = _cState$open2.disabled;\n\n        if (!prevState.open || prevState.open.options != options) {\n          this.range = rangeAroundSelected(options.length, selected, _update.state.facet(completionConfig).maxRenderedOptions);\n          this.showOptions(options, cState.id);\n        }\n\n        this.updateSel();\n        if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled)) this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!disabled);\n      }\n    }\n  }, {\n    key: \"updateTooltipClass\",\n    value: function updateTooltipClass(state) {\n      var cls = this.tooltipClass(state);\n\n      if (cls != this.currentClass) {\n        var _iterator3 = _createForOfIteratorHelper(this.currentClass.split(\" \")),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var c = _step3.value;\n            if (c) this.dom.classList.remove(c);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        var _iterator4 = _createForOfIteratorHelper(cls.split(\" \")),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _c = _step4.value;\n            if (_c) this.dom.classList.add(_c);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        this.currentClass = cls;\n      }\n    }\n  }, {\n    key: \"positioned\",\n    value: function positioned(space) {\n      this.space = space;\n      if (this.info) this.view.requestMeasure(this.placeInfoReq);\n    }\n  }, {\n    key: \"updateSel\",\n    value: function updateSel() {\n      var _this3 = this;\n\n      var cState = this.view.state.field(this.stateField),\n          open = cState.open;\n\n      if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n        this.showOptions(open.options, cState.id);\n      }\n\n      if (this.updateSelectedOption(open.selected)) {\n        this.destroyInfo();\n        var completion = open.options[open.selected].completion;\n        var info = completion.info;\n        if (!info) return;\n        var infoResult = typeof info === \"string\" ? document.createTextNode(info) : info(completion);\n        if (!infoResult) return;\n\n        if (\"then\" in infoResult) {\n          infoResult.then(function (obj) {\n            if (obj && _this3.view.state.field(_this3.stateField, false) == cState) _this3.addInfoPane(obj, completion);\n          }).catch(function (e) {\n            return logException(_this3.view.state, e, \"completion info\");\n          });\n        } else {\n          this.addInfoPane(infoResult, completion);\n        }\n      }\n    }\n  }, {\n    key: \"addInfoPane\",\n    value: function addInfoPane(content, completion) {\n      this.destroyInfo();\n      var wrap = this.info = document.createElement(\"div\");\n      wrap.className = \"cm-tooltip cm-completionInfo\";\n\n      if (content.nodeType != null) {\n        wrap.appendChild(content);\n        this.infoDestroy = null;\n      } else {\n        var dom = content.dom,\n            destroy = content.destroy;\n        wrap.appendChild(dom);\n        this.infoDestroy = destroy || null;\n      }\n\n      this.dom.appendChild(wrap);\n      this.view.requestMeasure(this.placeInfoReq);\n    }\n  }, {\n    key: \"updateSelectedOption\",\n    value: function updateSelectedOption(selected) {\n      var set = null;\n\n      for (var opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n        if (opt.nodeName != \"LI\" || !opt.id) {\n          i--; // A section header\n        } else if (i == selected) {\n          if (!opt.hasAttribute(\"aria-selected\")) {\n            opt.setAttribute(\"aria-selected\", \"true\");\n            set = opt;\n          }\n        } else {\n          if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n        }\n      }\n\n      if (set) scrollIntoView(this.list, set);\n      return set;\n    }\n  }, {\n    key: \"measureInfo\",\n    value: function measureInfo() {\n      var sel = this.dom.querySelector(\"[aria-selected]\");\n      if (!sel || !this.info) return null;\n      var listRect = this.dom.getBoundingClientRect();\n      var infoRect = this.info.getBoundingClientRect();\n      var selRect = sel.getBoundingClientRect();\n      var space = this.space;\n\n      if (!space) {\n        var win = this.dom.ownerDocument.defaultView || window;\n        space = {\n          left: 0,\n          top: 0,\n          right: win.innerWidth,\n          bottom: win.innerHeight\n        };\n      }\n\n      if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;\n      return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);\n    }\n  }, {\n    key: \"placeInfo\",\n    value: function placeInfo(pos) {\n      if (this.info) {\n        if (pos) {\n          if (pos.style) this.info.style.cssText = pos.style;\n          this.info.className = \"cm-tooltip cm-completionInfo \" + (pos.class || \"\");\n        } else {\n          this.info.style.cssText = \"top: -1e6px\";\n        }\n      }\n    }\n  }, {\n    key: \"createListBox\",\n    value: function createListBox(options, id, range) {\n      var ul = document.createElement(\"ul\");\n      ul.id = id;\n      ul.setAttribute(\"role\", \"listbox\");\n      ul.setAttribute(\"aria-expanded\", \"true\");\n      ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n      var curSection = null;\n\n      for (var i = range.from; i < range.to; i++) {\n        var _options$i = options[i],\n            completion = _options$i.completion,\n            match = _options$i.match,\n            section = completion.section;\n\n        if (section) {\n          var name = typeof section == \"string\" ? section : section.name;\n\n          if (name != curSection && (i > range.from || range.from == 0)) {\n            curSection = name;\n\n            if (typeof section != \"string\" && section.header) {\n              ul.appendChild(section.header(section));\n            } else {\n              var header = ul.appendChild(document.createElement(\"completion-section\"));\n              header.textContent = name;\n            }\n          }\n        }\n\n        var li = ul.appendChild(document.createElement(\"li\"));\n        li.id = id + \"-\" + i;\n        li.setAttribute(\"role\", \"option\");\n        var cls = this.optionClass(completion);\n        if (cls) li.className = cls;\n\n        var _iterator5 = _createForOfIteratorHelper(this.optionContent),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var source = _step5.value;\n            var node = source(completion, this.view.state, this.view, match);\n            if (node) li.appendChild(node);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n\n      if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n      if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n      return ul;\n    }\n  }, {\n    key: \"destroyInfo\",\n    value: function destroyInfo() {\n      if (this.info) {\n        if (this.infoDestroy) this.infoDestroy();\n        this.info.remove();\n        this.info = null;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.destroyInfo();\n    }\n  }]);\n\n  return CompletionTooltip;\n}();\n\nfunction completionTooltip(stateField, applyCompletion) {\n  return function (view) {\n    return new CompletionTooltip(view, stateField, applyCompletion);\n  };\n}\n\nfunction scrollIntoView(container, element) {\n  var parent = container.getBoundingClientRect();\n  var self = element.getBoundingClientRect();\n  var scaleY = parent.height / container.offsetHeight;\n  if (self.top < parent.top) container.scrollTop -= (parent.top - self.top) / scaleY;else if (self.bottom > parent.bottom) container.scrollTop += (self.bottom - parent.bottom) / scaleY;\n} // Used to pick a preferred option when two options with the same\n// label occur in the result.\n\n\nfunction score(option) {\n  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\n\nfunction sortOptions(active, state) {\n  var options = [];\n  var sections = null;\n\n  var addOption = function addOption(option) {\n    options.push(option);\n    var section = option.completion.section;\n\n    if (section) {\n      if (!sections) sections = [];\n      var name = typeof section == \"string\" ? section : section.name;\n      if (!sections.some(function (s) {\n        return s.name == name;\n      })) sections.push(typeof section == \"string\" ? {\n        name: name\n      } : section);\n    }\n  };\n\n  var conf = state.facet(completionConfig);\n\n  var _iterator6 = _createForOfIteratorHelper(active),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var a = _step6.value;\n\n      if (a.hasResult()) {\n        var getMatch = a.result.getMatch;\n\n        if (a.result.filter === false) {\n          var _iterator10 = _createForOfIteratorHelper(a.result.options),\n              _step10;\n\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var _option = _step10.value;\n              addOption(new Option(_option, a.source, getMatch ? getMatch(_option) : [], 1e9 - options.length));\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        } else {\n          var pattern = state.sliceDoc(a.from, a.to),\n              match = void 0;\n          var matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);\n\n          var _iterator11 = _createForOfIteratorHelper(a.result.options),\n              _step11;\n\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var _option2 = _step11.value;\n\n              if (match = matcher.match(_option2.label)) {\n                var matched = !_option2.displayLabel ? match.matched : getMatch ? getMatch(_option2, match.matched) : [];\n                addOption(new Option(_option2, a.source, matched, match.score + (_option2.boost || 0)));\n              }\n            }\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  if (sections) {\n    var sectionOrder = Object.create(null),\n        pos = 0;\n\n    var cmp = function cmp(a, b) {\n      var _a, _b;\n\n      return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1);\n    };\n\n    var _iterator7 = _createForOfIteratorHelper(sections.sort(cmp)),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var s = _step7.value;\n        pos -= 1e5;\n        sectionOrder[s.name] = pos;\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    var _iterator8 = _createForOfIteratorHelper(options),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var option = _step8.value;\n        var section = option.completion.section;\n        if (section) option.score += sectionOrder[typeof section == \"string\" ? section : section.name];\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n  }\n\n  var result = [],\n      prev = null;\n  var compare = conf.compareCompletions;\n\n  var _iterator9 = _createForOfIteratorHelper(options.sort(function (a, b) {\n    return b.score - a.score || compare(a.completion, b.completion);\n  })),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var opt = _step9.value;\n      var _cur = opt.completion;\n      if (!prev || prev.label != _cur.label || prev.detail != _cur.detail || prev.type != null && _cur.type != null && prev.type != _cur.type || prev.apply != _cur.apply || prev.boost != _cur.boost) result.push(opt);else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n      prev = opt.completion;\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  return result;\n}\n\nvar CompletionDialog = /*#__PURE__*/function () {\n  function CompletionDialog(options, attrs, tooltip, timestamp, selected, disabled) {\n    _classCallCheck(this, CompletionDialog);\n\n    this.options = options;\n    this.attrs = attrs;\n    this.tooltip = tooltip;\n    this.timestamp = timestamp;\n    this.selected = selected;\n    this.disabled = disabled;\n  }\n\n  _createClass(CompletionDialog, [{\n    key: \"setSelected\",\n    value: function setSelected(selected, id) {\n      return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n    }\n  }, {\n    key: \"map\",\n    value: function map(changes) {\n      return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n        pos: changes.mapPos(this.tooltip.pos)\n      }), this.timestamp, this.selected, this.disabled);\n    }\n  }], [{\n    key: \"build\",\n    value: function build(active, state, id, prev, conf) {\n      var options = sortOptions(active, state);\n\n      if (!options.length) {\n        return prev && active.some(function (a) {\n          return a.state == 1;\n        }\n        /* State.Pending */\n        ) ? new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;\n      }\n\n      var selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n\n      if (prev && prev.selected != selected && prev.selected != -1) {\n        var selectedValue = prev.options[prev.selected].completion;\n\n        for (var i = 0; i < options.length; i++) {\n          if (options[i].completion == selectedValue) {\n            selected = i;\n            break;\n          }\n        }\n      }\n\n      return new CompletionDialog(options, makeAttrs(id, selected), {\n        pos: active.reduce(function (a, b) {\n          return b.hasResult() ? Math.min(a, b.from) : a;\n        }, 1e8),\n        create: createTooltip,\n        above: conf.aboveCursor\n      }, prev ? prev.timestamp : Date.now(), selected, false);\n    }\n  }]);\n\n  return CompletionDialog;\n}();\n\nvar CompletionState = /*#__PURE__*/function () {\n  function CompletionState(active, id, open) {\n    _classCallCheck(this, CompletionState);\n\n    this.active = active;\n    this.id = id;\n    this.open = open;\n  }\n\n  _createClass(CompletionState, [{\n    key: \"update\",\n    value: function update(tr) {\n      var _this4 = this;\n\n      var state = tr.state,\n          conf = state.facet(completionConfig);\n      var sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n      var active = sources.map(function (source) {\n        var value = _this4.active.find(function (s) {\n          return s.source == source;\n        }) || new ActiveSource(source, _this4.active.some(function (a) {\n          return a.state != 0;\n        }\n        /* State.Inactive */\n        ) ? 1\n        /* State.Pending */\n        : 0\n        /* State.Inactive */\n        );\n        return value.update(tr, conf);\n      });\n      if (active.length == this.active.length && active.every(function (a, i) {\n        return a == _this4.active[i];\n      })) active = this.active;\n      var open = this.open;\n      if (open && tr.docChanged) open = open.map(tr.changes);\n      if (tr.selection || active.some(function (a) {\n        return a.hasResult() && tr.changes.touchesRange(a.from, a.to);\n      }) || !sameResults(active, this.active)) open = CompletionDialog.build(active, state, this.id, open, conf);else if (open && open.disabled && !active.some(function (a) {\n        return a.state == 1;\n      }\n      /* State.Pending */\n      )) open = null;\n      if (!open && active.every(function (a) {\n        return a.state != 1;\n      }\n      /* State.Pending */\n      ) && active.some(function (a) {\n        return a.hasResult();\n      })) active = active.map(function (a) {\n        return a.hasResult() ? new ActiveSource(a.source, 0\n        /* State.Inactive */\n        ) : a;\n      });\n\n      var _iterator12 = _createForOfIteratorHelper(tr.effects),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var effect = _step12.value;\n          if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n  }, {\n    key: \"tooltip\",\n    get: function get() {\n      return this.open ? this.open.tooltip : null;\n    }\n  }, {\n    key: \"attrs\",\n    get: function get() {\n      return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs;\n    }\n  }], [{\n    key: \"start\",\n    value: function start() {\n      return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n  }]);\n\n  return CompletionState;\n}();\n\nfunction sameResults(a, b) {\n  if (a == b) return true;\n\n  for (var iA = 0, iB = 0;;) {\n    while (iA < a.length && !a[iA].hasResult) {\n      iA++;\n    }\n\n    while (iB < b.length && !b[iB].hasResult) {\n      iB++;\n    }\n\n    var endA = iA == a.length,\n        endB = iB == b.length;\n    if (endA || endB) return endA == endB;\n    if (a[iA++].result != b[iB++].result) return false;\n  }\n}\n\nvar baseAttrs = {\n  \"aria-autocomplete\": \"list\"\n};\nvar noAttrs = {};\n\nfunction makeAttrs(id, selected) {\n  var result = {\n    \"aria-autocomplete\": \"list\",\n    \"aria-haspopup\": \"listbox\",\n    \"aria-controls\": id\n  };\n  if (selected > -1) result[\"aria-activedescendant\"] = id + \"-\" + selected;\n  return result;\n}\n\nvar none = [];\n\nfunction getUpdateType(tr, conf) {\n  if (tr.isUserEvent(\"input.complete\")) {\n    var completion = tr.annotation(pickedCompletion);\n    if (completion && conf.activateOnCompletion(completion)) return 4\n    /* UpdateType.Activate */\n    | 8\n    /* UpdateType.Reset */\n    ;\n  }\n\n  var typing = tr.isUserEvent(\"input.type\");\n  return typing && conf.activateOnTyping ? 4\n  /* UpdateType.Activate */\n  | 1\n  /* UpdateType.Typing */\n  : typing ? 1\n  /* UpdateType.Typing */\n  : tr.isUserEvent(\"delete.backward\") ? 2\n  /* UpdateType.Backspacing */\n  : tr.selection ? 8\n  /* UpdateType.Reset */\n  : tr.docChanged ? 16\n  /* UpdateType.ResetIfTouching */\n  : 0\n  /* UpdateType.None */\n  ;\n}\n\nvar ActiveSource = /*#__PURE__*/function () {\n  function ActiveSource(source, state) {\n    var explicitPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n    _classCallCheck(this, ActiveSource);\n\n    this.source = source;\n    this.state = state;\n    this.explicitPos = explicitPos;\n  }\n\n  _createClass(ActiveSource, [{\n    key: \"hasResult\",\n    value: function hasResult() {\n      return false;\n    }\n  }, {\n    key: \"update\",\n    value: function update(tr, conf) {\n      var type = getUpdateType(tr, conf),\n          value = this;\n      if (type & 8\n      /* UpdateType.Reset */\n      || type & 16\n      /* UpdateType.ResetIfTouching */\n      && this.touches(tr)) value = new ActiveSource(value.source, 0\n      /* State.Inactive */\n      );\n      if (type & 4\n      /* UpdateType.Activate */\n      && value.state == 0\n      /* State.Inactive */\n      ) value = new ActiveSource(this.source, 1\n        /* State.Pending */\n        );\n      value = value.updateFor(tr, type);\n\n      var _iterator13 = _createForOfIteratorHelper(tr.effects),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var effect = _step13.value;\n          if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1\n          /* State.Pending */\n          , effect.value ? cur(tr.state) : -1);else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0\n          /* State.Inactive */\n          );else if (effect.is(setActiveEffect)) {\n            var _iterator14 = _createForOfIteratorHelper(effect.value),\n                _step14;\n\n            try {\n              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                var active = _step14.value;\n                if (active.source == value.source) value = active;\n              }\n            } catch (err) {\n              _iterator14.e(err);\n            } finally {\n              _iterator14.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"updateFor\",\n    value: function updateFor(tr, type) {\n      return this.map(tr.changes);\n    }\n  }, {\n    key: \"map\",\n    value: function map(changes) {\n      return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n    }\n  }, {\n    key: \"touches\",\n    value: function touches(tr) {\n      return tr.changes.touchesRange(cur(tr.state));\n    }\n  }]);\n\n  return ActiveSource;\n}();\n\nvar ActiveResult = /*#__PURE__*/function (_ActiveSource) {\n  _inherits(ActiveResult, _ActiveSource);\n\n  var _super = _createSuper(ActiveResult);\n\n  function ActiveResult(source, explicitPos, result, from, to) {\n    var _this5;\n\n    _classCallCheck(this, ActiveResult);\n\n    _this5 = _super.call(this, source, 2\n    /* State.Result */\n    , explicitPos);\n    _this5.result = result;\n    _this5.from = from;\n    _this5.to = to;\n    return _this5;\n  }\n\n  _createClass(ActiveResult, [{\n    key: \"hasResult\",\n    value: function hasResult() {\n      return true;\n    }\n  }, {\n    key: \"updateFor\",\n    value: function updateFor(tr, type) {\n      var _a;\n\n      if (!(type & 3\n      /* UpdateType.SimpleInteraction */\n      )) return this.map(tr.changes);\n      var result = this.result;\n      if (result.map && !tr.changes.empty) result = result.map(result, tr.changes);\n      var from = tr.changes.mapPos(this.from),\n          to = tr.changes.mapPos(this.to, 1);\n      var pos = cur(tr.state);\n      if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || !result || type & 2\n      /* UpdateType.Backspacing */\n      && cur(tr.startState) == this.from) return new ActiveSource(this.source, type & 4\n      /* UpdateType.Activate */\n      ? 1\n      /* State.Pending */\n      : 0\n      /* State.Inactive */\n      );\n      var explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos);\n      if (checkValid(result.validFor, tr.state, from, to)) return new ActiveResult(this.source, explicitPos, result, from, to);\n      if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0)))) return new ActiveResult(this.source, explicitPos, result, result.from, (_a = result.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n      return new ActiveSource(this.source, 1\n      /* State.Pending */\n      , explicitPos);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      if (mapping.empty) return this;\n      var result = this.result.map ? this.result.map(this.result, mapping) : this.result;\n      if (!result) return new ActiveSource(this.source, 0\n      /* State.Inactive */\n      );\n      return new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n  }, {\n    key: \"touches\",\n    value: function touches(tr) {\n      return tr.changes.touchesRange(this.from, this.to);\n    }\n  }]);\n\n  return ActiveResult;\n}(ActiveSource);\n\nfunction checkValid(validFor, state, from, to) {\n  if (!validFor) return false;\n  var text = state.sliceDoc(from, to);\n  return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\n\nvar setActiveEffect = /*@__PURE__*/StateEffect.define({\n  map: function map(sources, mapping) {\n    return sources.map(function (s) {\n      return s.map(mapping);\n    });\n  }\n});\nvar setSelectedEffect = /*@__PURE__*/StateEffect.define();\nvar completionState = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return CompletionState.start();\n  },\n  update: function update(value, tr) {\n    return value.update(tr);\n  },\n  provide: function provide(f) {\n    return [showTooltip.from(f, function (val) {\n      return val.tooltip;\n    }), EditorView.contentAttributes.from(f, function (state) {\n      return state.attrs;\n    })];\n  }\n});\n\nfunction applyCompletion(view, option) {\n  var apply = option.completion.apply || option.completion.label;\n  var result = view.state.field(completionState).active.find(function (a) {\n    return a.source == option.source;\n  });\n  if (!(result instanceof ActiveResult)) return false;\n  if (typeof apply == \"string\") view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {\n    annotations: pickedCompletion.of(option.completion)\n  }));else apply(view, option.completion, result.from, result.to);\n  return true;\n}\n\nvar createTooltip = /*@__PURE__*/completionTooltip(completionState, applyCompletion);\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\n\nfunction moveCompletionSelection(forward) {\n  var by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"option\";\n  return function (view) {\n    var cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n    var step = 1,\n        tooltip;\n    if (by == \"page\" && (tooltip = getTooltip(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n    var length = cState.open.options.length;\n    var selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n    if (selected < 0) selected = by == \"page\" ? 0 : length - 1;else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n    view.dispatch({\n      effects: setSelectedEffect.of(selected)\n    });\n    return true;\n  };\n}\n/**\nAccept the current completion.\n*/\n\n\nvar acceptCompletion = function acceptCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n  return applyCompletion(view, cState.open.options[cState.open.selected]);\n};\n/**\nExplicitly start autocompletion.\n*/\n\n\nvar startCompletion = function startCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (!cState) return false;\n  view.dispatch({\n    effects: startCompletionEffect.of(true)\n  });\n  return true;\n};\n/**\nClose the currently active completion.\n*/\n\n\nvar closeCompletion = function closeCompletion(view) {\n  var cState = view.state.field(completionState, false);\n  if (!cState || !cState.active.some(function (a) {\n    return a.state != 0;\n  }\n  /* State.Inactive */\n  )) return false;\n  view.dispatch({\n    effects: closeCompletionEffect.of(null)\n  });\n  return true;\n};\n\nvar RunningQuery = function RunningQuery(active, context) {\n  _classCallCheck(this, RunningQuery);\n\n  this.active = active;\n  this.context = context;\n  this.time = Date.now();\n  this.updates = []; // Note that 'undefined' means 'not done yet', whereas 'null' means\n  // 'query returned null'.\n\n  this.done = undefined;\n};\n\nvar MaxUpdateCount = 50,\n    MinAbortTime = 1000;\nvar completionPlugin = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.view = view;\n    this.debounceUpdate = -1;\n    this.running = [];\n    this.debounceAccept = -1;\n    this.pendingStart = false;\n    this.composing = 0\n    /* CompositionState.None */\n    ;\n\n    var _iterator15 = _createForOfIteratorHelper(view.state.field(completionState).active),\n        _step15;\n\n    try {\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        var active = _step15.value;\n        if (active.state == 1\n        /* State.Pending */\n        ) this.startQuery(active);\n      }\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n  }\n\n  _createClass(_class, [{\n    key: \"update\",\n    value: function update(_update2) {\n      var _this6 = this;\n\n      var cState = _update2.state.field(completionState);\n\n      var conf = _update2.state.facet(completionConfig);\n\n      if (!_update2.selectionSet && !_update2.docChanged && _update2.startState.field(completionState) == cState) return;\n\n      var doesReset = _update2.transactions.some(function (tr) {\n        var type = getUpdateType(tr, conf);\n        return type & 8\n        /* UpdateType.Reset */\n        || (tr.selection || tr.docChanged) && !(type & 3\n        /* UpdateType.SimpleInteraction */\n        );\n      });\n\n      for (var i = 0; i < this.running.length; i++) {\n        var query = this.running[i];\n\n        if (doesReset || query.context.abortOnDocChange && _update2.docChanged || query.updates.length + _update2.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n          var _iterator16 = _createForOfIteratorHelper(query.context.abortListeners),\n              _step16;\n\n          try {\n            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n              var handler = _step16.value;\n\n              try {\n                handler();\n              } catch (e) {\n                logException(this.view.state, e);\n              }\n            }\n          } catch (err) {\n            _iterator16.e(err);\n          } finally {\n            _iterator16.f();\n          }\n\n          query.context.abortListeners = null;\n          this.running.splice(i--, 1);\n        } else {\n          var _query$updates;\n\n          (_query$updates = query.updates).push.apply(_query$updates, _toConsumableArray(_update2.transactions));\n        }\n      }\n\n      if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n      if (_update2.transactions.some(function (tr) {\n        return tr.effects.some(function (e) {\n          return e.is(startCompletionEffect);\n        });\n      })) this.pendingStart = true;\n      var delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;\n      this.debounceUpdate = cState.active.some(function (a) {\n        return a.state == 1\n        /* State.Pending */\n        && !_this6.running.some(function (q) {\n          return q.active.source == a.source;\n        });\n      }) ? setTimeout(function () {\n        return _this6.startUpdate();\n      }, delay) : -1;\n\n      if (this.composing != 0\n      /* CompositionState.None */\n      ) {\n        var _iterator17 = _createForOfIteratorHelper(_update2.transactions),\n            _step17;\n\n        try {\n          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n            var tr = _step17.value;\n            if (tr.isUserEvent(\"input.type\")) this.composing = 2\n            /* CompositionState.Changed */\n            ;else if (this.composing == 2\n            /* CompositionState.Changed */\n            && tr.selection) this.composing = 3\n            /* CompositionState.ChangedAndMoved */\n            ;\n          }\n        } catch (err) {\n          _iterator17.e(err);\n        } finally {\n          _iterator17.f();\n        }\n      }\n    }\n  }, {\n    key: \"startUpdate\",\n    value: function startUpdate() {\n      var _this7 = this;\n\n      this.debounceUpdate = -1;\n      this.pendingStart = false;\n      var state = this.view.state,\n          cState = state.field(completionState);\n\n      var _iterator18 = _createForOfIteratorHelper(cState.active),\n          _step18;\n\n      try {\n        var _loop = function _loop() {\n          var active = _step18.value;\n          if (active.state == 1\n          /* State.Pending */\n          && !_this7.running.some(function (r) {\n            return r.active.source == active.source;\n          })) _this7.startQuery(active);\n        };\n\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n    }\n  }, {\n    key: \"startQuery\",\n    value: function startQuery(active) {\n      var _this8 = this;\n\n      var state = this.view.state,\n          pos = cur(state);\n      var context = new CompletionContext(state, pos, active.explicitPos == pos, this.view);\n      var pending = new RunningQuery(active, context);\n      this.running.push(pending);\n      Promise.resolve(active.source(context)).then(function (result) {\n        if (!pending.context.aborted) {\n          pending.done = result || null;\n\n          _this8.scheduleAccept();\n        }\n      }, function (err) {\n        _this8.view.dispatch({\n          effects: closeCompletionEffect.of(null)\n        });\n\n        logException(_this8.view.state, err);\n      });\n    }\n  }, {\n    key: \"scheduleAccept\",\n    value: function scheduleAccept() {\n      var _this9 = this;\n\n      if (this.running.every(function (q) {\n        return q.done !== undefined;\n      })) this.accept();else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(function () {\n        return _this9.accept();\n      }, this.view.state.facet(completionConfig).updateSyncTime);\n    } // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n\n  }, {\n    key: \"accept\",\n    value: function accept() {\n      var _this10 = this;\n\n      var _a;\n\n      if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n      this.debounceAccept = -1;\n      var updated = [];\n      var conf = this.view.state.facet(completionConfig);\n\n      var _loop2 = function _loop2(_i2) {\n        var query = _this10.running[_i2];\n\n        if (query.done === undefined) {\n          i = _i2;\n          return \"continue\";\n        }\n\n        _this10.running.splice(_i2--, 1);\n\n        if (query.done) {\n          var active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : _this10.view.state)); // Replay the transactions that happened since the start of\n          // the request and see if that preserves the result\n\n          var _iterator19 = _createForOfIteratorHelper(query.updates),\n              _step19;\n\n          try {\n            for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n              var tr = _step19.value;\n              active = active.update(tr, conf);\n            }\n          } catch (err) {\n            _iterator19.e(err);\n          } finally {\n            _iterator19.f();\n          }\n\n          if (active.hasResult()) {\n            updated.push(active);\n            i = _i2;\n            return \"continue\";\n          }\n        }\n\n        var current = _this10.view.state.field(completionState).active.find(function (a) {\n          return a.source == query.active.source;\n        });\n\n        if (current && current.state == 1\n        /* State.Pending */\n        ) {\n            if (query.done == null) {\n              // Explicitly failed. Should clear the pending status if it\n              // hasn't been re-set in the meantime.\n              var _active = new ActiveSource(query.active.source, 0\n              /* State.Inactive */\n              );\n\n              var _iterator20 = _createForOfIteratorHelper(query.updates),\n                  _step20;\n\n              try {\n                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                  var _tr = _step20.value;\n                  _active = _active.update(_tr, conf);\n                }\n              } catch (err) {\n                _iterator20.e(err);\n              } finally {\n                _iterator20.f();\n              }\n\n              if (_active.state != 1\n              /* State.Pending */\n              ) updated.push(_active);\n            } else {\n              // Cleared by subsequent transactions. Restart.\n              _this10.startQuery(current);\n            }\n          }\n\n        i = _i2;\n      };\n\n      for (var i = 0; i < this.running.length; i++) {\n        var _ret = _loop2(i);\n\n        if (_ret === \"continue\") continue;\n      }\n\n      if (updated.length) this.view.dispatch({\n        effects: setActiveEffect.of(updated)\n      });\n    }\n  }]);\n\n  return _class;\n}(), {\n  eventHandlers: {\n    blur: function blur(event) {\n      var _this11 = this;\n\n      var state = this.view.state.field(completionState, false);\n\n      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {\n        var dialog = state.open && getTooltip(this.view, state.open.tooltip);\n        if (!dialog || !dialog.dom.contains(event.relatedTarget)) setTimeout(function () {\n          return _this11.view.dispatch({\n            effects: closeCompletionEffect.of(null)\n          });\n        }, 10);\n      }\n    },\n    compositionstart: function compositionstart() {\n      this.composing = 1\n      /* CompositionState.Started */\n      ;\n    },\n    compositionend: function compositionend() {\n      var _this12 = this;\n\n      if (this.composing == 3\n      /* CompositionState.ChangedAndMoved */\n      ) {\n          // Safari fires compositionend events synchronously, possibly\n          // from inside an update, so dispatch asynchronously to avoid reentrancy\n          setTimeout(function () {\n            return _this12.view.dispatch({\n              effects: startCompletionEffect.of(false)\n            });\n          }, 20);\n        }\n\n      this.composing = 0\n      /* CompositionState.None */\n      ;\n    }\n  }\n});\nvar windows = typeof navigator == \"object\" && /*@__PURE__*/ /Win/.test(navigator.platform);\nvar commitCharacters = /*@__PURE__*/Prec.highest( /*@__PURE__*/EditorView.domEventHandlers({\n  keydown: function keydown(event, view) {\n    var field = view.state.field(completionState, false);\n    if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey) return false;\n    var option = field.open.options[field.open.selected];\n    var result = field.active.find(function (a) {\n      return a.source == option.source;\n    });\n    var commitChars = option.completion.commitCharacters || result.result.commitCharacters;\n    if (commitChars && commitChars.indexOf(event.key) > -1) applyCompletion(view, option);\n    return false;\n  }\n}));\nvar baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-tooltip.cm-tooltip-autocomplete\": {\n    \"& > ul\": {\n      fontFamily: \"monospace\",\n      whiteSpace: \"nowrap\",\n      overflow: \"hidden auto\",\n      maxWidth_fallback: \"700px\",\n      maxWidth: \"min(700px, 95vw)\",\n      minWidth: \"250px\",\n      maxHeight: \"10em\",\n      height: \"100%\",\n      listStyle: \"none\",\n      margin: 0,\n      padding: 0,\n      \"& > li, & > completion-section\": {\n        padding: \"1px 3px\",\n        lineHeight: 1.2\n      },\n      \"& > li\": {\n        overflowX: \"hidden\",\n        textOverflow: \"ellipsis\",\n        cursor: \"pointer\"\n      },\n      \"& > completion-section\": {\n        display: \"list-item\",\n        borderBottom: \"1px solid silver\",\n        paddingLeft: \"0.5em\",\n        opacity: 0.7\n      }\n    }\n  },\n  \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#17c\",\n    color: \"white\"\n  },\n  \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n    background: \"#777\"\n  },\n  \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#347\",\n    color: \"white\"\n  },\n  \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n    background: \"#444\"\n  },\n  \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n    content: '\"···\"',\n    opacity: 0.5,\n    display: \"block\",\n    textAlign: \"center\"\n  },\n  \".cm-tooltip.cm-completionInfo\": {\n    position: \"absolute\",\n    padding: \"3px 9px\",\n    width: \"max-content\",\n    maxWidth: \"\".concat(400\n    /* Info.Width */\n    , \"px\"),\n    boxSizing: \"border-box\",\n    whiteSpace: \"pre-line\"\n  },\n  \".cm-completionInfo.cm-completionInfo-left\": {\n    right: \"100%\"\n  },\n  \".cm-completionInfo.cm-completionInfo-right\": {\n    left: \"100%\"\n  },\n  \".cm-completionInfo.cm-completionInfo-left-narrow\": {\n    right: \"\".concat(30\n    /* Info.Margin */\n    , \"px\")\n  },\n  \".cm-completionInfo.cm-completionInfo-right-narrow\": {\n    left: \"\".concat(30\n    /* Info.Margin */\n    , \"px\")\n  },\n  \"&light .cm-snippetField\": {\n    backgroundColor: \"#00000022\"\n  },\n  \"&dark .cm-snippetField\": {\n    backgroundColor: \"#ffffff22\"\n  },\n  \".cm-snippetFieldPosition\": {\n    verticalAlign: \"text-top\",\n    width: 0,\n    height: \"1.15em\",\n    display: \"inline-block\",\n    margin: \"0 -0.7px -.7em\",\n    borderLeft: \"1.4px dotted #888\"\n  },\n  \".cm-completionMatchedText\": {\n    textDecoration: \"underline\"\n  },\n  \".cm-completionDetail\": {\n    marginLeft: \"0.5em\",\n    fontStyle: \"italic\"\n  },\n  \".cm-completionIcon\": {\n    fontSize: \"90%\",\n    width: \".8em\",\n    display: \"inline-block\",\n    textAlign: \"center\",\n    paddingRight: \".6em\",\n    opacity: \"0.6\",\n    boxSizing: \"content-box\"\n  },\n  \".cm-completionIcon-function, .cm-completionIcon-method\": {\n    \"&:after\": {\n      content: \"'ƒ'\"\n    }\n  },\n  \".cm-completionIcon-class\": {\n    \"&:after\": {\n      content: \"'○'\"\n    }\n  },\n  \".cm-completionIcon-interface\": {\n    \"&:after\": {\n      content: \"'◌'\"\n    }\n  },\n  \".cm-completionIcon-variable\": {\n    \"&:after\": {\n      content: \"'𝑥'\"\n    }\n  },\n  \".cm-completionIcon-constant\": {\n    \"&:after\": {\n      content: \"'𝐶'\"\n    }\n  },\n  \".cm-completionIcon-type\": {\n    \"&:after\": {\n      content: \"'𝑡'\"\n    }\n  },\n  \".cm-completionIcon-enum\": {\n    \"&:after\": {\n      content: \"'∪'\"\n    }\n  },\n  \".cm-completionIcon-property\": {\n    \"&:after\": {\n      content: \"'□'\"\n    }\n  },\n  \".cm-completionIcon-keyword\": {\n    \"&:after\": {\n      content: \"'\\uD83D\\uDD11\\uFE0E'\"\n    } // Disable emoji rendering\n\n  },\n  \".cm-completionIcon-namespace\": {\n    \"&:after\": {\n      content: \"'▢'\"\n    }\n  },\n  \".cm-completionIcon-text\": {\n    \"&:after\": {\n      content: \"'abc'\",\n      fontSize: \"50%\",\n      verticalAlign: \"middle\"\n    }\n  }\n});\n\nvar FieldPos = function FieldPos(field, line, from, to) {\n  _classCallCheck(this, FieldPos);\n\n  this.field = field;\n  this.line = line;\n  this.from = from;\n  this.to = to;\n};\n\nvar FieldRange = /*#__PURE__*/function () {\n  function FieldRange(field, from, to) {\n    _classCallCheck(this, FieldRange);\n\n    this.field = field;\n    this.from = from;\n    this.to = to;\n  }\n\n  _createClass(FieldRange, [{\n    key: \"map\",\n    value: function map(changes) {\n      var from = changes.mapPos(this.from, -1, MapMode.TrackDel);\n      var to = changes.mapPos(this.to, 1, MapMode.TrackDel);\n      return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n  }]);\n\n  return FieldRange;\n}();\n\nvar Snippet = /*#__PURE__*/function () {\n  function Snippet(lines, fieldPositions) {\n    _classCallCheck(this, Snippet);\n\n    this.lines = lines;\n    this.fieldPositions = fieldPositions;\n  }\n\n  _createClass(Snippet, [{\n    key: \"instantiate\",\n    value: function instantiate(state, pos) {\n      var text = [],\n          lineStart = [pos];\n      var lineObj = state.doc.lineAt(pos),\n          baseIndent = /^\\s*/.exec(lineObj.text)[0];\n\n      var _iterator21 = _createForOfIteratorHelper(this.lines),\n          _step21;\n\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var line = _step21.value;\n\n          if (text.length) {\n            var indent = baseIndent,\n                tabs = /^\\t*/.exec(line)[0].length;\n\n            for (var _i3 = 0; _i3 < tabs; _i3++) {\n              indent += state.facet(indentUnit);\n            }\n\n            lineStart.push(pos + indent.length - tabs);\n            line = indent + line.slice(tabs);\n          }\n\n          text.push(line);\n          pos += line.length + 1;\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n\n      var ranges = this.fieldPositions.map(function (pos) {\n        return new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to);\n      });\n      return {\n        text: text,\n        ranges: ranges\n      };\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(template) {\n      var fields = [];\n      var lines = [],\n          positions = [],\n          m;\n\n      var _iterator22 = _createForOfIteratorHelper(template.split(/\\r\\n?|\\n/)),\n          _step22;\n\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var line = _step22.value;\n\n          while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|((?:\\\\[{}]|[^}])*))\\}/.exec(line)) {\n            var seq = m[1] ? +m[1] : null,\n                rawName = m[2] || m[3] || \"\",\n                found = -1;\n            var name = rawName.replace(/\\\\[{}]/g, function (m) {\n              return m[1];\n            });\n\n            for (var _i4 = 0; _i4 < fields.length; _i4++) {\n              if (seq != null ? fields[_i4].seq == seq : name ? fields[_i4].name == name : false) found = _i4;\n            }\n\n            if (found < 0) {\n              var _i5 = 0;\n\n              while (_i5 < fields.length && (seq == null || fields[_i5].seq != null && fields[_i5].seq < seq)) {\n                _i5++;\n              }\n\n              fields.splice(_i5, 0, {\n                seq: seq,\n                name: name\n              });\n              found = _i5;\n\n              var _iterator23 = _createForOfIteratorHelper(positions),\n                  _step23;\n\n              try {\n                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                  var pos = _step23.value;\n                  if (pos.field >= found) pos.field++;\n                }\n              } catch (err) {\n                _iterator23.e(err);\n              } finally {\n                _iterator23.f();\n              }\n            }\n\n            positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n            line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);\n          }\n\n          line = line.replace(/\\\\([{}])/g, function (_, brace, index) {\n            var _iterator24 = _createForOfIteratorHelper(positions),\n                _step24;\n\n            try {\n              for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n                var _pos = _step24.value;\n\n                if (_pos.line == lines.length && _pos.from > index) {\n                  _pos.from--;\n                  _pos.to--;\n                }\n              }\n            } catch (err) {\n              _iterator24.e(err);\n            } finally {\n              _iterator24.f();\n            }\n\n            return brace;\n          });\n          lines.push(line);\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n\n      return new Snippet(lines, positions);\n    }\n  }]);\n\n  return Snippet;\n}();\n\nvar fieldMarker = /*@__PURE__*/Decoration.widget({\n  widget: /*@__PURE__*/new ( /*#__PURE__*/function (_WidgetType) {\n    _inherits(_class2, _WidgetType);\n\n    var _super2 = _createSuper(_class2);\n\n    function _class2() {\n      _classCallCheck(this, _class2);\n\n      return _super2.apply(this, arguments);\n    }\n\n    _createClass(_class2, [{\n      key: \"toDOM\",\n      value: function toDOM() {\n        var span = document.createElement(\"span\");\n        span.className = \"cm-snippetFieldPosition\";\n        return span;\n      }\n    }, {\n      key: \"ignoreEvent\",\n      value: function ignoreEvent() {\n        return false;\n      }\n    }]);\n\n    return _class2;\n  }(WidgetType))()\n});\nvar fieldRange = /*@__PURE__*/Decoration.mark({\n  class: \"cm-snippetField\"\n});\n\nvar ActiveSnippet = /*#__PURE__*/function () {\n  function ActiveSnippet(ranges, active) {\n    _classCallCheck(this, ActiveSnippet);\n\n    this.ranges = ranges;\n    this.active = active;\n    this.deco = Decoration.set(ranges.map(function (r) {\n      return (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to);\n    }));\n  }\n\n  _createClass(ActiveSnippet, [{\n    key: \"map\",\n    value: function map(changes) {\n      var ranges = [];\n\n      var _iterator25 = _createForOfIteratorHelper(this.ranges),\n          _step25;\n\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var r = _step25.value;\n          var mapped = r.map(changes);\n          if (!mapped) return null;\n          ranges.push(mapped);\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n\n      return new ActiveSnippet(ranges, this.active);\n    }\n  }, {\n    key: \"selectionInsideField\",\n    value: function selectionInsideField(sel) {\n      var _this13 = this;\n\n      return sel.ranges.every(function (range) {\n        return _this13.ranges.some(function (r) {\n          return r.field == _this13.active && r.from <= range.from && r.to >= range.to;\n        });\n      });\n    }\n  }]);\n\n  return ActiveSnippet;\n}();\n\nvar setActive = /*@__PURE__*/StateEffect.define({\n  map: function map(value, changes) {\n    return value && value.map(changes);\n  }\n});\nvar moveToField = /*@__PURE__*/StateEffect.define();\nvar snippetState = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return null;\n  },\n  update: function update(value, tr) {\n    var _iterator26 = _createForOfIteratorHelper(tr.effects),\n        _step26;\n\n    try {\n      for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n        var effect = _step26.value;\n        if (effect.is(setActive)) return effect.value;\n        if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n      }\n    } catch (err) {\n      _iterator26.e(err);\n    } finally {\n      _iterator26.f();\n    }\n\n    if (value && tr.docChanged) value = value.map(tr.changes);\n    if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n    return value;\n  },\n  provide: function provide(f) {\n    return EditorView.decorations.from(f, function (val) {\n      return val ? val.deco : Decoration.none;\n    });\n  }\n});\n\nfunction fieldSelection(ranges, field) {\n  return EditorSelection.create(ranges.filter(function (r) {\n    return r.field == field;\n  }).map(function (r) {\n    return EditorSelection.range(r.from, r.to);\n  }));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/\n\n\nfunction snippet(template) {\n  var snippet = Snippet.parse(template);\n  return function (editor, completion, from, to) {\n    var _snippet$instantiate = snippet.instantiate(editor.state, from),\n        text = _snippet$instantiate.text,\n        ranges = _snippet$instantiate.ranges;\n\n    var spec = {\n      changes: {\n        from: from,\n        to: to,\n        insert: Text.of(text)\n      },\n      scrollIntoView: true,\n      annotations: completion ? [pickedCompletion.of(completion), Transaction.userEvent.of(\"input.complete\")] : undefined\n    };\n    if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n\n    if (ranges.some(function (r) {\n      return r.field > 0;\n    })) {\n      var active = new ActiveSnippet(ranges, 0);\n      var effects = spec.effects = [setActive.of(active)];\n      if (editor.state.field(snippetState, false) === undefined) effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));\n    }\n\n    editor.dispatch(editor.state.update(spec));\n  };\n}\n\nfunction moveField(dir) {\n  return function (_ref3) {\n    var state = _ref3.state,\n        dispatch = _ref3.dispatch;\n    var active = state.field(snippetState, false);\n    if (!active || dir < 0 && active.active == 0) return false;\n    var next = active.active + dir,\n        last = dir > 0 && !active.ranges.some(function (r) {\n      return r.field == next + dir;\n    });\n    dispatch(state.update({\n      selection: fieldSelection(active.ranges, next),\n      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),\n      scrollIntoView: true\n    }));\n    return true;\n  };\n}\n/**\nA command that clears the active snippet, if any.\n*/\n\n\nvar clearSnippet = function clearSnippet(_ref4) {\n  var state = _ref4.state,\n      dispatch = _ref4.dispatch;\n  var active = state.field(snippetState, false);\n  if (!active) return false;\n  dispatch(state.update({\n    effects: setActive.of(null)\n  }));\n  return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\n\n\nvar nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\n\nvar prevSnippetField = /*@__PURE__*/moveField(-1);\n/**\nCheck if there is an active snippet with a next field for\n`nextSnippetField` to move to.\n*/\n\nfunction hasNextSnippetField(state) {\n  var active = state.field(snippetState, false);\n  return !!(active && active.ranges.some(function (r) {\n    return r.field == active.active + 1;\n  }));\n}\n/**\nReturns true if there is an active snippet and a previous field\nfor `prevSnippetField` to move to.\n*/\n\n\nfunction hasPrevSnippetField(state) {\n  var active = state.field(snippetState, false);\n  return !!(active && active.active > 0);\n}\n\nvar defaultSnippetKeymap = [{\n  key: \"Tab\",\n  run: nextSnippetField,\n  shift: prevSnippetField\n}, {\n  key: \"Escape\",\n  run: clearSnippet\n}];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\n\nvar snippetKeymap = /*@__PURE__*/Facet.define({\n  combine: function combine(maps) {\n    return maps.length ? maps[0] : defaultSnippetKeymap;\n  }\n});\nvar addSnippetKeymap = /*@__PURE__*/Prec.highest( /*@__PURE__*/keymap.compute([snippetKeymap], function (state) {\n  return state.facet(snippetKeymap);\n}));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\n\nfunction snippetCompletion(template, completion) {\n  return Object.assign(Object.assign({}, completion), {\n    apply: snippet(template)\n  });\n}\n\nvar snippetPointerHandler = /*@__PURE__*/EditorView.domEventHandlers({\n  mousedown: function mousedown(event, view) {\n    var active = view.state.field(snippetState, false),\n        pos;\n    if (!active || (pos = view.posAtCoords({\n      x: event.clientX,\n      y: event.clientY\n    })) == null) return false;\n    var match = active.ranges.find(function (r) {\n      return r.from <= pos && r.to >= pos;\n    });\n    if (!match || match.field == active.active) return false;\n    view.dispatch({\n      selection: fieldSelection(active.ranges, match.field),\n      effects: setActive.of(active.ranges.some(function (r) {\n        return r.field > match.field;\n      }) ? new ActiveSnippet(active.ranges, match.field) : null),\n      scrollIntoView: true\n    });\n    return true;\n  }\n});\n\nfunction wordRE(wordChars) {\n  var escaped = wordChars.replace(/[\\]\\-\\\\]/g, \"\\\\$&\");\n\n  try {\n    return new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_\".concat(escaped, \"]+\"), \"ug\");\n  } catch (_a) {\n    return new RegExp(\"[w\".concat(escaped, \"]\"), \"g\");\n  }\n}\n\nfunction mapRE(re, f) {\n  return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\n\nvar wordCaches = /*@__PURE__*/Object.create(null);\n\nfunction wordCache(wordChars) {\n  return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap());\n}\n\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n  for (var lines = doc.iterLines(), pos = 0; !lines.next().done;) {\n    var value = lines.value,\n        m = void 0;\n    wordRE.lastIndex = 0;\n\n    while (m = wordRE.exec(value)) {\n      if (!seen[m[0]] && pos + m.index != ignoreAt) {\n        result.push({\n          type: \"text\",\n          label: m[0]\n        });\n        seen[m[0]] = true;\n        if (result.length >= 2000\n        /* C.MaxList */\n        ) return;\n      }\n    }\n\n    pos += value.length + 1;\n  }\n}\n\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n  var big = doc.length >= 1000\n  /* C.MinCacheLen */\n  ;\n  var cached = big && cache.get(doc);\n  if (cached) return cached;\n  var result = [],\n      seen = Object.create(null);\n\n  if (doc.children) {\n    var pos = 0;\n\n    var _iterator27 = _createForOfIteratorHelper(doc.children),\n        _step27;\n\n    try {\n      for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n        var ch = _step27.value;\n\n        if (ch.length >= 1000\n        /* C.MinCacheLen */\n        ) {\n            var _iterator28 = _createForOfIteratorHelper(collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)),\n                _step28;\n\n            try {\n              for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                var c = _step28.value;\n\n                if (!seen[c.label]) {\n                  seen[c.label] = true;\n                  result.push(c);\n                }\n              }\n            } catch (err) {\n              _iterator28.e(err);\n            } finally {\n              _iterator28.f();\n            }\n          } else {\n          storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n        }\n\n        pos += ch.length + 1;\n      }\n    } catch (err) {\n      _iterator27.e(err);\n    } finally {\n      _iterator27.f();\n    }\n  } else {\n    storeWords(doc, wordRE, result, seen, ignoreAt);\n  }\n\n  if (big && result.length < 2000\n  /* C.MaxList */\n  ) cache.set(doc, result);\n  return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\n\n\nvar completeAnyWord = function completeAnyWord(context) {\n  var wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n  var re = wordRE(wordChars);\n  var token = context.matchBefore(mapRE(re, function (s) {\n    return s + \"$\";\n  }));\n  if (!token && !context.explicit) return null;\n  var from = token ? token.from : context.pos;\n  var options = collectWords(context.state.doc, wordCache(wordChars), re, 50000\n  /* C.Range */\n  , from);\n  return {\n    from: from,\n    options: options,\n    validFor: mapRE(re, function (s) {\n      return \"^\" + s;\n    })\n  };\n};\n\nvar defaults = {\n  brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n  before: \")]}:;>\",\n  stringPrefixes: []\n};\nvar closeBracketEffect = /*@__PURE__*/StateEffect.define({\n  map: function map(value, mapping) {\n    var mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);\n    return mapped == null ? undefined : mapped;\n  }\n});\nvar closedBracket = /*@__PURE__*/new ( /*#__PURE__*/function (_RangeValue) {\n  _inherits(_class3, _RangeValue);\n\n  var _super3 = _createSuper(_class3);\n\n  function _class3() {\n    _classCallCheck(this, _class3);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return _class3;\n}(RangeValue))();\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nvar bracketState = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return RangeSet.empty;\n  },\n  update: function update(value, tr) {\n    value = value.map(tr.changes);\n\n    if (tr.selection) {\n      var line = tr.state.doc.lineAt(tr.selection.main.head);\n      value = value.update({\n        filter: function filter(from) {\n          return from >= line.from && from <= line.to;\n        }\n      });\n    }\n\n    var _iterator29 = _createForOfIteratorHelper(tr.effects),\n        _step29;\n\n    try {\n      for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n        var effect = _step29.value;\n        if (effect.is(closeBracketEffect)) value = value.update({\n          add: [closedBracket.range(effect.value, effect.value + 1)]\n        });\n      }\n    } catch (err) {\n      _iterator29.e(err);\n    } finally {\n      _iterator29.f();\n    }\n\n    return value;\n  }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/\n\nfunction closeBrackets() {\n  return [inputHandler, bracketState];\n}\n\nvar definedClosing = \"()[]{}<>\";\n\nfunction closing(ch) {\n  for (var _i6 = 0; _i6 < definedClosing.length; _i6 += 2) {\n    if (definedClosing.charCodeAt(_i6) == ch) return definedClosing.charAt(_i6 + 1);\n  }\n\n  return fromCodePoint(ch < 128 ? ch : ch + 1);\n}\n\nfunction config(state, pos) {\n  return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\n\nvar android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\nvar inputHandler = /*@__PURE__*/EditorView.inputHandler.of(function (view, from, to, insert) {\n  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;\n  var sel = view.state.selection.main;\n  if (insert.length > 2 || insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;\n  var tr = insertBracket(view.state, insert);\n  if (!tr) return false;\n  view.dispatch(tr);\n  return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/\n\nvar deleteBracketPair = function deleteBracketPair(_ref5) {\n  var state = _ref5.state,\n      dispatch = _ref5.dispatch;\n  if (state.readOnly) return false;\n  var conf = config(state, state.selection.main.head);\n  var tokens = conf.brackets || defaults.brackets;\n  var dont = null,\n      changes = state.changeByRange(function (range) {\n    if (range.empty) {\n      var before = prevChar(state.doc, range.head);\n\n      var _iterator30 = _createForOfIteratorHelper(tokens),\n          _step30;\n\n      try {\n        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n          var token = _step30.value;\n          if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0))) return {\n            changes: {\n              from: range.head - token.length,\n              to: range.head + token.length\n            },\n            range: EditorSelection.cursor(range.head - token.length)\n          };\n        }\n      } catch (err) {\n        _iterator30.e(err);\n      } finally {\n        _iterator30.f();\n      }\n    }\n\n    return {\n      range: dont = range\n    };\n  });\n  if (!dont) dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"delete.backward\"\n  }));\n  return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/\n\n\nvar closeBracketsKeymap = [{\n  key: \"Backspace\",\n  run: deleteBracketPair\n}];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert brackets—the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/\n\nfunction insertBracket(state, bracket) {\n  var conf = config(state, state.selection.main.head);\n  var tokens = conf.brackets || defaults.brackets;\n\n  var _iterator31 = _createForOfIteratorHelper(tokens),\n      _step31;\n\n  try {\n    for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n      var tok = _step31.value;\n      var closed = closing(codePointAt(tok, 0));\n      if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);\n      if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);\n    }\n  } catch (err) {\n    _iterator31.e(err);\n  } finally {\n    _iterator31.f();\n  }\n\n  return null;\n}\n\nfunction closedBracketAt(state, pos) {\n  var found = false;\n  state.field(bracketState).between(0, state.doc.length, function (from) {\n    if (from == pos) found = true;\n  });\n  return found;\n}\n\nfunction nextChar(doc, pos) {\n  var next = doc.sliceString(pos, pos + 2);\n  return next.slice(0, codePointSize(codePointAt(next, 0)));\n}\n\nfunction prevChar(doc, pos) {\n  var prev = doc.sliceString(pos - 2, pos);\n  return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\n\nfunction handleOpen(state, open, close, closeBefore) {\n  var dont = null,\n      changes = state.changeByRange(function (range) {\n    if (!range.empty) return {\n      changes: [{\n        insert: open,\n        from: range.from\n      }, {\n        insert: close,\n        from: range.to\n      }],\n      effects: closeBracketEffect.of(range.to + open.length),\n      range: EditorSelection.range(range.anchor + open.length, range.head + open.length)\n    };\n    var next = nextChar(state.doc, range.head);\n    if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) return {\n      changes: {\n        insert: open + close,\n        from: range.head\n      },\n      effects: closeBracketEffect.of(range.head + open.length),\n      range: EditorSelection.cursor(range.head + open.length)\n    };\n    return {\n      range: dont = range\n    };\n  });\n  return dont ? null : state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input.type\"\n  });\n}\n\nfunction handleClose(state, _open, close) {\n  var dont = null,\n      changes = state.changeByRange(function (range) {\n    if (range.empty && nextChar(state.doc, range.head) == close) return {\n      changes: {\n        from: range.head,\n        to: range.head + close.length,\n        insert: close\n      },\n      range: EditorSelection.cursor(range.head + close.length)\n    };\n    return dont = {\n      range: range\n    };\n  });\n  return dont ? null : state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input.type\"\n  });\n} // Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\n\n\nfunction handleSame(state, token, allowTriple, config) {\n  var stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n  var dont = null,\n      changes = state.changeByRange(function (range) {\n    if (!range.empty) return {\n      changes: [{\n        insert: token,\n        from: range.from\n      }, {\n        insert: token,\n        from: range.to\n      }],\n      effects: closeBracketEffect.of(range.to + token.length),\n      range: EditorSelection.range(range.anchor + token.length, range.head + token.length)\n    };\n    var pos = range.head,\n        next = nextChar(state.doc, pos),\n        start;\n\n    if (next == token) {\n      if (nodeStart(state, pos)) {\n        return {\n          changes: {\n            insert: token + token,\n            from: pos\n          },\n          effects: closeBracketEffect.of(pos + token.length),\n          range: EditorSelection.cursor(pos + token.length)\n        };\n      } else if (closedBracketAt(state, pos)) {\n        var isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n        var content = isTriple ? token + token + token : token;\n        return {\n          changes: {\n            from: pos,\n            to: pos + content.length,\n            insert: content\n          },\n          range: EditorSelection.cursor(pos + content.length)\n        };\n      }\n    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {\n      return {\n        changes: {\n          insert: token + token + token + token,\n          from: pos\n        },\n        effects: closeBracketEffect.of(pos + token.length),\n        range: EditorSelection.cursor(pos + token.length)\n      };\n    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {\n      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {\n        changes: {\n          insert: token + token,\n          from: pos\n        },\n        effects: closeBracketEffect.of(pos + token.length),\n        range: EditorSelection.cursor(pos + token.length)\n      };\n    }\n\n    return {\n      range: dont = range\n    };\n  });\n  return dont ? null : state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input.type\"\n  });\n}\n\nfunction nodeStart(state, pos) {\n  var tree = syntaxTree(state).resolveInner(pos + 1);\n  return tree.parent && tree.from == pos;\n}\n\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n  var node = syntaxTree(state).resolveInner(pos, -1);\n  var maxPrefix = prefixes.reduce(function (m, p) {\n    return Math.max(m, p.length);\n  }, 0);\n\n  for (var _i7 = 0; _i7 < 5; _i7++) {\n    var start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n    var quotePos = start.indexOf(quoteToken);\n\n    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n      var first = node.firstChild;\n\n      while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {\n        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;\n        first = first.firstChild;\n      }\n\n      return true;\n    }\n\n    var parent = node.to == pos && node.parent;\n    if (!parent) break;\n    node = parent;\n  }\n\n  return false;\n}\n\nfunction canStartStringAt(state, pos, prefixes) {\n  var charCat = state.charCategorizer(pos);\n  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word) return pos;\n\n  var _iterator32 = _createForOfIteratorHelper(prefixes),\n      _step32;\n\n  try {\n    for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n      var prefix = _step32.value;\n      var start = pos - prefix.length;\n      if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word) return start;\n    }\n  } catch (err) {\n    _iterator32.e(err);\n  } finally {\n    _iterator32.f();\n  }\n\n  return -1;\n}\n/**\nReturns an extension that enables autocompletion.\n*/\n\n\nfunction autocompletion() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [commitCharacters, completionState, completionConfig.of(config), completionPlugin, completionKeymapExt, baseTheme];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space (and Alt-\\` on macOS): [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\n\n\nvar completionKeymap = [{\n  key: \"Ctrl-Space\",\n  run: startCompletion\n}, {\n  mac: \"Alt-`\",\n  run: startCompletion\n}, {\n  key: \"Escape\",\n  run: closeCompletion\n}, {\n  key: \"ArrowDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true)\n}, {\n  key: \"ArrowUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false)\n}, {\n  key: \"PageDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true, \"page\")\n}, {\n  key: \"PageUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false, \"page\")\n}, {\n  key: \"Enter\",\n  run: acceptCompletion\n}];\nvar completionKeymapExt = /*@__PURE__*/Prec.highest( /*@__PURE__*/keymap.computeN([completionConfig], function (state) {\n  return state.facet(completionConfig).defaultKeymap ? [completionKeymap] : [];\n}));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\n\nfunction completionStatus(state) {\n  var cState = state.field(completionState, false);\n  return cState && cState.active.some(function (a) {\n    return a.state == 1;\n  }\n  /* State.Pending */\n  ) ? \"pending\" : cState && cState.active.some(function (a) {\n    return a.state != 0;\n  }\n  /* State.Inactive */\n  ) ? \"active\" : null;\n}\n\nvar completionArrayCache = /*@__PURE__*/new WeakMap();\n/**\nReturns the available completions as an array.\n*/\n\nfunction currentCompletions(state) {\n  var _a;\n\n  var open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  if (!open || open.disabled) return [];\n  var completions = completionArrayCache.get(open.options);\n  if (!completions) completionArrayCache.set(open.options, completions = open.options.map(function (o) {\n    return o.completion;\n  }));\n  return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/\n\n\nfunction selectedCompletion(state) {\n  var _a;\n\n  var open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/\n\n\nfunction selectedCompletionIndex(state) {\n  var _a;\n\n  var open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/\n\n\nfunction setSelectedCompletion(index) {\n  return setSelectedEffect.of(index);\n}\n\nexport { CompletionContext, acceptCompletion, autocompletion, clearSnippet, closeBrackets, closeBracketsKeymap, closeCompletion, completeAnyWord, completeFromList, completionKeymap, completionStatus, currentCompletions, deleteBracketPair, hasNextSnippetField, hasPrevSnippetField, ifIn, ifNotIn, insertBracket, insertCompletionText, moveCompletionSelection, nextSnippetField, pickedCompletion, prevSnippetField, selectedCompletion, selectedCompletionIndex, setSelectedCompletion, snippet, snippetCompletion, snippetKeymap, startCompletion };","map":{"version":3,"sources":["/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/@codemirror/autocomplete/dist/index.js"],"names":["Annotation","StateEffect","EditorSelection","codePointAt","codePointSize","fromCodePoint","Facet","combineConfig","StateField","Prec","Text","Transaction","MapMode","RangeValue","RangeSet","CharCategory","Direction","logException","showTooltip","EditorView","ViewPlugin","getTooltip","Decoration","WidgetType","keymap","syntaxTree","indentUnit","CompletionContext","state","pos","explicit","view","abortListeners","abortOnDocChange","types","token","resolveInner","indexOf","name","parent","from","to","text","sliceDoc","type","expr","line","doc","lineAt","start","Math","max","str","slice","found","search","ensureAnchor","listener","options","push","onDocChange","toSet","chars","flat","Object","keys","join","words","test","replace","prefixMatch","first","create","rest","label","i","length","source","RegExp","completeFromList","list","map","o","every","validFor","match","context","matchBefore","ifIn","nodes","isTop","ifNotIn","Option","completion","score","cur","selection","main","_a","addStart","addEnd","flags","ignoreCase","pickedCompletion","define","insertCompletionText","fromOff","toOff","assign","changeByRange","range","lines","toText","changes","insert","cursor","scrollIntoView","userEvent","SourceCache","WeakMap","asSource","Array","isArray","known","get","set","startCompletionEffect","closeCompletionEffect","FuzzyMatcher","pattern","folded","any","precise","byWord","matched","p","char","size","part","upper","toUpperCase","toLowerCase","astral","word","ret","firstSize","direct","len","anyTo","e","min","next","preciseTo","byWordTo","byWordFolded","adjacentTo","adjacentStart","adjacentEnd","hasLower","wordAdjacent","prevType","ch","result","positions","StrictMatcher","completionConfig","combine","configs","activateOnTyping","activateOnCompletion","activateOnTypingDelay","selectOnOpen","override","closeOnBlur","maxRenderedOptions","defaultKeymap","tooltipClass","optionClass","aboveCursor","icons","addToOptions","positionInfo","defaultPositionInfo","filterStrict","compareCompletions","a","b","localeCompare","interactionDelay","updateSyncTime","c","joinClass","concat","option","info","space","tooltip","rtl","textDirection","RTL","left","narrow","side","offset","maxWidth","spaceLeft","spaceRight","right","infoWidth","infoHeight","bottom","top","spaceBelow","scaleY","offsetHeight","scaleX","offsetWidth","style","class","optionContent","config","content","render","icon","document","createElement","classList","add","split","cls","setAttribute","position","_s","_v","labelElt","className","displayLabel","off","j","appendChild","createTextNode","span","detail","detailElt","textContent","sort","rangeAroundSelected","total","selected","floor","CompletionTooltip","stateField","applyCompletion","infoDestroy","placeInfoReq","read","measureInfo","write","placeInfo","key","currentClass","cState","field","open","facet","dom","updateTooltipClass","addEventListener","target","parentNode","nodeName","exec","id","preventDefault","relatedTarget","contentDOM","dispatch","effects","of","showOptions","updateSel","remove","createListBox","requestMeasure","update","prevState","startState","disabled","toggle","updateSelectedOption","destroyInfo","infoResult","then","obj","addInfoPane","catch","wrap","nodeType","destroy","opt","firstChild","nextSibling","hasAttribute","removeAttribute","sel","querySelector","listRect","getBoundingClientRect","infoRect","selRect","win","ownerDocument","defaultView","window","innerWidth","innerHeight","cssText","ul","phrase","curSection","section","header","li","node","completionTooltip","container","element","self","height","scrollTop","boost","apply","sortOptions","active","sections","addOption","some","s","conf","hasResult","getMatch","filter","matcher","sectionOrder","cmp","_b","rank","prev","compare","CompletionDialog","attrs","timestamp","makeAttrs","mapPos","selectedValue","reduce","createTooltip","above","Date","now","CompletionState","tr","sources","languageDataAt","value","find","ActiveSource","docChanged","touchesRange","sameResults","build","effect","is","setSelectedEffect","setSelected","baseAttrs","noAttrs","none","random","toString","iA","iB","endA","endB","getUpdateType","isUserEvent","annotation","typing","explicitPos","touches","updateFor","setActiveEffect","empty","ActiveResult","checkValid","mapping","completionState","provide","f","val","contentAttributes","annotations","moveCompletionSelection","forward","by","step","acceptCompletion","readOnly","startCompletion","closeCompletion","RunningQuery","time","updates","done","undefined","MaxUpdateCount","MinAbortTime","completionPlugin","fromClass","debounceUpdate","running","debounceAccept","pendingStart","composing","startQuery","selectionSet","doesReset","transactions","query","handler","splice","clearTimeout","delay","q","setTimeout","startUpdate","r","pending","Promise","resolve","aborted","scheduleAccept","err","accept","updated","current","eventHandlers","blur","event","dialog","contains","compositionstart","compositionend","windows","navigator","platform","commitCharacters","highest","domEventHandlers","keydown","ctrlKey","altKey","metaKey","commitChars","baseTheme","fontFamily","whiteSpace","overflow","maxWidth_fallback","minWidth","maxHeight","listStyle","margin","padding","lineHeight","overflowX","textOverflow","display","borderBottom","paddingLeft","opacity","background","color","textAlign","width","boxSizing","backgroundColor","verticalAlign","borderLeft","textDecoration","marginLeft","fontStyle","fontSize","paddingRight","FieldPos","FieldRange","TrackDel","Snippet","fieldPositions","lineStart","lineObj","baseIndent","indent","tabs","ranges","template","fields","m","seq","rawName","index","_","brace","fieldMarker","widget","fieldRange","mark","ActiveSnippet","deco","mapped","setActive","moveToField","snippetState","selectionInsideField","decorations","fieldSelection","snippet","parse","editor","instantiate","spec","appendConfig","addSnippetKeymap","snippetPointerHandler","moveField","dir","last","clearSnippet","nextSnippetField","prevSnippetField","hasNextSnippetField","hasPrevSnippetField","defaultSnippetKeymap","run","shift","snippetKeymap","maps","compute","snippetCompletion","mousedown","posAtCoords","x","clientX","y","clientY","wordRE","wordChars","escaped","mapRE","re","unicode","wordCaches","wordCache","storeWords","seen","ignoreAt","iterLines","lastIndex","collectWords","cache","big","cached","children","completeAnyWord","defaults","brackets","before","stringPrefixes","closeBracketEffect","TrackAfter","closedBracket","startSide","endSide","bracketState","head","closeBrackets","inputHandler","definedClosing","closing","charCodeAt","charAt","android","userAgent","compositionStarted","insertBracket","deleteBracketPair","tokens","dont","prevChar","nextChar","closeBracketsKeymap","bracket","tok","closed","handleSame","handleOpen","closedBracketAt","handleClose","between","sliceString","close","closeBefore","anchor","_open","allowTriple","nodeStart","isTriple","canStartStringAt","charCategorizer","Word","probablyInString","tree","quoteToken","prefixes","maxPrefix","quotePos","charCat","prefix","autocompletion","completionKeymapExt","completionKeymap","mac","computeN","completionStatus","completionArrayCache","currentCompletions","completions","selectedCompletion","selectedCompletionIndex","setSelectedCompletion"],"mappings":"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","sourcesContent":["import { Annotation, StateEffect, EditorSelection, codePointAt, codePointSize, fromCodePoint, Facet, combineConfig, StateField, Prec, Text, Transaction, MapMode, RangeValue, RangeSet, CharCategory } from '@codemirror/state';\nimport { Direction, logException, showTooltip, EditorView, ViewPlugin, getTooltip, Decoration, WidgetType, keymap } from '@codemirror/view';\nimport { syntaxTree, indentUnit } from '@codemirror/language';\n\n/**\nAn instance of this is passed to completion source functions.\n*/\nclass CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sources—in the editor, the extension will create\n    these for you.)\n    */\n    constructor(\n    /**\n    The editor state that the completion happens in.\n    */\n    state, \n    /**\n    The position at which the completion is happening.\n    */\n    pos, \n    /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */\n    explicit, \n    /**\n    The editor view. May be undefined if the context was created\n    in a situation where there is no such view available, such as\n    in synchronous updates via\n    [`CompletionResult.update`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.update)\n    or when called by test code.\n    */\n    view) {\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        this.view = view;\n        /**\n        @internal\n        */\n        this.abortListeners = [];\n        /**\n        @internal\n        */\n        this.abortOnDocChange = false;\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */\n    tokenBefore(types) {\n        let token = syntaxTree(this.state).resolveInner(this.pos, -1);\n        while (token && types.indexOf(token.name) < 0)\n            token = token.parent;\n        return token ? { from: token.from, to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */\n    matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */\n    get aborted() { return this.abortListeners == null; }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    \n    By default, running queries will not be aborted for regular\n    typing or backspacing, on the assumption that they are likely to\n    return a result with a\n    [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that\n    allows the result to be used after all. Passing `onDocChange:\n    true` will cause this query to be aborted for any document\n    change.\n    */\n    addEventListener(type, listener, options) {\n        if (type == \"abort\" && this.abortListeners) {\n            this.abortListeners.push(listener);\n            if (options && options.onDocChange)\n                this.abortOnDocChange = true;\n        }\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words)\n        flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options) {\n        first[label[0]] = true;\n        for (let i = 1; i < label.length; i++)\n            rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\nfunction completeFromList(list) {\n    let options = list.map(o => typeof o == \"string\" ? { label: o } : o);\n    let [validFor, match] = options.every(o => /^\\w+$/.test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\n    return (context) => {\n        let token = context.matchBefore(match);\n        return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;\n    };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifIn(nodes, source) {\n    return (context) => {\n        for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n            if (nodes.indexOf(pos.name) > -1)\n                return source(context);\n            if (pos.type.isTop)\n                break;\n        }\n        return null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifNotIn(nodes, source) {\n    return (context) => {\n        for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {\n            if (nodes.indexOf(pos.name) > -1)\n                return null;\n            if (pos.type.isTop)\n                break;\n        }\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match, score) {\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n        this.score = score;\n    }\n}\nfunction cur(state) { return state.selection.main.from; }\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd)\n        return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? \"i\" : \"\"));\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/\nconst pickedCompletion = /*@__PURE__*/Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/\nfunction insertCompletionText(state, text, from, to) {\n    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;\n    return Object.assign(Object.assign({}, state.changeByRange(range => {\n        if (range != main && from != to &&\n            state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))\n            return { range };\n        let lines = state.toText(text);\n        return {\n            changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },\n            range: EditorSelection.cursor(range.from + fromOff + lines.length)\n        };\n    })), { scrollIntoView: true, userEvent: \"input.complete\" });\n}\nconst SourceCache = /*@__PURE__*/new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source))\n        return source;\n    let known = SourceCache.get(source);\n    if (!known)\n        SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\nconst startCompletionEffect = /*@__PURE__*/StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/StateEffect.define();\n\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern) {\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        this.score = 0;\n        this.matched = [];\n        for (let p = 0; p < pattern.length;) {\n            let char = codePointAt(pattern, p), size = codePointSize(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    ret(score, matched) {\n        this.score = score;\n        this.matched = matched;\n        return this;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return a boolean indicating whether there was a match and,\n    // on success, set `this.score` to the score, `this.matched` to an\n    // array of `from, to` pairs indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0)\n            return this.ret(-100 /* Penalty.NotFull */, []);\n        if (word.length < this.pattern.length)\n            return null;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = codePointAt(word, 0), firstSize = codePointSize(first);\n            let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */;\n            if (first == chars[0]) ;\n            else if (first == folded[0])\n                score += -200 /* Penalty.CaseFold */;\n            else\n                return null;\n            return this.ret(score, [0, firstSize]);\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0)\n            return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */, [0, this.pattern.length]);\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n                let next = codePointAt(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo])\n                    any[anyTo++] = i;\n                i += codePointSize(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len)\n                return null;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word), wordAdjacent = true;\n        // Go over the option's text, scanning for the various kinds of matches\n        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */; i < e && byWordTo < len;) {\n            let next = codePointAt(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo])\n                    precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0)\n                            adjacentStart = i;\n                        adjacentEnd = i + 1;\n                        adjacentTo++;\n                    }\n                    else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff\n                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */ : next >= 65 && next <= 90 ? 1 /* Tp.Upper */ : 0 /* Tp.NonWord */)\n                : ((ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */ : ch != ch.toUpperCase() ? 2 /* Tp.Lower */ : 0 /* Tp.NonWord */);\n            if (!i || type == 1 /* Tp.Upper */ && hasLower || prevType == 0 /* Tp.NonWord */ && type != 0 /* Tp.NonWord */) {\n                if (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true)))\n                    byWord[byWordTo++] = i;\n                else if (byWord.length)\n                    wordAdjacent = false;\n            }\n            prevType = type;\n            i += codePointSize(next);\n        }\n        if (byWordTo == len && byWord[0] == 0 && wordAdjacent)\n            return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0)\n            return this.ret(-200 /* Penalty.CaseFold */ - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */), [0, adjacentEnd]);\n        if (direct > -1)\n            return this.ret(-700 /* Penalty.NotStart */ - word.length, [direct, direct + this.pattern.length]);\n        if (adjacentTo == len)\n            return this.ret(-200 /* Penalty.CaseFold */ + -700 /* Penalty.NotStart */ - word.length, [adjacentStart, adjacentEnd]);\n        if (byWordTo == len)\n            return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0) + -700 /* Penalty.NotStart */ +\n                (wordAdjacent ? 0 : -1100 /* Penalty.Gap */), byWord, word);\n        return chars.length == 2 ? null\n            : this.result((any[0] ? -700 /* Penalty.NotStart */ : 0) + -200 /* Penalty.CaseFold */ + -1100 /* Penalty.Gap */, any, word);\n    }\n    result(score, positions, word) {\n        let result = [], i = 0;\n        for (let pos of positions) {\n            let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);\n            if (i && result[i - 1] == pos)\n                result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return this.ret(score - word.length, result);\n    }\n}\nclass StrictMatcher {\n    constructor(pattern) {\n        this.pattern = pattern;\n        this.matched = [];\n        this.score = 0;\n        this.folded = pattern.toLowerCase();\n    }\n    match(word) {\n        if (word.length < this.pattern.length)\n            return null;\n        let start = word.slice(0, this.pattern.length);\n        let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 /* Penalty.CaseFold */ : null;\n        if (match == null)\n            return null;\n        this.matched = [0, start.length];\n        this.score = match + (word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */);\n        return this;\n    }\n}\n\nconst completionConfig = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            activateOnTyping: true,\n            activateOnCompletion: () => false,\n            activateOnTypingDelay: 100,\n            selectOnOpen: true,\n            override: null,\n            closeOnBlur: true,\n            maxRenderedOptions: 100,\n            defaultKeymap: true,\n            tooltipClass: () => \"\",\n            optionClass: () => \"\",\n            aboveCursor: false,\n            icons: true,\n            addToOptions: [],\n            positionInfo: defaultPositionInfo,\n            filterStrict: false,\n            compareCompletions: (a, b) => a.label.localeCompare(b.label),\n            interactionDelay: 75,\n            updateSyncTime: 100\n        }, {\n            defaultKeymap: (a, b) => a && b,\n            closeOnBlur: (a, b) => a && b,\n            icons: (a, b) => a && b,\n            tooltipClass: (a, b) => c => joinClass(a(c), b(c)),\n            optionClass: (a, b) => c => joinClass(a(c), b(c)),\n            addToOptions: (a, b) => a.concat(b),\n            filterStrict: (a, b) => a || b,\n        });\n    }\n});\nfunction joinClass(a, b) {\n    return a ? b ? a + \" \" + b : a : b;\n}\nfunction defaultPositionInfo(view, list, option, info, space, tooltip) {\n    let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;\n    let side = \"top\", offset, maxWidth;\n    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;\n    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;\n    if (left && spaceLeft < Math.min(infoWidth, spaceRight))\n        left = false;\n    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))\n        left = true;\n    if (infoWidth <= (left ? spaceLeft : spaceRight)) {\n        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;\n        maxWidth = Math.min(400 /* Info.Width */, left ? spaceLeft : spaceRight);\n    }\n    else {\n        narrow = true;\n        maxWidth = Math.min(400 /* Info.Width */, (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */);\n        let spaceBelow = space.bottom - list.bottom;\n        if (spaceBelow >= infoHeight || spaceBelow > list.top) { // Below the completion\n            offset = option.bottom - list.top;\n        }\n        else { // Above it\n            side = \"bottom\";\n            offset = list.bottom - option.top;\n        }\n    }\n    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;\n    let scaleX = (list.right - list.left) / tooltip.offsetWidth;\n    return {\n        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,\n        class: \"cm-completionInfo-\" + (narrow ? (rtl ? \"left-narrow\" : \"right-narrow\") : left ? \"left\" : \"right\")\n    };\n}\n\nfunction optionContent(config) {\n    let content = config.addToOptions.slice();\n    if (config.icons)\n        content.push({\n            render(completion) {\n                let icon = document.createElement(\"div\");\n                icon.classList.add(\"cm-completionIcon\");\n                if (completion.type)\n                    icon.classList.add(...completion.type.split(/\\s+/g).map(cls => \"cm-completionIcon-\" + cls));\n                icon.setAttribute(\"aria-hidden\", \"true\");\n                return icon;\n            },\n            position: 20\n        });\n    content.push({\n        render(completion, _s, _v, match) {\n            let labelElt = document.createElement(\"span\");\n            labelElt.className = \"cm-completionLabel\";\n            let label = completion.displayLabel || completion.label, off = 0;\n            for (let j = 0; j < match.length;) {\n                let from = match[j++], to = match[j++];\n                if (from > off)\n                    labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n                let span = labelElt.appendChild(document.createElement(\"span\"));\n                span.appendChild(document.createTextNode(label.slice(from, to)));\n                span.className = \"cm-completionMatchedText\";\n                off = to;\n            }\n            if (off < label.length)\n                labelElt.appendChild(document.createTextNode(label.slice(off)));\n            return labelElt;\n        },\n        position: 50\n    }, {\n        render(completion) {\n            if (!completion.detail)\n                return null;\n            let detailElt = document.createElement(\"span\");\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = completion.detail;\n            return detailElt;\n        },\n        position: 80\n    });\n    return content.sort((a, b) => a.position - b.position).map(a => a.render);\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max)\n        return { from: 0, to: total };\n    if (selected < 0)\n        selected = 0;\n    if (selected <= (total >> 1)) {\n        let off = Math.floor(selected / max);\n        return { from: off * max, to: (off + 1) * max };\n    }\n    let off = Math.floor((total - selected) / max);\n    return { from: total - (off + 1) * max, to: total - off * max };\n}\nclass CompletionTooltip {\n    constructor(view, stateField, applyCompletion) {\n        this.view = view;\n        this.stateField = stateField;\n        this.applyCompletion = applyCompletion;\n        this.info = null;\n        this.infoDestroy = null;\n        this.placeInfoReq = {\n            read: () => this.measureInfo(),\n            write: (pos) => this.placeInfo(pos),\n            key: this\n        };\n        this.space = null;\n        this.currentClass = \"\";\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.optionContent = optionContent(config);\n        this.optionClass = config.optionClass;\n        this.tooltipClass = config.tooltipClass;\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.updateTooltipClass(view.state);\n        this.dom.addEventListener(\"mousedown\", (e) => {\n            let { options } = view.state.field(stateField).open;\n            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    this.applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.dom.addEventListener(\"focusout\", (e) => {\n            let state = view.state.field(this.stateField, false);\n            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur &&\n                e.relatedTarget != view.contentDOM)\n                view.dispatch({ effects: closeCompletionEffect.of(null) });\n        });\n        this.showOptions(options, cState.id);\n    }\n    mount() { this.updateSel(); }\n    showOptions(options, id) {\n        if (this.list)\n            this.list.remove();\n        this.list = this.dom.appendChild(this.createListBox(options, id, this.range));\n        this.list.addEventListener(\"scroll\", () => {\n            if (this.info)\n                this.view.requestMeasure(this.placeInfoReq);\n        });\n    }\n    update(update) {\n        var _a;\n        let cState = update.state.field(this.stateField);\n        let prevState = update.startState.field(this.stateField);\n        this.updateTooltipClass(update.state);\n        if (cState != prevState) {\n            let { options, selected, disabled } = cState.open;\n            if (!prevState.open || prevState.open.options != options) {\n                this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);\n                this.showOptions(options, cState.id);\n            }\n            this.updateSel();\n            if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled))\n                this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!disabled);\n        }\n    }\n    updateTooltipClass(state) {\n        let cls = this.tooltipClass(state);\n        if (cls != this.currentClass) {\n            for (let c of this.currentClass.split(\" \"))\n                if (c)\n                    this.dom.classList.remove(c);\n            for (let c of cls.split(\" \"))\n                if (c)\n                    this.dom.classList.add(c);\n            this.currentClass = cls;\n        }\n    }\n    positioned(space) {\n        this.space = space;\n        if (this.info)\n            this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.showOptions(open.options, cState.id);\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            this.destroyInfo();\n            let { completion } = open.options[open.selected];\n            let { info } = completion;\n            if (!info)\n                return;\n            let infoResult = typeof info === \"string\" ? document.createTextNode(info) : info(completion);\n            if (!infoResult)\n                return;\n            if (\"then\" in infoResult) {\n                infoResult.then(obj => {\n                    if (obj && this.view.state.field(this.stateField, false) == cState)\n                        this.addInfoPane(obj, completion);\n                }).catch(e => logException(this.view.state, e, \"completion info\"));\n            }\n            else {\n                this.addInfoPane(infoResult, completion);\n            }\n        }\n    }\n    addInfoPane(content, completion) {\n        this.destroyInfo();\n        let wrap = this.info = document.createElement(\"div\");\n        wrap.className = \"cm-tooltip cm-completionInfo\";\n        if (content.nodeType != null) {\n            wrap.appendChild(content);\n            this.infoDestroy = null;\n        }\n        else {\n            let { dom, destroy } = content;\n            wrap.appendChild(dom);\n            this.infoDestroy = destroy || null;\n        }\n        this.dom.appendChild(wrap);\n        this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n            if (opt.nodeName != \"LI\" || !opt.id) {\n                i--; // A section header\n            }\n            else if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            }\n            else {\n                if (opt.hasAttribute(\"aria-selected\"))\n                    opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set)\n            scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel || !this.info)\n            return null;\n        let listRect = this.dom.getBoundingClientRect();\n        let infoRect = this.info.getBoundingClientRect();\n        let selRect = sel.getBoundingClientRect();\n        let space = this.space;\n        if (!space) {\n            let win = this.dom.ownerDocument.defaultView || window;\n            space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };\n        }\n        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 ||\n            selRect.bottom < Math.max(space.top, listRect.top) + 10)\n            return null;\n        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);\n    }\n    placeInfo(pos) {\n        if (this.info) {\n            if (pos) {\n                if (pos.style)\n                    this.info.style.cssText = pos.style;\n                this.info.className = \"cm-tooltip cm-completionInfo \" + (pos.class || \"\");\n            }\n            else {\n                this.info.style.cssText = \"top: -1e6px\";\n            }\n        }\n    }\n    createListBox(options, id, range) {\n        const ul = document.createElement(\"ul\");\n        ul.id = id;\n        ul.setAttribute(\"role\", \"listbox\");\n        ul.setAttribute(\"aria-expanded\", \"true\");\n        ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n        let curSection = null;\n        for (let i = range.from; i < range.to; i++) {\n            let { completion, match } = options[i], { section } = completion;\n            if (section) {\n                let name = typeof section == \"string\" ? section : section.name;\n                if (name != curSection && (i > range.from || range.from == 0)) {\n                    curSection = name;\n                    if (typeof section != \"string\" && section.header) {\n                        ul.appendChild(section.header(section));\n                    }\n                    else {\n                        let header = ul.appendChild(document.createElement(\"completion-section\"));\n                        header.textContent = name;\n                    }\n                }\n            }\n            const li = ul.appendChild(document.createElement(\"li\"));\n            li.id = id + \"-\" + i;\n            li.setAttribute(\"role\", \"option\");\n            let cls = this.optionClass(completion);\n            if (cls)\n                li.className = cls;\n            for (let source of this.optionContent) {\n                let node = source(completion, this.view.state, this.view, match);\n                if (node)\n                    li.appendChild(node);\n            }\n        }\n        if (range.from)\n            ul.classList.add(\"cm-completionListIncompleteTop\");\n        if (range.to < options.length)\n            ul.classList.add(\"cm-completionListIncompleteBottom\");\n        return ul;\n    }\n    destroyInfo() {\n        if (this.info) {\n            if (this.infoDestroy)\n                this.infoDestroy();\n            this.info.remove();\n            this.info = null;\n        }\n    }\n    destroy() {\n        this.destroyInfo();\n    }\n}\nfunction completionTooltip(stateField, applyCompletion) {\n    return (view) => new CompletionTooltip(view, stateField, applyCompletion);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    let scaleY = parent.height / container.offsetHeight;\n    if (self.top < parent.top)\n        container.scrollTop -= (parent.top - self.top) / scaleY;\n    else if (self.bottom > parent.bottom)\n        container.scrollTop += (self.bottom - parent.bottom) / scaleY;\n}\n\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +\n        (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    let sections = null;\n    let addOption = (option) => {\n        options.push(option);\n        let { section } = option.completion;\n        if (section) {\n            if (!sections)\n                sections = [];\n            let name = typeof section == \"string\" ? section : section.name;\n            if (!sections.some(s => s.name == name))\n                sections.push(typeof section == \"string\" ? { name } : section);\n        }\n    };\n    let conf = state.facet(completionConfig);\n    for (let a of active)\n        if (a.hasResult()) {\n            let getMatch = a.result.getMatch;\n            if (a.result.filter === false) {\n                for (let option of a.result.options) {\n                    addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));\n                }\n            }\n            else {\n                let pattern = state.sliceDoc(a.from, a.to), match;\n                let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);\n                for (let option of a.result.options)\n                    if (match = matcher.match(option.label)) {\n                        let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];\n                        addOption(new Option(option, a.source, matched, match.score + (option.boost || 0)));\n                    }\n            }\n        }\n    if (sections) {\n        let sectionOrder = Object.create(null), pos = 0;\n        let cmp = (a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1); };\n        for (let s of sections.sort(cmp)) {\n            pos -= 1e5;\n            sectionOrder[s.name] = pos;\n        }\n        for (let option of options) {\n            let { section } = option.completion;\n            if (section)\n                option.score += sectionOrder[typeof section == \"string\" ? section : section.name];\n        }\n    }\n    let result = [], prev = null;\n    let compare = conf.compareCompletions;\n    for (let opt of options.sort((a, b) => (b.score - a.score) || compare(a.completion, b.completion))) {\n        let cur = opt.completion;\n        if (!prev || prev.label != cur.label || prev.detail != cur.detail ||\n            (prev.type != null && cur.type != null && prev.type != cur.type) ||\n            prev.apply != cur.apply || prev.boost != cur.boost)\n            result.push(opt);\n        else if (score(opt.completion) > score(prev))\n            result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected, disabled) {\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n        this.disabled = disabled;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this\n            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n    }\n    static build(active, state, id, prev, conf) {\n        let options = sortOptions(active, state);\n        if (!options.length) {\n            return prev && active.some(a => a.state == 1 /* State.Pending */) ?\n                new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;\n        }\n        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n        if (prev && prev.selected != selected && prev.selected != -1) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for (let i = 0; i < options.length; i++)\n                if (options[i].completion == selectedValue) {\n                    selected = i;\n                    break;\n                }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: createTooltip,\n            above: conf.aboveCursor,\n        }, prev ? prev.timestamp : Date.now(), selected, false);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open) {\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override ||\n            state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map(source => {\n            let value = this.active.find(s => s.source == source) ||\n                new ActiveSource(source, this.active.some(a => a.state != 0 /* State.Inactive */) ? 1 /* State.Pending */ : 0 /* State.Inactive */);\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))\n            active = this.active;\n        let open = this.open;\n        if (open && tr.docChanged)\n            open = open.map(tr.changes);\n        if (tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||\n            !sameResults(active, this.active))\n            open = CompletionDialog.build(active, state, this.id, open, conf);\n        else if (open && open.disabled && !active.some(a => a.state == 1 /* State.Pending */))\n            open = null;\n        if (!open && active.every(a => a.state != 1 /* State.Pending */) && active.some(a => a.hasResult()))\n            active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */) : a);\n        for (let effect of tr.effects)\n            if (effect.is(setSelectedEffect))\n                open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() { return this.open ? this.open.tooltip : null; }\n    get attrs() { return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs; }\n}\nfunction sameResults(a, b) {\n    if (a == b)\n        return true;\n    for (let iA = 0, iB = 0;;) {\n        while (iA < a.length && !a[iA].hasResult)\n            iA++;\n        while (iB < b.length && !b[iB].hasResult)\n            iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB)\n            return endA == endB;\n        if (a[iA++].result != b[iB++].result)\n            return false;\n    }\n}\nconst baseAttrs = {\n    \"aria-autocomplete\": \"list\"\n};\nconst noAttrs = {};\nfunction makeAttrs(id, selected) {\n    let result = {\n        \"aria-autocomplete\": \"list\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-controls\": id\n    };\n    if (selected > -1)\n        result[\"aria-activedescendant\"] = id + \"-\" + selected;\n    return result;\n}\nconst none = [];\nfunction getUpdateType(tr, conf) {\n    if (tr.isUserEvent(\"input.complete\")) {\n        let completion = tr.annotation(pickedCompletion);\n        if (completion && conf.activateOnCompletion(completion))\n            return 4 /* UpdateType.Activate */ | 8 /* UpdateType.Reset */;\n    }\n    let typing = tr.isUserEvent(\"input.type\");\n    return typing && conf.activateOnTyping ? 4 /* UpdateType.Activate */ | 1 /* UpdateType.Typing */\n        : typing ? 1 /* UpdateType.Typing */\n            : tr.isUserEvent(\"delete.backward\") ? 2 /* UpdateType.Backspacing */\n                : tr.selection ? 8 /* UpdateType.Reset */\n                    : tr.docChanged ? 16 /* UpdateType.ResetIfTouching */ : 0 /* UpdateType.None */;\n}\nclass ActiveSource {\n    constructor(source, state, explicitPos = -1) {\n        this.source = source;\n        this.state = state;\n        this.explicitPos = explicitPos;\n    }\n    hasResult() { return false; }\n    update(tr, conf) {\n        let type = getUpdateType(tr, conf), value = this;\n        if ((type & 8 /* UpdateType.Reset */) || (type & 16 /* UpdateType.ResetIfTouching */) && this.touches(tr))\n            value = new ActiveSource(value.source, 0 /* State.Inactive */);\n        if ((type & 4 /* UpdateType.Activate */) && value.state == 0 /* State.Inactive */)\n            value = new ActiveSource(this.source, 1 /* State.Pending */);\n        value = value.updateFor(tr, type);\n        for (let effect of tr.effects) {\n            if (effect.is(startCompletionEffect))\n                value = new ActiveSource(value.source, 1 /* State.Pending */, effect.value ? cur(tr.state) : -1);\n            else if (effect.is(closeCompletionEffect))\n                value = new ActiveSource(value.source, 0 /* State.Inactive */);\n            else if (effect.is(setActiveEffect))\n                for (let active of effect.value)\n                    if (active.source == value.source)\n                        value = active;\n        }\n        return value;\n    }\n    updateFor(tr, type) { return this.map(tr.changes); }\n    map(changes) {\n        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n    }\n    touches(tr) {\n        return tr.changes.touchesRange(cur(tr.state));\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicitPos, result, from, to) {\n        super(source, 2 /* State.Result */, explicitPos);\n        this.result = result;\n        this.from = from;\n        this.to = to;\n    }\n    hasResult() { return true; }\n    updateFor(tr, type) {\n        var _a;\n        if (!(type & 3 /* UpdateType.SimpleInteraction */))\n            return this.map(tr.changes);\n        let result = this.result;\n        if (result.map && !tr.changes.empty)\n            result = result.map(result, tr.changes);\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if ((this.explicitPos < 0 ? pos <= from : pos < this.from) ||\n            pos > to || !result ||\n            (type & 2 /* UpdateType.Backspacing */) && cur(tr.startState) == this.from)\n            return new ActiveSource(this.source, type & 4 /* UpdateType.Activate */ ? 1 /* State.Pending */ : 0 /* State.Inactive */);\n        let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos);\n        if (checkValid(result.validFor, tr.state, from, to))\n            return new ActiveResult(this.source, explicitPos, result, from, to);\n        if (result.update &&\n            (result = result.update(result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))\n            return new ActiveResult(this.source, explicitPos, result, result.from, (_a = result.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n        return new ActiveSource(this.source, 1 /* State.Pending */, explicitPos);\n    }\n    map(mapping) {\n        if (mapping.empty)\n            return this;\n        let result = this.result.map ? this.result.map(this.result, mapping) : this.result;\n        if (!result)\n            return new ActiveSource(this.source, 0 /* State.Inactive */);\n        return new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n    touches(tr) {\n        return tr.changes.touchesRange(this.from, this.to);\n    }\n}\nfunction checkValid(validFor, state, from, to) {\n    if (!validFor)\n        return false;\n    let text = state.sliceDoc(from, to);\n    return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\nconst setActiveEffect = /*@__PURE__*/StateEffect.define({\n    map(sources, mapping) { return sources.map(s => s.map(mapping)); }\n});\nconst setSelectedEffect = /*@__PURE__*/StateEffect.define();\nconst completionState = /*@__PURE__*/StateField.define({\n    create() { return CompletionState.start(); },\n    update(value, tr) { return value.update(tr); },\n    provide: f => [\n        showTooltip.from(f, val => val.tooltip),\n        EditorView.contentAttributes.from(f, state => state.attrs)\n    ]\n});\nfunction applyCompletion(view, option) {\n    const apply = option.completion.apply || option.completion.label;\n    let result = view.state.field(completionState).active.find(a => a.source == option.source);\n    if (!(result instanceof ActiveResult))\n        return false;\n    if (typeof apply == \"string\")\n        view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));\n    else\n        apply(view, option.completion, result.from, result.to);\n    return true;\n}\nconst createTooltip = /*@__PURE__*/completionTooltip(completionState, applyCompletion);\n\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\nfunction moveCompletionSelection(forward, by = \"option\") {\n    return (view) => {\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || cState.open.disabled ||\n            Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)\n            return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = getTooltip(view, cState.open.tooltip)))\n            step = Math.max(2, Math.floor(tooltip.dom.offsetHeight /\n                tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n        let { length } = cState.open.options;\n        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n        if (selected < 0)\n            selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length)\n            selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({ effects: setSelectedEffect.of(selected) });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/\nconst acceptCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled ||\n        Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)\n        return false;\n    return applyCompletion(view, cState.open.options[cState.open.selected]);\n};\n/**\nExplicitly start autocompletion.\n*/\nconst startCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState)\n        return false;\n    view.dispatch({ effects: startCompletionEffect.of(true) });\n    return true;\n};\n/**\nClose the currently active completion.\n*/\nconst closeCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some(a => a.state != 0 /* State.Inactive */))\n        return false;\n    view.dispatch({ effects: closeCompletionEffect.of(null) });\n    return true;\n};\nclass RunningQuery {\n    constructor(active, context) {\n        this.active = active;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.pendingStart = false;\n        this.composing = 0 /* CompositionState.None */;\n        for (let active of view.state.field(completionState).active)\n            if (active.state == 1 /* State.Pending */)\n                this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        let conf = update.state.facet(completionConfig);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)\n            return;\n        let doesReset = update.transactions.some(tr => {\n            let type = getUpdateType(tr, conf);\n            return (type & 8 /* UpdateType.Reset */) || (tr.selection || tr.docChanged) && !(type & 3 /* UpdateType.SimpleInteraction */);\n        });\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (doesReset ||\n                query.context.abortOnDocChange && update.docChanged ||\n                query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n                for (let handler of query.context.abortListeners) {\n                    try {\n                        handler();\n                    }\n                    catch (e) {\n                        logException(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            }\n            else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1)\n            clearTimeout(this.debounceUpdate);\n        if (update.transactions.some(tr => tr.effects.some(e => e.is(startCompletionEffect))))\n            this.pendingStart = true;\n        let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;\n        this.debounceUpdate = cState.active.some(a => a.state == 1 /* State.Pending */ && !this.running.some(q => q.active.source == a.source))\n            ? setTimeout(() => this.startUpdate(), delay) : -1;\n        if (this.composing != 0 /* CompositionState.None */)\n            for (let tr of update.transactions) {\n                if (tr.isUserEvent(\"input.type\"))\n                    this.composing = 2 /* CompositionState.Changed */;\n                else if (this.composing == 2 /* CompositionState.Changed */ && tr.selection)\n                    this.composing = 3 /* CompositionState.ChangedAndMoved */;\n            }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        this.pendingStart = false;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active) {\n            if (active.state == 1 /* State.Pending */ && !this.running.some(r => r.active.source == active.source))\n                this.startQuery(active);\n        }\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicitPos == pos, this.view);\n        let pending = new RunningQuery(active, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then(result => {\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, err => {\n            this.view.dispatch({ effects: closeCompletionEffect.of(null) });\n            logException(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every(q => q.done !== undefined))\n            this.accept();\n        else if (this.debounceAccept < 0)\n            this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1)\n            clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig);\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (query.done === undefined)\n                continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)\n                    active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);\n            if (current && current.state == 1 /* State.Pending */) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.active.source, 0 /* State.Inactive */);\n                    for (let tr of query.updates)\n                        active = active.update(tr, conf);\n                    if (active.state != 1 /* State.Pending */)\n                        updated.push(active);\n                }\n                else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length)\n            this.view.dispatch({ effects: setActiveEffect.of(updated) });\n    }\n}, {\n    eventHandlers: {\n        blur(event) {\n            let state = this.view.state.field(completionState, false);\n            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {\n                let dialog = state.open && getTooltip(this.view, state.open.tooltip);\n                if (!dialog || !dialog.dom.contains(event.relatedTarget))\n                    setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);\n            }\n        },\n        compositionstart() {\n            this.composing = 1 /* CompositionState.Started */;\n        },\n        compositionend() {\n            if (this.composing == 3 /* CompositionState.ChangedAndMoved */) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);\n            }\n            this.composing = 0 /* CompositionState.None */;\n        }\n    }\n});\nconst windows = typeof navigator == \"object\" && /*@__PURE__*//Win/.test(navigator.platform);\nconst commitCharacters = /*@__PURE__*/Prec.highest(/*@__PURE__*/EditorView.domEventHandlers({\n    keydown(event, view) {\n        let field = view.state.field(completionState, false);\n        if (!field || !field.open || field.open.disabled || field.open.selected < 0 ||\n            event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey)\n            return false;\n        let option = field.open.options[field.open.selected];\n        let result = field.active.find(a => a.source == option.source);\n        let commitChars = option.completion.commitCharacters || result.result.commitCharacters;\n        if (commitChars && commitChars.indexOf(event.key) > -1)\n            applyCompletion(view, option);\n        return false;\n    }\n}));\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            minWidth: \"250px\",\n            maxHeight: \"10em\",\n            height: \"100%\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li, & > completion-section\": {\n                padding: \"1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li\": {\n                overflowX: \"hidden\",\n                textOverflow: \"ellipsis\",\n                cursor: \"pointer\"\n            },\n            \"& > completion-section\": {\n                display: \"list-item\",\n                borderBottom: \"1px solid silver\",\n                paddingLeft: \"0.5em\",\n                opacity: 0.7\n            }\n        }\n    },\n    \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#17c\",\n        color: \"white\",\n    },\n    \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#777\",\n    },\n    \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#347\",\n        color: \"white\",\n    },\n    \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#444\",\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"···\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: `${400 /* Info.Width */}px`,\n        boxSizing: \"border-box\",\n        whiteSpace: \"pre-line\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": { right: \"100%\" },\n    \".cm-completionInfo.cm-completionInfo-right\": { left: \"100%\" },\n    \".cm-completionInfo.cm-completionInfo-left-narrow\": { right: `${30 /* Info.Margin */}px` },\n    \".cm-completionInfo.cm-completionInfo-right-narrow\": { left: `${30 /* Info.Margin */}px` },\n    \"&light .cm-snippetField\": { backgroundColor: \"#00000022\" },\n    \"&dark .cm-snippetField\": { backgroundColor: \"#ffffff22\" },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        display: \"inline-block\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\",\n        boxSizing: \"content-box\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": { content: \"'ƒ'\" }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": { content: \"'○'\" }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": { content: \"'◌'\" }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": { content: \"'𝑥'\" }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": { content: \"'𝐶'\" }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": { content: \"'𝑡'\" }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": { content: \"'∪'\" }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": { content: \"'□'\" }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": { content: \"'🔑\\uFE0E'\" } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": { content: \"'▢'\" }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": { content: \"'abc'\", fontSize: \"50%\", verticalAlign: \"middle\" }\n    }\n});\n\nclass FieldPos {\n    constructor(field, line, from, to) {\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to) {\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        let from = changes.mapPos(this.from, -1, MapMode.TrackDel);\n        let to = changes.mapPos(this.to, 1, MapMode.TrackDel);\n        return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions) {\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [pos];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines) {\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for (let i = 0; i < tabs; i++)\n                    indent += state.facet(indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return { text, ranges };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)) {\n            while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|((?:\\\\[{}]|[^}])*))\\}/.exec(line)) {\n                let seq = m[1] ? +m[1] : null, rawName = m[2] || m[3] || \"\", found = -1;\n                let name = rawName.replace(/\\\\[{}]/g, m => m[1]);\n                for (let i = 0; i < fields.length; i++) {\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)\n                        found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))\n                        i++;\n                    fields.splice(i, 0, { seq, name });\n                    found = i;\n                    for (let pos of positions)\n                        if (pos.field >= found)\n                            pos.field++;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);\n            }\n            line = line.replace(/\\\\([{}])/g, (_, brace, index) => {\n                for (let pos of positions)\n                    if (pos.line == lines.length && pos.from > index) {\n                        pos.from--;\n                        pos.to--;\n                    }\n                return brace;\n            });\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/Decoration.widget({ widget: /*@__PURE__*/new class extends WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() { return false; }\n    } });\nlet fieldRange = /*@__PURE__*/Decoration.mark({ class: \"cm-snippetField\" });\nclass ActiveSnippet {\n    constructor(ranges, active) {\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        let ranges = [];\n        for (let r of this.ranges) {\n            let mapped = r.map(changes);\n            if (!mapped)\n                return null;\n            ranges.push(mapped);\n        }\n        return new ActiveSnippet(ranges, this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/StateEffect.define({\n    map(value, changes) { return value && value.map(changes); }\n});\nconst moveToField = /*@__PURE__*/StateEffect.define();\nconst snippetState = /*@__PURE__*/StateField.define({\n    create() { return null; },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setActive))\n                return effect.value;\n            if (effect.is(moveToField) && value)\n                return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged)\n            value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection))\n            value = null;\n        return value;\n    },\n    provide: f => EditorView.decorations.from(f, val => val ? val.deco : Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return EditorSelection.create(ranges.filter(r => r.field == field).map(r => EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/\nfunction snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, completion, from, to) => {\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let spec = {\n            changes: { from, to, insert: Text.of(text) },\n            scrollIntoView: true,\n            annotations: completion ? [pickedCompletion.of(completion), Transaction.userEvent.of(\"input.complete\")] : undefined\n        };\n        if (ranges.length)\n            spec.selection = fieldSelection(ranges, 0);\n        if (ranges.some(r => r.field > 0)) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [setActive.of(active)];\n            if (editor.state.field(snippetState, false) === undefined)\n                effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch }) => {\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0)\n            return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),\n            scrollIntoView: true\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/\nconst clearSnippet = ({ state, dispatch }) => {\n    let active = state.field(snippetState, false);\n    if (!active)\n        return false;\n    dispatch(state.update({ effects: setActive.of(null) }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\nconst nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\nconst prevSnippetField = /*@__PURE__*/moveField(-1);\n/**\nCheck if there is an active snippet with a next field for\n`nextSnippetField` to move to.\n*/\nfunction hasNextSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.ranges.some(r => r.field == active.active + 1));\n}\n/**\nReturns true if there is an active snippet and a previous field\nfor `prevSnippetField` to move to.\n*/\nfunction hasPrevSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.active > 0);\n}\nconst defaultSnippetKeymap = [\n    { key: \"Tab\", run: nextSnippetField, shift: prevSnippetField },\n    { key: \"Escape\", run: clearSnippet }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\nconst snippetKeymap = /*@__PURE__*/Facet.define({\n    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }\n});\nconst addSnippetKeymap = /*@__PURE__*/Prec.highest(/*@__PURE__*/keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\nfunction snippetCompletion(template, completion) {\n    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });\n}\nconst snippetPointerHandler = /*@__PURE__*/EditorView.domEventHandlers({\n    mousedown(event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)\n            return false;\n        let match = active.ranges.find(r => r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active)\n            return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some(r => r.field > match.field)\n                ? new ActiveSnippet(active.ranges, match.field) : null),\n            scrollIntoView: true\n        });\n        return true;\n    }\n});\n\nfunction wordRE(wordChars) {\n    let escaped = wordChars.replace(/[\\]\\-\\\\]/g, \"\\\\$&\");\n    try {\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n    }\n    catch (_a) {\n        return new RegExp(`[\\w${escaped}]`, \"g\");\n    }\n}\nfunction mapRE(re, f) {\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/Object.create(null);\nfunction wordCache(wordChars) {\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n    for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {\n        let { value } = lines, m;\n        wordRE.lastIndex = 0;\n        while (m = wordRE.exec(value)) {\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\n                result.push({ type: \"text\", label: m[0] });\n                seen[m[0]] = true;\n                if (result.length >= 2000 /* C.MaxList */)\n                    return;\n            }\n        }\n        pos += value.length + 1;\n    }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n    let big = doc.length >= 1000 /* C.MinCacheLen */;\n    let cached = big && cache.get(doc);\n    if (cached)\n        return cached;\n    let result = [], seen = Object.create(null);\n    if (doc.children) {\n        let pos = 0;\n        for (let ch of doc.children) {\n            if (ch.length >= 1000 /* C.MinCacheLen */) {\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {\n                    if (!seen[c.label]) {\n                        seen[c.label] = true;\n                        result.push(c);\n                    }\n                }\n            }\n            else {\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n            }\n            pos += ch.length + 1;\n        }\n    }\n    else {\n        storeWords(doc, wordRE, result, seen, ignoreAt);\n    }\n    if (big && result.length < 2000 /* C.MaxList */)\n        cache.set(doc, result);\n    return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\nconst completeAnyWord = context => {\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n    let re = wordRE(wordChars);\n    let token = context.matchBefore(mapRE(re, s => s + \"$\"));\n    if (!token && !context.explicit)\n        return null;\n    let from = token ? token.from : context.pos;\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */, from);\n    return { from, options, validFor: mapRE(re, s => \"^\" + s) };\n};\n\nconst defaults = {\n    brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n    before: \")]}:;>\",\n    stringPrefixes: []\n};\nconst closeBracketEffect = /*@__PURE__*/StateEffect.define({\n    map(value, mapping) {\n        let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst closedBracket = /*@__PURE__*/new class extends RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/StateField.define({\n    create() { return RangeSet.empty; },\n    update(value, tr) {\n        value = value.map(tr.changes);\n        if (tr.selection) {\n            let line = tr.state.doc.lineAt(tr.selection.main.head);\n            value = value.update({ filter: from => from >= line.from && from <= line.to });\n        }\n        for (let effect of tr.effects)\n            if (effect.is(closeBracketEffect))\n                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });\n        return value;\n    }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/\nfunction closeBrackets() {\n    return [inputHandler, bracketState];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for (let i = 0; i < definedClosing.length; i += 2)\n        if (definedClosing.charCodeAt(i) == ch)\n            return definedClosing.charAt(i + 1);\n    return fromCodePoint(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\nconst inputHandler = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, insert) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)\n        return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1 ||\n        from != sel.from || to != sel.to)\n        return false;\n    let tr = insertBracket(view.state, insert);\n    if (!tr)\n        return false;\n    view.dispatch(tr);\n    return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/\nconst deleteBracketPair = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange(range => {\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens) {\n                if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))\n                    return { changes: { from: range.head - token.length, to: range.head + token.length },\n                        range: EditorSelection.cursor(range.head - token.length) };\n            }\n        }\n        return { range: dont = range };\n    });\n    if (!dont)\n        dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete.backward\" }));\n    return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/\nconst closeBracketsKeymap = [\n    { key: \"Backspace\", run: deleteBracketPair }\n];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert brackets—the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/\nfunction insertBracket(state, bracket) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens) {\n        let closed = closing(codePointAt(tok, 0));\n        if (bracket == tok)\n            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf)\n                : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from))\n            return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, from => {\n        if (from == pos)\n            found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, codePointSize(codePointAt(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],\n                effects: closeBracketEffect.of(range.to + open.length),\n                range: EditorSelection.range(range.anchor + open.length, range.head + open.length) };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1)\n            return { changes: { insert: open + close, from: range.head },\n                effects: closeBracketEffect.of(range.head + open.length),\n                range: EditorSelection.cursor(range.head + open.length) };\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (range.empty && nextChar(state.doc, range.head) == close)\n            return { changes: { from: range.head, to: range.head + close.length, insert: close },\n                range: EditorSelection.cursor(range.head + close.length) };\n        return dont = { range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple, config) {\n    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],\n                effects: closeBracketEffect.of(range.to + token.length),\n                range: EditorSelection.range(range.anchor + token.length, range.head + token.length) };\n        let pos = range.head, next = nextChar(state.doc, pos), start;\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: EditorSelection.cursor(pos + token.length) };\n            }\n            else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                let content = isTriple ? token + token + token : token;\n                return { changes: { from: pos, to: pos + content.length, insert: content },\n                    range: EditorSelection.cursor(pos + content.length) };\n            }\n        }\n        else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token &&\n            (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 &&\n            nodeStart(state, start)) {\n            return { changes: { insert: token + token + token + token, from: pos },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: EditorSelection.cursor(pos + token.length) };\n        }\n        else if (state.charCategorizer(pos)(next) != CharCategory.Word) {\n            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: EditorSelection.cursor(pos + token.length) };\n        }\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = syntaxTree(state).resolveInner(pos + 1);\n    return tree.parent && tree.from == pos;\n}\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n    let node = syntaxTree(state).resolveInner(pos, -1);\n    let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);\n    for (let i = 0; i < 5; i++) {\n        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n        let quotePos = start.indexOf(quoteToken);\n        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n            let first = node.firstChild;\n            while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {\n                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)\n                    return false;\n                first = first.firstChild;\n            }\n            return true;\n        }\n        let parent = node.to == pos && node.parent;\n        if (!parent)\n            break;\n        node = parent;\n    }\n    return false;\n}\nfunction canStartStringAt(state, pos, prefixes) {\n    let charCat = state.charCategorizer(pos);\n    if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)\n        return pos;\n    for (let prefix of prefixes) {\n        let start = pos - prefix.length;\n        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)\n            return start;\n    }\n    return -1;\n}\n\n/**\nReturns an extension that enables autocompletion.\n*/\nfunction autocompletion(config = {}) {\n    return [\n        commitCharacters,\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space (and Alt-\\` on macOS): [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\nconst completionKeymap = [\n    { key: \"Ctrl-Space\", run: startCompletion },\n    { mac: \"Alt-`\", run: startCompletion },\n    { key: \"Escape\", run: closeCompletion },\n    { key: \"ArrowDown\", run: /*@__PURE__*/moveCompletionSelection(true) },\n    { key: \"ArrowUp\", run: /*@__PURE__*/moveCompletionSelection(false) },\n    { key: \"PageDown\", run: /*@__PURE__*/moveCompletionSelection(true, \"page\") },\n    { key: \"PageUp\", run: /*@__PURE__*/moveCompletionSelection(false, \"page\") },\n    { key: \"Enter\", run: acceptCompletion }\n];\nconst completionKeymapExt = /*@__PURE__*/Prec.highest(/*@__PURE__*/keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\nfunction completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some(a => a.state == 1 /* State.Pending */) ? \"pending\"\n        : cState && cState.active.some(a => a.state != 0 /* State.Inactive */) ? \"active\" : null;\n}\nconst completionArrayCache = /*@__PURE__*/new WeakMap;\n/**\nReturns the available completions as an array.\n*/\nfunction currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    if (!open || open.disabled)\n        return [];\n    let completions = completionArrayCache.get(open.options);\n    if (!completions)\n        completionArrayCache.set(open.options, completions = open.options.map(o => o.completion));\n    return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/\nfunction selectedCompletion(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/\nfunction selectedCompletionIndex(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/\nfunction setSelectedCompletion(index) {\n    return setSelectedEffect.of(index);\n}\n\nexport { CompletionContext, acceptCompletion, autocompletion, clearSnippet, closeBrackets, closeBracketsKeymap, closeCompletion, completeAnyWord, completeFromList, completionKeymap, completionStatus, currentCompletions, deleteBracketPair, hasNextSnippetField, hasPrevSnippetField, ifIn, ifNotIn, insertBracket, insertCompletionText, moveCompletionSelection, nextSnippetField, pickedCompletion, prevSnippetField, selectedCompletion, selectedCompletionIndex, setSelectedCompletion, snippet, snippetCompletion, snippetKeymap, startCompletion };\n"]},"metadata":{},"sourceType":"module"}