{"ast":null,"code":"import _toConsumableArray from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _inherits from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec, EditorState, findClusterBreak } from '@codemirror/state';\nimport elt from 'crelt';\nvar basicNormalize = typeof String.prototype.normalize == \"function\" ? function (x) {\n  return x.normalize(\"NFKD\");\n} : function (x) {\n  return x;\n};\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\n\nvar SearchCursor = /*#__PURE__*/function () {\n  /**\n  Create a text cursor. The query is the search string, `from` to\n  `to` provides the region to search.\n  \n  When `normalize` is given, it will be called, on both the query\n  string and the content it is matched against, before comparing.\n  You can, for example, create a case-insensitive search by\n  passing `s => s.toLowerCase()`.\n  \n  Text is always normalized with\n  [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n  (when supported).\n  */\n  function SearchCursor(text, query) {\n    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : text.length;\n    var normalize = arguments.length > 4 ? arguments[4] : undefined;\n    var test = arguments.length > 5 ? arguments[5] : undefined;\n\n    _classCallCheck(this, SearchCursor);\n\n    this.test = test;\n    /**\n    The current match (only holds a meaningful value after\n    [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n    `done` is false).\n    */\n\n    this.value = {\n      from: 0,\n      to: 0\n    };\n    /**\n    Whether the end of the iterated region has been reached.\n    */\n\n    this.done = false;\n    this.matches = [];\n    this.buffer = \"\";\n    this.bufferPos = 0;\n    this.iter = text.iterRange(from, to);\n    this.bufferStart = from;\n    this.normalize = normalize ? function (x) {\n      return normalize(basicNormalize(x));\n    } : basicNormalize;\n    this.query = this.normalize(query);\n  }\n\n  _createClass(SearchCursor, [{\n    key: \"peek\",\n    value: function peek() {\n      if (this.bufferPos == this.buffer.length) {\n        this.bufferStart += this.buffer.length;\n        this.iter.next();\n        if (this.iter.done) return -1;\n        this.bufferPos = 0;\n        this.buffer = this.iter.value;\n      }\n\n      return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      while (this.matches.length) {\n        this.matches.pop();\n      }\n\n      return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n\n  }, {\n    key: \"nextOverlapping\",\n    value: function nextOverlapping() {\n      for (;;) {\n        var next = this.peek();\n\n        if (next < 0) {\n          this.done = true;\n          return this;\n        }\n\n        var str = fromCodePoint(next),\n            start = this.bufferStart + this.bufferPos;\n        this.bufferPos += codePointSize(next);\n        var norm = this.normalize(str);\n\n        for (var i = 0, pos = start;; i++) {\n          var code = norm.charCodeAt(i);\n          var match = this.match(code, pos, this.bufferPos + this.bufferStart);\n\n          if (i == norm.length - 1) {\n            if (match) {\n              this.value = match;\n              return this;\n            }\n\n            break;\n          }\n\n          if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n        }\n      }\n    }\n  }, {\n    key: \"match\",\n    value: function match(code, pos, end) {\n      var match = null;\n\n      for (var i = 0; i < this.matches.length; i += 2) {\n        var index = this.matches[i],\n            keep = false;\n\n        if (this.query.charCodeAt(index) == code) {\n          if (index == this.query.length - 1) {\n            match = {\n              from: this.matches[i + 1],\n              to: end\n            };\n          } else {\n            this.matches[i]++;\n            keep = true;\n          }\n        }\n\n        if (!keep) {\n          this.matches.splice(i, 2);\n          i -= 2;\n        }\n      }\n\n      if (this.query.charCodeAt(0) == code) {\n        if (this.query.length == 1) match = {\n          from: pos,\n          to: end\n        };else this.matches.push(1, pos);\n      }\n\n      if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart)) match = null;\n      return match;\n    }\n  }]);\n\n  return SearchCursor;\n}();\n\nif (typeof Symbol != \"undefined\") SearchCursor.prototype[Symbol.iterator] = function () {\n  return this;\n};\nvar empty = {\n  from: -1,\n  to: -1,\n  match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nvar baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\n\nvar RegExpCursor = /*#__PURE__*/function () {\n  /**\n  Create a cursor that will search the given range in the given\n  document. `query` should be the raw pattern (as you'd pass it to\n  `new RegExp`).\n  */\n  function RegExpCursor(text, query, options) {\n    var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : text.length;\n\n    _classCallCheck(this, RegExpCursor);\n\n    this.text = text;\n    this.to = to;\n    this.curLine = \"\";\n    /**\n    Set to `true` when the cursor has reached the end of the search\n    range.\n    */\n\n    this.done = false;\n    /**\n    Will contain an object with the extent of the match and the\n    match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n    sucessfully finds a match.\n    */\n\n    this.value = empty;\n    if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.test = options === null || options === void 0 ? void 0 : options.test;\n    this.iter = text.iter();\n    var startLine = text.lineAt(from);\n    this.curLineStart = startLine.from;\n    this.matchPos = toCharEnd(text, from);\n    this.getLine(this.curLineStart);\n  }\n\n  _createClass(RegExpCursor, [{\n    key: \"getLine\",\n    value: function getLine(skip) {\n      this.iter.next(skip);\n\n      if (this.iter.lineBreak) {\n        this.curLine = \"\";\n      } else {\n        this.curLine = this.iter.value;\n        if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n        this.iter.next();\n      }\n    }\n  }, {\n    key: \"nextLine\",\n    value: function nextLine() {\n      this.curLineStart = this.curLineStart + this.curLine.length + 1;\n      if (this.curLineStart > this.to) this.curLine = \"\";else this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      for (var off = this.matchPos - this.curLineStart;;) {\n        this.re.lastIndex = off;\n        var match = this.matchPos <= this.to && this.re.exec(this.curLine);\n\n        if (match) {\n          var from = this.curLineStart + match.index,\n              to = from + match[0].length;\n          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n          if (from == this.curLineStart + this.curLine.length) this.nextLine();\n\n          if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n            this.value = {\n              from: from,\n              to: to,\n              match: match\n            };\n            return this;\n          }\n\n          off = this.matchPos - this.curLineStart;\n        } else if (this.curLineStart + this.curLine.length < this.to) {\n          this.nextLine();\n          off = 0;\n        } else {\n          this.done = true;\n          return this;\n        }\n      }\n    }\n  }]);\n\n  return RegExpCursor;\n}();\n\nvar flattened = /*@__PURE__*/new WeakMap(); // Reusable (partially) flattened document strings\n\nvar FlattenedDoc = /*#__PURE__*/function () {\n  function FlattenedDoc(from, text) {\n    _classCallCheck(this, FlattenedDoc);\n\n    this.from = from;\n    this.text = text;\n  }\n\n  _createClass(FlattenedDoc, [{\n    key: \"to\",\n    get: function get() {\n      return this.from + this.text.length;\n    }\n  }], [{\n    key: \"get\",\n    value: function get(doc, from, to) {\n      var cached = flattened.get(doc);\n\n      if (!cached || cached.from >= to || cached.to <= from) {\n        var flat = new FlattenedDoc(from, doc.sliceString(from, to));\n        flattened.set(doc, flat);\n        return flat;\n      }\n\n      if (cached.from == from && cached.to == to) return cached;\n      var text = cached.text,\n          cachedFrom = cached.from;\n\n      if (cachedFrom > from) {\n        text = doc.sliceString(from, cachedFrom) + text;\n        cachedFrom = from;\n      }\n\n      if (cached.to < to) text += doc.sliceString(cached.to, to);\n      flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n      return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n  }]);\n\n  return FlattenedDoc;\n}();\n\nvar MultilineRegExpCursor = /*#__PURE__*/function () {\n  function MultilineRegExpCursor(text, query, options, from, to) {\n    _classCallCheck(this, MultilineRegExpCursor);\n\n    this.text = text;\n    this.to = to;\n    this.done = false;\n    this.value = empty;\n    this.matchPos = toCharEnd(text, from);\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.test = options === null || options === void 0 ? void 0 : options.test;\n    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000\n    /* Chunk.Base */\n    ));\n  }\n\n  _createClass(MultilineRegExpCursor, [{\n    key: \"chunkEnd\",\n    value: function chunkEnd(pos) {\n      return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      for (;;) {\n        var off = this.re.lastIndex = this.matchPos - this.flat.from;\n        var match = this.re.exec(this.flat.text); // Skip empty matches directly after the last match\n\n        if (match && !match[0] && match.index == off) {\n          this.re.lastIndex = off + 1;\n          match = this.re.exec(this.flat.text);\n        }\n\n        if (match) {\n          var from = this.flat.from + match.index,\n              to = from + match[0].length; // If a match goes almost to the end of a noncomplete chunk, try\n          // again, since it'll likely be able to match more\n\n          if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {\n            this.value = {\n              from: from,\n              to: to,\n              match: match\n            };\n            this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n            return this;\n          }\n        }\n\n        if (this.flat.to == this.to) {\n          this.done = true;\n          return this;\n        } // Grow the flattened doc\n\n\n        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n      }\n    }\n  }]);\n\n  return MultilineRegExpCursor;\n}();\n\nif (typeof Symbol != \"undefined\") {\n  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n}\n\nfunction validRegExp(source) {\n  try {\n    new RegExp(source, baseFlags);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nfunction toCharEnd(text, pos) {\n  if (pos >= text.length) return pos;\n  var line = text.lineAt(pos),\n      next;\n\n  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000) {\n    pos++;\n  }\n\n  return pos;\n}\n\nfunction createLineDialog(view) {\n  var line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n  var input = elt(\"input\", {\n    class: \"cm-textfield\",\n    name: \"line\",\n    value: line\n  });\n  var dom = elt(\"form\", {\n    class: \"cm-gotoLine\",\n    onkeydown: function onkeydown(event) {\n      if (event.keyCode == 27) {\n        // Escape\n        event.preventDefault();\n        view.dispatch({\n          effects: dialogEffect.of(false)\n        });\n        view.focus();\n      } else if (event.keyCode == 13) {\n        // Enter\n        event.preventDefault();\n        go();\n      }\n    },\n    onsubmit: function onsubmit(event) {\n      event.preventDefault();\n      go();\n    }\n  }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", {\n    class: \"cm-button\",\n    type: \"submit\"\n  }, view.state.phrase(\"go\")));\n\n  function go() {\n    var match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n    if (!match) return;\n    var state = view.state,\n        startLine = state.doc.lineAt(state.selection.main.head);\n\n    var _match = _slicedToArray(match, 5),\n        sign = _match[1],\n        ln = _match[2],\n        cl = _match[3],\n        percent = _match[4];\n\n    var col = cl ? +cl.slice(1) : 0;\n    var line = ln ? +ln : startLine.number;\n\n    if (ln && percent) {\n      var pc = line / 100;\n      if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n      line = Math.round(state.doc.lines * pc);\n    } else if (ln && sign) {\n      line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n    }\n\n    var docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n    var selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n    view.dispatch({\n      effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, {\n        y: 'center'\n      })],\n      selection: selection\n    });\n    view.focus();\n  }\n\n  return {\n    dom: dom\n  };\n}\n\nvar dialogEffect = /*@__PURE__*/StateEffect.define();\nvar dialogField = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return true;\n  },\n  update: function update(value, tr) {\n    var _iterator = _createForOfIteratorHelper(tr.effects),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var e = _step.value;\n        if (e.is(dialogEffect)) value = e.value;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return value;\n  },\n  provide: function provide(f) {\n    return showPanel.from(f, function (val) {\n      return val ? createLineDialog : null;\n    });\n  }\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/\n\nvar gotoLine = function gotoLine(view) {\n  var panel = getPanel(view, createLineDialog);\n\n  if (!panel) {\n    var effects = [dialogEffect.of(true)];\n    if (view.state.field(dialogField, false) == null) effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n    view.dispatch({\n      effects: effects\n    });\n    panel = getPanel(view, createLineDialog);\n  }\n\n  if (panel) panel.dom.querySelector(\"input\").select();\n  return true;\n};\n\nvar baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-panel.cm-gotoLine\": {\n    padding: \"2px 6px 4px\",\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  }\n});\nvar defaultHighlightOptions = {\n  highlightWordAroundCursor: false,\n  minSelectionLength: 1,\n  maxMatches: 100,\n  wholeWords: false\n};\nvar highlightConfig = /*@__PURE__*/Facet.define({\n  combine: function combine(options) {\n    return combineConfig(options, defaultHighlightOptions, {\n      highlightWordAroundCursor: function highlightWordAroundCursor(a, b) {\n        return a || b;\n      },\n      minSelectionLength: Math.min,\n      maxMatches: Math.min\n    });\n  }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\n\nfunction highlightSelectionMatches(options) {\n  var ext = [defaultTheme, matchHighlighter];\n  if (options) ext.push(highlightConfig.of(options));\n  return ext;\n}\n\nvar matchDeco = /*@__PURE__*/Decoration.mark({\n  class: \"cm-selectionMatch\"\n});\nvar mainMatchDeco = /*@__PURE__*/Decoration.mark({\n  class: \"cm-selectionMatch cm-selectionMatch-main\"\n}); // Whether the characters directly outside the given positions are non-word characters\n\nfunction insideWordBoundaries(check, state, from, to) {\n  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n} // Whether the characters directly at the given positions are word characters\n\n\nfunction insideWord(check, state, from, to) {\n  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\n\nvar matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.decorations = this.getDeco(view);\n  }\n\n  _createClass(_class, [{\n    key: \"update\",\n    value: function update(_update) {\n      if (_update.selectionSet || _update.docChanged || _update.viewportChanged) this.decorations = this.getDeco(_update.view);\n    }\n  }, {\n    key: \"getDeco\",\n    value: function getDeco(view) {\n      var conf = view.state.facet(highlightConfig);\n      var state = view.state,\n          sel = state.selection;\n      if (sel.ranges.length > 1) return Decoration.none;\n      var range = sel.main,\n          query,\n          check = null;\n\n      if (range.empty) {\n        if (!conf.highlightWordAroundCursor) return Decoration.none;\n        var word = state.wordAt(range.head);\n        if (!word) return Decoration.none;\n        check = state.charCategorizer(range.head);\n        query = state.sliceDoc(word.from, word.to);\n      } else {\n        var len = range.to - range.from;\n        if (len < conf.minSelectionLength || len > 200) return Decoration.none;\n\n        if (conf.wholeWords) {\n          query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n\n          check = state.charCategorizer(range.head);\n          if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to))) return Decoration.none;\n        } else {\n          query = state.sliceDoc(range.from, range.to);\n          if (!query) return Decoration.none;\n        }\n      }\n\n      var deco = [];\n\n      var _iterator2 = _createForOfIteratorHelper(view.visibleRanges),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var part = _step2.value;\n          var cursor = new SearchCursor(state.doc, query, part.from, part.to);\n\n          while (!cursor.next().done) {\n            var _cursor$value = cursor.value,\n                from = _cursor$value.from,\n                to = _cursor$value.to;\n\n            if (!check || insideWordBoundaries(check, state, from, to)) {\n              if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n              if (deco.length > conf.maxMatches) return Decoration.none;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return Decoration.set(deco);\n    }\n  }]);\n\n  return _class;\n}(), {\n  decorations: function decorations(v) {\n    return v.decorations;\n  }\n});\nvar defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-selectionMatch\": {\n    backgroundColor: \"#99ff7780\"\n  },\n  \".cm-searchMatch .cm-selectionMatch\": {\n    backgroundColor: \"transparent\"\n  }\n}); // Select the words around the cursors.\n\nvar selectWord = function selectWord(_ref) {\n  var state = _ref.state,\n      dispatch = _ref.dispatch;\n  var selection = state.selection;\n  var newSel = EditorSelection.create(selection.ranges.map(function (range) {\n    return state.wordAt(range.head) || EditorSelection.cursor(range.head);\n  }), selection.mainIndex);\n  if (newSel.eq(selection)) return false;\n  dispatch(state.update({\n    selection: newSel\n  }));\n  return true;\n}; // Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\n\n\nfunction findNextOccurrence(state, query) {\n  var _state$selection = state.selection,\n      main = _state$selection.main,\n      ranges = _state$selection.ranges;\n  var word = state.wordAt(main.head),\n      fullWord = word && word.from == main.from && word.to == main.to;\n\n  var _loop = function _loop(_cycled, _cursor) {\n    _cursor.next();\n\n    if (_cursor.done) {\n      if (_cycled) {\n        cursor = _cursor;\n        {\n          cycled = _cycled;\n          return {\n            v: null\n          };\n        }\n      }\n\n      _cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n      _cycled = true;\n    } else {\n      if (_cycled && ranges.some(function (r) {\n        return r.from == _cursor.value.from;\n      })) {\n        cursor = _cursor;\n        {\n          cycled = _cycled;\n          return \"continue\";\n        }\n      }\n\n      if (fullWord) {\n        var _word = state.wordAt(_cursor.value.from);\n\n        if (!_word || _word.from != _cursor.value.from || _word.to != _cursor.value.to) {\n          cursor = _cursor;\n          {\n            cycled = _cycled;\n            return \"continue\";\n          }\n        }\n      }\n\n      cycled = _cycled;\n      cursor = _cursor;\n      return {\n        v: _cursor.value\n      };\n    }\n\n    cycled = _cycled;\n    cursor = _cursor;\n  };\n\n  for (var cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n    var _ret = _loop(cycled, cursor);\n\n    if (_ret === \"continue\") continue;\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\n\n\nvar selectNextOccurrence = function selectNextOccurrence(_ref2) {\n  var state = _ref2.state,\n      dispatch = _ref2.dispatch;\n  var ranges = state.selection.ranges;\n  if (ranges.some(function (sel) {\n    return sel.from === sel.to;\n  })) return selectWord({\n    state: state,\n    dispatch: dispatch\n  });\n  var searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n  if (state.selection.ranges.some(function (r) {\n    return state.sliceDoc(r.from, r.to) != searchedText;\n  })) return false;\n  var range = findNextOccurrence(state, searchedText);\n  if (!range) return false;\n  dispatch(state.update({\n    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n    effects: EditorView.scrollIntoView(range.to)\n  }));\n  return true;\n};\n\nvar searchConfigFacet = /*@__PURE__*/Facet.define({\n  combine: function combine(configs) {\n    return combineConfig(configs, {\n      top: false,\n      caseSensitive: false,\n      literal: false,\n      regexp: false,\n      wholeWord: false,\n      createPanel: function createPanel(view) {\n        return new SearchPanel(view);\n      },\n      scrollToMatch: function scrollToMatch(range) {\n        return EditorView.scrollIntoView(range);\n      }\n    });\n  }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\n\nfunction search(config) {\n  return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\n\n\nvar SearchQuery = /*#__PURE__*/function () {\n  /**\n  Create a query object.\n  */\n  function SearchQuery(config) {\n    _classCallCheck(this, SearchQuery);\n\n    this.search = config.search;\n    this.caseSensitive = !!config.caseSensitive;\n    this.literal = !!config.literal;\n    this.regexp = !!config.regexp;\n    this.replace = config.replace || \"\";\n    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n    this.unquoted = this.unquote(this.search);\n    this.wholeWord = !!config.wholeWord;\n  }\n  /**\n  @internal\n  */\n\n\n  _createClass(SearchQuery, [{\n    key: \"unquote\",\n    value: function unquote(text) {\n      return this.literal ? text : text.replace(/\\\\([nrt\\\\])/g, function (_, ch) {\n        return ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\";\n      });\n    }\n    /**\n    Compare this query to another query.\n    */\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"create\",\n    value: function create() {\n      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */\n\n  }, {\n    key: \"getCursor\",\n    value: function getCursor(state) {\n      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var to = arguments.length > 2 ? arguments[2] : undefined;\n      var st = state.doc ? state : EditorState.create({\n        doc: state\n      });\n      if (to == null) to = st.doc.length;\n      return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n  }]);\n\n  return SearchQuery;\n}();\n\nvar QueryType = function QueryType(spec) {\n  _classCallCheck(this, QueryType);\n\n  this.spec = spec;\n};\n\nfunction stringCursor(spec, state, from, to) {\n  return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : function (x) {\n    return x.toLowerCase();\n  }, spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\n\nfunction stringWordTest(doc, categorizer) {\n  return function (from, to, buf, bufPos) {\n    if (bufPos > from || bufPos + buf.length < to) {\n      bufPos = Math.max(0, from - 2);\n      buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n    }\n\n    return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);\n  };\n}\n\nvar StringQuery = /*#__PURE__*/function (_QueryType) {\n  _inherits(StringQuery, _QueryType);\n\n  var _super = _createSuper(StringQuery);\n\n  function StringQuery(spec) {\n    _classCallCheck(this, StringQuery);\n\n    return _super.call(this, spec);\n  }\n\n  _createClass(StringQuery, [{\n    key: \"nextMatch\",\n    value: function nextMatch(state, curFrom, curTo) {\n      var cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n      if (cursor.done) cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n      return cursor.done ? null : cursor.value;\n    } // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n\n  }, {\n    key: \"prevMatchInRange\",\n    value: function prevMatchInRange(state, from, to) {\n      for (var pos = to;;) {\n        var start = Math.max(from, pos - 10000\n        /* FindPrev.ChunkSize */\n        - this.spec.unquoted.length);\n\n        var _cursor2 = stringCursor(this.spec, state, start, pos),\n            range = null;\n\n        while (!_cursor2.nextOverlapping().done) {\n          range = _cursor2.value;\n        }\n\n        if (range) return range;\n        if (start == from) return null;\n        pos -= 10000\n        /* FindPrev.ChunkSize */\n        ;\n      }\n    }\n  }, {\n    key: \"prevMatch\",\n    value: function prevMatch(state, curFrom, curTo) {\n      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n  }, {\n    key: \"getReplacement\",\n    value: function getReplacement(_result) {\n      return this.spec.unquote(this.spec.replace);\n    }\n  }, {\n    key: \"matchAll\",\n    value: function matchAll(state, limit) {\n      var cursor = stringCursor(this.spec, state, 0, state.doc.length),\n          ranges = [];\n\n      while (!cursor.next().done) {\n        if (ranges.length >= limit) return null;\n        ranges.push(cursor.value);\n      }\n\n      return ranges;\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(state, from, to, add) {\n      var cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n\n      while (!cursor.next().done) {\n        add(cursor.value.from, cursor.value.to);\n      }\n    }\n  }]);\n\n  return StringQuery;\n}(QueryType);\n\nfunction regexpCursor(spec, state, from, to) {\n  return new RegExpCursor(state.doc, spec.search, {\n    ignoreCase: !spec.caseSensitive,\n    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n  }, from, to);\n}\n\nfunction charBefore(str, index) {\n  return str.slice(findClusterBreak(str, index, false), index);\n}\n\nfunction charAfter(str, index) {\n  return str.slice(index, findClusterBreak(str, index));\n}\n\nfunction regexpWordTest(categorizer) {\n  return function (_from, _to, match) {\n    return !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);\n  };\n}\n\nvar RegExpQuery = /*#__PURE__*/function (_QueryType2) {\n  _inherits(RegExpQuery, _QueryType2);\n\n  var _super2 = _createSuper(RegExpQuery);\n\n  function RegExpQuery() {\n    _classCallCheck(this, RegExpQuery);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(RegExpQuery, [{\n    key: \"nextMatch\",\n    value: function nextMatch(state, curFrom, curTo) {\n      var cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n      if (cursor.done) cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n      return cursor.done ? null : cursor.value;\n    }\n  }, {\n    key: \"prevMatchInRange\",\n    value: function prevMatchInRange(state, from, to) {\n      for (var size = 1;; size++) {\n        var start = Math.max(from, to - size * 10000\n        /* FindPrev.ChunkSize */\n        );\n\n        var _cursor3 = regexpCursor(this.spec, state, start, to),\n            range = null;\n\n        while (!_cursor3.next().done) {\n          range = _cursor3.value;\n        }\n\n        if (range && (start == from || range.from > start + 10)) return range;\n        if (start == from) return null;\n      }\n    }\n  }, {\n    key: \"prevMatch\",\n    value: function prevMatch(state, curFrom, curTo) {\n      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n  }, {\n    key: \"getReplacement\",\n    value: function getReplacement(result) {\n      return this.spec.unquote(this.spec.replace).replace(/\\$([$&\\d+])/g, function (m, i) {\n        return i == \"$\" ? \"$\" : i == \"&\" ? result.match[0] : i != \"0\" && +i < result.match.length ? result.match[i] : m;\n      });\n    }\n  }, {\n    key: \"matchAll\",\n    value: function matchAll(state, limit) {\n      var cursor = regexpCursor(this.spec, state, 0, state.doc.length),\n          ranges = [];\n\n      while (!cursor.next().done) {\n        if (ranges.length >= limit) return null;\n        ranges.push(cursor.value);\n      }\n\n      return ranges;\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(state, from, to, add) {\n      var cursor = regexpCursor(this.spec, state, Math.max(0, from - 250\n      /* RegExp.HighlightMargin */\n      ), Math.min(to + 250\n      /* RegExp.HighlightMargin */\n      , state.doc.length));\n\n      while (!cursor.next().done) {\n        add(cursor.value.from, cursor.value.to);\n      }\n    }\n  }]);\n\n  return RegExpQuery;\n}(QueryType);\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\n\n\nvar setSearchQuery = /*@__PURE__*/StateEffect.define();\nvar togglePanel = /*@__PURE__*/StateEffect.define();\nvar searchState = /*@__PURE__*/StateField.define({\n  create: function create(state) {\n    return new SearchState(defaultQuery(state).create(), null);\n  },\n  update: function update(value, tr) {\n    var _iterator3 = _createForOfIteratorHelper(tr.effects),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var effect = _step3.value;\n        if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return value;\n  },\n  provide: function provide(f) {\n    return showPanel.from(f, function (val) {\n      return val.panel;\n    });\n  }\n});\n/**\nGet the current search query from an editor state.\n*/\n\nfunction getSearchQuery(state) {\n  var curState = state.field(searchState, false);\n  return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\n\n\nfunction searchPanelOpen(state) {\n  var _a;\n\n  return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\n\nvar SearchState = function SearchState(query, panel) {\n  _classCallCheck(this, SearchState);\n\n  this.query = query;\n  this.panel = panel;\n};\n\nvar matchMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-searchMatch\"\n}),\n    selectedMatchMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nvar searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class2(view) {\n    _classCallCheck(this, _class2);\n\n    this.view = view;\n    this.decorations = this.highlight(view.state.field(searchState));\n  }\n\n  _createClass(_class2, [{\n    key: \"update\",\n    value: function update(_update2) {\n      var state = _update2.state.field(searchState);\n\n      if (state != _update2.startState.field(searchState) || _update2.docChanged || _update2.selectionSet || _update2.viewportChanged) this.decorations = this.highlight(state);\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(_ref3) {\n      var query = _ref3.query,\n          panel = _ref3.panel;\n      if (!panel || !query.spec.valid) return Decoration.none;\n      var view = this.view;\n      var builder = new RangeSetBuilder();\n\n      for (var i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n        var _ranges$i = ranges[i],\n            from = _ranges$i.from,\n            to = _ranges$i.to;\n\n        while (i < l - 1 && to > ranges[i + 1].from - 2 * 250\n        /* RegExp.HighlightMargin */\n        ) {\n          to = ranges[++i].to;\n        }\n\n        query.highlight(view.state, from, to, function (from, to) {\n          var selected = view.state.selection.ranges.some(function (r) {\n            return r.from == from && r.to == to;\n          });\n          builder.add(from, to, selected ? selectedMatchMark : matchMark);\n        });\n      }\n\n      return builder.finish();\n    }\n  }]);\n\n  return _class2;\n}(), {\n  decorations: function decorations(v) {\n    return v.decorations;\n  }\n});\n\nfunction searchCommand(f) {\n  return function (view) {\n    var state = view.state.field(searchState, false);\n    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n  };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\n\n\nvar findNext = /*@__PURE__*/searchCommand(function (view, _ref4) {\n  var query = _ref4.query;\n  var to = view.state.selection.main.to;\n  var next = query.nextMatch(view.state, to, to);\n  if (!next) return false;\n  var selection = EditorSelection.single(next.from, next.to);\n  var config = view.state.facet(searchConfigFacet);\n  view.dispatch({\n    selection: selection,\n    effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],\n    userEvent: \"select.search\"\n  });\n  selectSearchInput(view);\n  return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\n\nvar findPrevious = /*@__PURE__*/searchCommand(function (view, _ref5) {\n  var query = _ref5.query;\n  var state = view.state,\n      from = state.selection.main.from;\n  var prev = query.prevMatch(state, from, from);\n  if (!prev) return false;\n  var selection = EditorSelection.single(prev.from, prev.to);\n  var config = view.state.facet(searchConfigFacet);\n  view.dispatch({\n    selection: selection,\n    effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],\n    userEvent: \"select.search\"\n  });\n  selectSearchInput(view);\n  return true;\n});\n/**\nSelect all instances of the search query.\n*/\n\nvar selectMatches = /*@__PURE__*/searchCommand(function (view, _ref6) {\n  var query = _ref6.query;\n  var ranges = query.matchAll(view.state, 1000);\n  if (!ranges || !ranges.length) return false;\n  view.dispatch({\n    selection: EditorSelection.create(ranges.map(function (r) {\n      return EditorSelection.range(r.from, r.to);\n    })),\n    userEvent: \"select.search.matches\"\n  });\n  return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\n\nvar selectSelectionMatches = function selectSelectionMatches(_ref7) {\n  var state = _ref7.state,\n      dispatch = _ref7.dispatch;\n  var sel = state.selection;\n  if (sel.ranges.length > 1 || sel.main.empty) return false;\n  var _sel$main = sel.main,\n      from = _sel$main.from,\n      to = _sel$main.to;\n  var ranges = [],\n      main = 0;\n\n  for (var cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n    if (ranges.length > 1000) return false;\n    if (cur.value.from == from) main = ranges.length;\n    ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n  }\n\n  dispatch(state.update({\n    selection: EditorSelection.create(ranges, main),\n    userEvent: \"select.search.matches\"\n  }));\n  return true;\n};\n/**\nReplace the current match of the search query.\n*/\n\n\nvar replaceNext = /*@__PURE__*/searchCommand(function (view, _ref8) {\n  var query = _ref8.query;\n  var state = view.state,\n      _state$selection$main = state.selection.main,\n      from = _state$selection$main.from,\n      to = _state$selection$main.to;\n  if (state.readOnly) return false;\n  var next = query.nextMatch(state, from, from);\n  if (!next) return false;\n  var changes = [],\n      selection,\n      replacement;\n  var effects = [];\n\n  if (next.from == from && next.to == to) {\n    replacement = state.toText(query.getReplacement(next));\n    changes.push({\n      from: next.from,\n      to: next.to,\n      insert: replacement\n    });\n    next = query.nextMatch(state, next.from, next.to);\n    effects.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n  }\n\n  if (next) {\n    var off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n    selection = EditorSelection.single(next.from - off, next.to - off);\n    effects.push(announceMatch(view, next));\n    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n  }\n\n  view.dispatch({\n    changes: changes,\n    selection: selection,\n    effects: effects,\n    userEvent: \"input.replace\"\n  });\n  return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\n\nvar replaceAll = /*@__PURE__*/searchCommand(function (view, _ref9) {\n  var query = _ref9.query;\n  if (view.state.readOnly) return false;\n  var changes = query.matchAll(view.state, 1e9).map(function (match) {\n    var from = match.from,\n        to = match.to;\n    return {\n      from: from,\n      to: to,\n      insert: query.getReplacement(match)\n    };\n  });\n  if (!changes.length) return false;\n  var announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n  view.dispatch({\n    changes: changes,\n    effects: EditorView.announce.of(announceText),\n    userEvent: \"input.replace.all\"\n  });\n  return true;\n});\n\nfunction createSearchPanel(view) {\n  return view.state.facet(searchConfigFacet).createPanel(view);\n}\n\nfunction defaultQuery(state, fallback) {\n  var _a, _b, _c, _d, _e;\n\n  var sel = state.selection.main;\n  var selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n  if (fallback && !selText) return fallback;\n  var config = state.facet(searchConfigFacet);\n  return new SearchQuery({\n    search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n    regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n    wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n  });\n}\n\nfunction getSearchInput(view) {\n  var panel = getPanel(view, createSearchPanel);\n  return panel && panel.dom.querySelector(\"[main-field]\");\n}\n\nfunction selectSearchInput(view) {\n  var input = getSearchInput(view);\n  if (input && input == view.root.activeElement) input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/\n\n\nvar openSearchPanel = function openSearchPanel(view) {\n  var state = view.state.field(searchState, false);\n\n  if (state && state.panel) {\n    var searchInput = getSearchInput(view);\n\n    if (searchInput && searchInput != view.root.activeElement) {\n      var query = defaultQuery(view.state, state.query.spec);\n      if (query.valid) view.dispatch({\n        effects: setSearchQuery.of(query)\n      });\n      searchInput.focus();\n      searchInput.select();\n    }\n  } else {\n    view.dispatch({\n      effects: [togglePanel.of(true), state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)]\n    });\n  }\n\n  return true;\n};\n/**\nClose the search panel.\n*/\n\n\nvar closeSearchPanel = function closeSearchPanel(view) {\n  var state = view.state.field(searchState, false);\n  if (!state || !state.panel) return false;\n  var panel = getPanel(view, createSearchPanel);\n  if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n  view.dispatch({\n    effects: togglePanel.of(false)\n  });\n  return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\n\n\nvar searchKeymap = [{\n  key: \"Mod-f\",\n  run: openSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"F3\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\",\n  preventDefault: true\n}, {\n  key: \"Mod-g\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\",\n  preventDefault: true\n}, {\n  key: \"Escape\",\n  run: closeSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-Shift-l\",\n  run: selectSelectionMatches\n}, {\n  key: \"Mod-Alt-g\",\n  run: gotoLine\n}, {\n  key: \"Mod-d\",\n  run: selectNextOccurrence,\n  preventDefault: true\n}];\n\nvar SearchPanel = /*#__PURE__*/function () {\n  function SearchPanel(view) {\n    var _this = this;\n\n    _classCallCheck(this, SearchPanel);\n\n    this.view = view;\n    var query = this.query = view.state.field(searchState).query.spec;\n    this.commit = this.commit.bind(this);\n    this.searchField = elt(\"input\", {\n      value: query.search,\n      placeholder: phrase(view, \"Find\"),\n      \"aria-label\": phrase(view, \"Find\"),\n      class: \"cm-textfield\",\n      name: \"search\",\n      form: \"\",\n      \"main-field\": \"true\",\n      onchange: this.commit,\n      onkeyup: this.commit\n    });\n    this.replaceField = elt(\"input\", {\n      value: query.replace,\n      placeholder: phrase(view, \"Replace\"),\n      \"aria-label\": phrase(view, \"Replace\"),\n      class: \"cm-textfield\",\n      name: \"replace\",\n      form: \"\",\n      onchange: this.commit,\n      onkeyup: this.commit\n    });\n    this.caseField = elt(\"input\", {\n      type: \"checkbox\",\n      name: \"case\",\n      form: \"\",\n      checked: query.caseSensitive,\n      onchange: this.commit\n    });\n    this.reField = elt(\"input\", {\n      type: \"checkbox\",\n      name: \"re\",\n      form: \"\",\n      checked: query.regexp,\n      onchange: this.commit\n    });\n    this.wordField = elt(\"input\", {\n      type: \"checkbox\",\n      name: \"word\",\n      form: \"\",\n      checked: query.wholeWord,\n      onchange: this.commit\n    });\n\n    function button(name, onclick, content) {\n      return elt(\"button\", {\n        class: \"cm-button\",\n        name: name,\n        onclick: onclick,\n        type: \"button\"\n      }, content);\n    }\n\n    this.dom = elt(\"div\", {\n      onkeydown: function onkeydown(e) {\n        return _this.keydown(e);\n      },\n      class: \"cm-search\"\n    }, [this.searchField, button(\"next\", function () {\n      return findNext(view);\n    }, [phrase(view, \"next\")]), button(\"prev\", function () {\n      return findPrevious(view);\n    }, [phrase(view, \"previous\")]), button(\"select\", function () {\n      return selectMatches(view);\n    }, [phrase(view, \"all\")]), elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]), elt(\"label\", null, [this.reField, phrase(view, \"regexp\")]), elt(\"label\", null, [this.wordField, phrase(view, \"by word\")])].concat(_toConsumableArray(view.state.readOnly ? [] : [elt(\"br\"), this.replaceField, button(\"replace\", function () {\n      return replaceNext(view);\n    }, [phrase(view, \"replace\")]), button(\"replaceAll\", function () {\n      return replaceAll(view);\n    }, [phrase(view, \"replace all\")])]), [elt(\"button\", {\n      name: \"close\",\n      onclick: function onclick() {\n        return closeSearchPanel(view);\n      },\n      \"aria-label\": phrase(view, \"close\"),\n      type: \"button\"\n    }, [\"\"])]));\n  }\n\n  _createClass(SearchPanel, [{\n    key: \"commit\",\n    value: function commit() {\n      var query = new SearchQuery({\n        search: this.searchField.value,\n        caseSensitive: this.caseField.checked,\n        regexp: this.reField.checked,\n        wholeWord: this.wordField.checked,\n        replace: this.replaceField.value\n      });\n\n      if (!query.eq(this.query)) {\n        this.query = query;\n        this.view.dispatch({\n          effects: setSearchQuery.of(query)\n        });\n      }\n    }\n  }, {\n    key: \"keydown\",\n    value: function keydown(e) {\n      if (runScopeHandlers(this.view, e, \"search-panel\")) {\n        e.preventDefault();\n      } else if (e.keyCode == 13 && e.target == this.searchField) {\n        e.preventDefault();\n        (e.shiftKey ? findPrevious : findNext)(this.view);\n      } else if (e.keyCode == 13 && e.target == this.replaceField) {\n        e.preventDefault();\n        replaceNext(this.view);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update3) {\n      var _iterator4 = _createForOfIteratorHelper(_update3.transactions),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var tr = _step4.value;\n\n          var _iterator5 = _createForOfIteratorHelper(tr.effects),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var effect = _step5.value;\n              if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"setQuery\",\n    value: function setQuery(query) {\n      this.query = query;\n      this.searchField.value = query.search;\n      this.replaceField.value = query.replace;\n      this.caseField.checked = query.caseSensitive;\n      this.reField.checked = query.regexp;\n      this.wordField.checked = query.wholeWord;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount() {\n      this.searchField.select();\n    }\n  }, {\n    key: \"pos\",\n    get: function get() {\n      return 80;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.view.state.facet(searchConfigFacet).top;\n    }\n  }]);\n\n  return SearchPanel;\n}();\n\nfunction phrase(view, phrase) {\n  return view.state.phrase(phrase);\n}\n\nvar AnnounceMargin = 30;\nvar Break = /[\\s\\.,:;?!]/;\n\nfunction announceMatch(view, _ref10) {\n  var from = _ref10.from,\n      to = _ref10.to;\n  var line = view.state.doc.lineAt(from),\n      lineEnd = view.state.doc.lineAt(to).to;\n  var start = Math.max(line.from, from - AnnounceMargin),\n      end = Math.min(lineEnd, to + AnnounceMargin);\n  var text = view.state.sliceDoc(start, end);\n\n  if (start != line.from) {\n    for (var i = 0; i < AnnounceMargin; i++) {\n      if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n        text = text.slice(i);\n        break;\n      }\n    }\n  }\n\n  if (end != lineEnd) {\n    for (var _i = text.length - 1; _i > text.length - AnnounceMargin; _i--) {\n      if (!Break.test(text[_i - 1]) && Break.test(text[_i])) {\n        text = text.slice(0, _i);\n        break;\n      }\n    }\n  }\n\n  return EditorView.announce.of(\"\".concat(view.state.phrase(\"current match\"), \". \").concat(text, \" \").concat(view.state.phrase(\"on line\"), \" \").concat(line.number, \".\"));\n}\n\nvar baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-panel.cm-search\": {\n    padding: \"2px 6px 4px\",\n    position: \"relative\",\n    \"& [name=close]\": {\n      position: \"absolute\",\n      top: \"0\",\n      right: \"4px\",\n      backgroundColor: \"inherit\",\n      border: \"none\",\n      font: \"inherit\",\n      padding: 0,\n      margin: 0\n    },\n    \"& input, & button, & label\": {\n      margin: \".2em .6em .2em 0\"\n    },\n    \"& input[type=checkbox]\": {\n      marginRight: \".2em\"\n    },\n    \"& label\": {\n      fontSize: \"80%\",\n      whiteSpace: \"pre\"\n    }\n  },\n  \"&light .cm-searchMatch\": {\n    backgroundColor: \"#ffff0054\"\n  },\n  \"&dark .cm-searchMatch\": {\n    backgroundColor: \"#00ffff8a\"\n  },\n  \"&light .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff6a0054\"\n  },\n  \"&dark .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff00ff8a\"\n  }\n});\nvar searchExtensions = [searchState, /*@__PURE__*/Prec.low(searchHighlighter), baseTheme];\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };","map":{"version":3,"sources":["/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/@codemirror/search/dist/index.js"],"names":["showPanel","EditorView","getPanel","Decoration","ViewPlugin","runScopeHandlers","codePointAt","fromCodePoint","codePointSize","StateEffect","StateField","EditorSelection","Facet","combineConfig","CharCategory","RangeSetBuilder","Prec","EditorState","findClusterBreak","elt","basicNormalize","String","prototype","normalize","x","SearchCursor","text","query","from","to","length","test","value","done","matches","buffer","bufferPos","iter","iterRange","bufferStart","next","pop","nextOverlapping","peek","str","start","norm","i","pos","code","charCodeAt","match","end","index","keep","splice","push","Symbol","iterator","empty","exec","baseFlags","unicode","RegExpCursor","options","curLine","MultilineRegExpCursor","re","RegExp","ignoreCase","startLine","lineAt","curLineStart","matchPos","toCharEnd","getLine","skip","lineBreak","slice","off","lastIndex","nextLine","flattened","WeakMap","FlattenedDoc","doc","cached","get","flat","sliceString","set","cachedFrom","chunkEnd","validRegExp","source","_a","line","createLineDialog","view","state","selection","main","head","number","input","class","name","dom","onkeydown","event","keyCode","preventDefault","dispatch","effects","dialogEffect","of","focus","go","onsubmit","phrase","type","sign","ln","cl","percent","col","pc","lines","Math","round","docLine","max","min","cursor","scrollIntoView","y","define","dialogField","create","update","tr","e","is","provide","f","val","gotoLine","panel","field","appendConfig","baseTheme$1","querySelector","select","baseTheme","padding","fontSize","defaultHighlightOptions","highlightWordAroundCursor","minSelectionLength","maxMatches","wholeWords","highlightConfig","combine","a","b","highlightSelectionMatches","ext","defaultTheme","matchHighlighter","matchDeco","mark","mainMatchDeco","insideWordBoundaries","check","sliceDoc","Word","insideWord","fromClass","decorations","getDeco","selectionSet","docChanged","viewportChanged","conf","facet","sel","ranges","none","range","word","wordAt","charCategorizer","len","deco","visibleRanges","part","v","backgroundColor","selectWord","newSel","map","mainIndex","eq","findNextOccurrence","fullWord","cycled","some","r","selectNextOccurrence","searchedText","addRange","searchConfigFacet","configs","top","caseSensitive","literal","regexp","wholeWord","createPanel","SearchPanel","scrollToMatch","search","config","searchExtensions","SearchQuery","replace","valid","unquoted","unquote","_","ch","other","RegExpQuery","StringQuery","st","regexpCursor","stringCursor","QueryType","spec","undefined","toLowerCase","stringWordTest","categorizer","buf","bufPos","charBefore","charAfter","curFrom","curTo","prevMatchInRange","_result","limit","add","regexpWordTest","_from","_to","size","result","m","setSearchQuery","togglePanel","searchState","SearchState","defaultQuery","effect","createSearchPanel","getSearchQuery","curState","searchPanelOpen","matchMark","selectedMatchMark","searchHighlighter","highlight","startState","builder","l","selected","finish","searchCommand","openSearchPanel","findNext","nextMatch","single","announceMatch","userEvent","selectSearchInput","findPrevious","prev","prevMatch","selectMatches","matchAll","selectSelectionMatches","cur","replaceNext","readOnly","changes","replacement","toText","getReplacement","insert","announce","replaceAll","announceText","fallback","_b","_c","_d","_e","selText","getSearchInput","root","activeElement","searchInput","closeSearchPanel","contains","searchKeymap","key","run","scope","shift","commit","bind","searchField","placeholder","form","onchange","onkeyup","replaceField","caseField","checked","reField","wordField","button","onclick","content","keydown","target","shiftKey","transactions","setQuery","AnnounceMargin","Break","lineEnd","position","right","border","font","margin","marginRight","whiteSpace","low"],"mappings":"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","sourcesContent":["import { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec, EditorState, findClusterBreak } from '@codemirror/state';\nimport elt from 'crelt';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize, test) {\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: end };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: end };\n            else\n                this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))\n            match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\")\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length)\n                    this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&\n                    (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\n        function () { return this; };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length)\n        return pos;\n    let line = text.lineAt(pos), next;\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\n        pos++;\n    return pos;\n}\n\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\", value: line });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: 'center' })],\n            selection,\n        });\n        view.focus();\n    }\n    return { dom };\n}\nconst dialogEffect = /*@__PURE__*/StateEffect.define();\nconst dialogField = /*@__PURE__*/StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word\n        && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) &&\n                    insideWord(check, state, range.from, range.to)))\n                    return Decoration.none;\n            }\n            else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query)\n                    return Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n        effects: EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: view => new SearchPanel(view),\n            scrollToMatch: range => EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n    /**\n    Create a query object.\n    */\n    constructor(config) {\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */\n    unquote(text) {\n        return this.literal ? text :\n            text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&\n            this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */\n    create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */\n    getCursor(state, from = 0, to) {\n        let st = state.doc ? state : EditorState.create({ doc: state });\n        if (to == null)\n            to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec) {\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos) => {\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||\n            categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &&\n            (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||\n                categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec) {\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done)\n            cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* FindPrev.ChunkSize */;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice(findClusterBreak(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, findClusterBreak(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match) => !match[0].length ||\n        (categorizer(charBefore(match.input, match.index)) != CharCategory.Word ||\n            categorizer(charAfter(match.input, match.index)) != CharCategory.Word) &&\n            (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word ||\n                categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done)\n            cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m);\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setSearchQuery))\n                value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next)\n        return false;\n    let selection = EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev)\n        return false;\n    let selection = EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let next = query.nextMatch(state, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes, selection, effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText)\n        return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = getPanel(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement)\n        input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid)\n                view.dispatch({ effects: setSearchQuery.of(query) });\n            searchInput.focus();\n            searchInput.select();\n        }\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Mod-Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nclass SearchPanel {\n    constructor(view) {\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = elt(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = elt(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return elt(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n        }\n        this.dom = elt(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\n            this.searchField,\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\n            elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\n            elt(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\n            elt(\"label\", null, [this.wordField, phrase(view, \"by word\")]),\n            ...view.state.readOnly ? [] : [\n                elt(\"br\"),\n                this.replaceField,\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])\n            ],\n            elt(\"button\", {\n                name: \"close\",\n                onclick: () => closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\"\"])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value,\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\n        }\n    }\n    keydown(e) {\n        if (runScopeHandlers(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        }\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)\n            for (let effect of tr.effects) {\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\n                    this.setQuery(effect.value);\n            }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() { return 80; }\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\n}\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/Prec.low(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };\n"]},"metadata":{},"sourceType":"module"}