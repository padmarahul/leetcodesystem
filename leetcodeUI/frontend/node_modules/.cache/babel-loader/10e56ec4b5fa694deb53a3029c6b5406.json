{"ast":null,"code":"import _classCallCheck from \"/Users/sairahulpadma/Desktop/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sairahulpadma/Desktop/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _createForOfIteratorHelper from \"/Users/sairahulpadma/Desktop/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { Annotation, Facet, combineConfig, StateField, Transaction, ChangeSet, ChangeDesc, EditorSelection, StateEffect, Text, findClusterBreak, countColumn, CharCategory } from '@codemirror/state';\nimport { EditorView, Direction } from '@codemirror/view';\nimport { IndentContext, getIndentation, indentString, matchBrackets, syntaxTree, getIndentUnit, indentUnit } from '@codemirror/language';\nimport { NodeProp } from '@lezer/common';\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\n\nvar toggleComment = function toggleComment(target) {\n  var state = target.state,\n      line = state.doc.lineAt(state.selection.main.from),\n      config = getConfig(target.state, line.from);\n  return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\n\nfunction command(f, option) {\n  return function (_ref) {\n    var state = _ref.state,\n        dispatch = _ref.dispatch;\n    if (state.readOnly) return false;\n    var tr = f(option, state);\n    if (!tr) return false;\n    dispatch(state.update(tr));\n    return true;\n  };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\n\n\nvar toggleLineComment = /*@__PURE__*/command(changeLineComment, 0\n/* CommentOption.Toggle */\n);\n/**\nComment the current selection using line comments.\n*/\n\nvar lineComment = /*@__PURE__*/command(changeLineComment, 1\n/* CommentOption.Comment */\n);\n/**\nUncomment the current selection using line comments.\n*/\n\nvar lineUncomment = /*@__PURE__*/command(changeLineComment, 2\n/* CommentOption.Uncomment */\n);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\n\nvar toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0\n/* CommentOption.Toggle */\n);\n/**\nComment the current selection using block comments.\n*/\n\nvar blockComment = /*@__PURE__*/command(changeBlockComment, 1\n/* CommentOption.Comment */\n);\n/**\nUncomment the current selection using block comments.\n*/\n\nvar blockUncomment = /*@__PURE__*/command(changeBlockComment, 2\n/* CommentOption.Uncomment */\n);\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/\n\nvar toggleBlockCommentByLine = /*@__PURE__*/command(function (o, s) {\n  return changeBlockComment(o, s, selectedLineRanges(s));\n}, 0\n/* CommentOption.Toggle */\n);\n\nfunction getConfig(state, pos) {\n  var data = state.languageDataAt(\"commentTokens\", pos);\n  return data.length ? data[0] : {};\n}\n\nvar SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\n\nfunction findBlockComment(state, _ref2, from, to) {\n  var open = _ref2.open,\n      close = _ref2.close;\n  var textBefore = state.sliceDoc(from - SearchMargin, from);\n  var textAfter = state.sliceDoc(to, to + SearchMargin);\n  var spaceBefore = /\\s*$/.exec(textBefore)[0].length,\n      spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n  var beforeOff = textBefore.length - spaceBefore;\n\n  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n    return {\n      open: {\n        pos: from - spaceBefore,\n        margin: spaceBefore && 1\n      },\n      close: {\n        pos: to + spaceAfter,\n        margin: spaceAfter && 1\n      }\n    };\n  }\n\n  var startText, endText;\n\n  if (to - from <= 2 * SearchMargin) {\n    startText = endText = state.sliceDoc(from, to);\n  } else {\n    startText = state.sliceDoc(from, from + SearchMargin);\n    endText = state.sliceDoc(to - SearchMargin, to);\n  }\n\n  var startSpace = /^\\s*/.exec(startText)[0].length,\n      endSpace = /\\s*$/.exec(endText)[0].length;\n  var endOff = endText.length - endSpace - close.length;\n\n  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n    return {\n      open: {\n        pos: from + startSpace + open.length,\n        margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n      },\n      close: {\n        pos: to - endSpace - close.length,\n        margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n      }\n    };\n  }\n\n  return null;\n}\n\nfunction selectedLineRanges(state) {\n  var ranges = [];\n\n  var _iterator = _createForOfIteratorHelper(state.selection.ranges),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var r = _step.value;\n      var fromLine = state.doc.lineAt(r.from);\n      var toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n      if (toLine.from > fromLine.from && toLine.from == r.to) toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);\n      var last = ranges.length - 1;\n      if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;else ranges.push({\n        from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length,\n        to: toLine.to\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return ranges;\n} // Performs toggle, comment and uncomment of block comments in\n// languages that support them.\n\n\nfunction changeBlockComment(option, state) {\n  var ranges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : state.selection.ranges;\n  var tokens = ranges.map(function (r) {\n    return getConfig(state, r.from).block;\n  });\n  if (!tokens.every(function (c) {\n    return c;\n  })) return null;\n  var comments = ranges.map(function (r, i) {\n    return findBlockComment(state, tokens[i], r.from, r.to);\n  });\n\n  if (option != 2\n  /* CommentOption.Uncomment */\n  && !comments.every(function (c) {\n    return c;\n  })) {\n    return {\n      changes: state.changes(ranges.map(function (range, i) {\n        if (comments[i]) return [];\n        return [{\n          from: range.from,\n          insert: tokens[i].open + \" \"\n        }, {\n          from: range.to,\n          insert: \" \" + tokens[i].close\n        }];\n      }))\n    };\n  } else if (option != 1\n  /* CommentOption.Comment */\n  && comments.some(function (c) {\n    return c;\n  })) {\n    var changes = [];\n\n    for (var i = 0, comment; i < comments.length; i++) {\n      if (comment = comments[i]) {\n        var token = tokens[i],\n            _comment = comment,\n            open = _comment.open,\n            close = _comment.close;\n        changes.push({\n          from: open.pos - token.open.length,\n          to: open.pos + open.margin\n        }, {\n          from: close.pos - close.margin,\n          to: close.pos + token.close.length\n        });\n      }\n    }\n\n    return {\n      changes: changes\n    };\n  }\n\n  return null;\n} // Performs toggle, comment and uncomment of line comments.\n\n\nfunction changeLineComment(option, state) {\n  var ranges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : state.selection.ranges;\n  var lines = [];\n  var prevLine = -1;\n\n  var _iterator2 = _createForOfIteratorHelper(ranges),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _step2.value,\n          _from = _step2$value.from,\n          _to = _step2$value.to;\n      var startI = lines.length,\n          minIndent = 1e9;\n      var _token2 = getConfig(state, _from).line;\n      if (!_token2) continue;\n\n      for (var pos = _from; pos <= _to;) {\n        var _line2 = state.doc.lineAt(pos);\n\n        if (_line2.from > prevLine && (_from == _to || _to > _line2.from)) {\n          prevLine = _line2.from;\n          var _indent = /^\\s*/.exec(_line2.text)[0].length;\n\n          var _empty = _indent == _line2.length;\n\n          var _comment2 = _line2.text.slice(_indent, _indent + _token2.length) == _token2 ? _indent : -1;\n\n          if (_indent < _line2.text.length && _indent < minIndent) minIndent = _indent;\n          lines.push({\n            line: _line2,\n            comment: _comment2,\n            token: _token2,\n            indent: _indent,\n            empty: _empty,\n            single: false\n          });\n        }\n\n        pos = _line2.to + 1;\n      }\n\n      if (minIndent < 1e9) for (var i = startI; i < lines.length; i++) {\n        if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n      }\n      if (lines.length == startI + 1) lines[startI].single = true;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (option != 2\n  /* CommentOption.Uncomment */\n  && lines.some(function (l) {\n    return l.comment < 0 && (!l.empty || l.single);\n  })) {\n    var changes = [];\n\n    var _iterator3 = _createForOfIteratorHelper(lines),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _step3.value,\n            line = _step3$value.line,\n            token = _step3$value.token,\n            indent = _step3$value.indent,\n            empty = _step3$value.empty,\n            single = _step3$value.single;\n        if (single || !empty) changes.push({\n          from: line.from + indent,\n          insert: token + \" \"\n        });\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var changeSet = state.changes(changes);\n    return {\n      changes: changeSet,\n      selection: state.selection.map(changeSet, 1)\n    };\n  } else if (option != 1\n  /* CommentOption.Comment */\n  && lines.some(function (l) {\n    return l.comment >= 0;\n  })) {\n    var _changes = [];\n\n    var _iterator4 = _createForOfIteratorHelper(lines),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _step4$value = _step4.value,\n            _line = _step4$value.line,\n            comment = _step4$value.comment,\n            _token = _step4$value.token;\n\n        if (comment >= 0) {\n          var from = _line.from + comment,\n              to = from + _token.length;\n          if (_line.text[to - _line.from] == \" \") to++;\n\n          _changes.push({\n            from: from,\n            to: to\n          });\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return {\n      changes: _changes\n    };\n  }\n\n  return null;\n}\n\nvar fromHistory = /*@__PURE__*/Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\n\nvar isolateHistory = /*@__PURE__*/Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\n\nvar invertedEffects = /*@__PURE__*/Facet.define();\nvar historyConfig = /*@__PURE__*/Facet.define({\n  combine: function combine(configs) {\n    return combineConfig(configs, {\n      minDepth: 100,\n      newGroupDelay: 500,\n      joinToEvent: function joinToEvent(_t, isAdjacent) {\n        return isAdjacent;\n      }\n    }, {\n      minDepth: Math.max,\n      newGroupDelay: Math.min,\n      joinToEvent: function joinToEvent(a, b) {\n        return function (tr, adj) {\n          return a(tr, adj) || b(tr, adj);\n        };\n      }\n    });\n  }\n});\nvar historyField_ = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return HistoryState.empty;\n  },\n  update: function update(state, tr) {\n    var config = tr.state.facet(historyConfig);\n    var fromHist = tr.annotation(fromHistory);\n\n    if (fromHist) {\n      var item = HistEvent.fromTransaction(tr, fromHist.selection),\n          from = fromHist.side;\n      var other = from == 0\n      /* BranchName.Done */\n      ? state.undone : state.done;\n      if (item) other = updateBranch(other, other.length, config.minDepth, item);else other = _addSelection(other, tr.startState.selection);\n      return new HistoryState(from == 0\n      /* BranchName.Done */\n      ? fromHist.rest : other, from == 0\n      /* BranchName.Done */\n      ? other : fromHist.rest);\n    }\n\n    var isolate = tr.annotation(isolateHistory);\n    if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n    if (tr.annotation(Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n    var event = HistEvent.fromTransaction(tr);\n    var time = tr.annotation(Transaction.time),\n        userEvent = tr.annotation(Transaction.userEvent);\n    if (event) state = state.addChanges(event, time, userEvent, config, tr);else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n    if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n    return state;\n  },\n  toJSON: function toJSON(value) {\n    return {\n      done: value.done.map(function (e) {\n        return e.toJSON();\n      }),\n      undone: value.undone.map(function (e) {\n        return e.toJSON();\n      })\n    };\n  },\n  fromJSON: function fromJSON(json) {\n    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n  }\n});\n/**\nCreate a history extension with the given configuration.\n*/\n\nfunction history() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [historyField_, historyConfig.of(config), EditorView.domEventHandlers({\n    beforeinput: function beforeinput(e, view) {\n      var command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n      if (!command) return false;\n      e.preventDefault();\n      return command(view);\n    }\n  })];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\n\n\nvar historyField = historyField_;\n\nfunction cmd(side, selection) {\n  return function (_ref3) {\n    var state = _ref3.state,\n        dispatch = _ref3.dispatch;\n    if (!selection && state.readOnly) return false;\n    var historyState = state.field(historyField_, false);\n    if (!historyState) return false;\n    var tr = historyState.pop(side, state, selection);\n    if (!tr) return false;\n    dispatch(tr);\n    return true;\n  };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\n\n\nvar undo = /*@__PURE__*/cmd(0\n/* BranchName.Done */\n, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\n\nvar redo = /*@__PURE__*/cmd(1\n/* BranchName.Undone */\n, false);\n/**\nUndo a change or selection change.\n*/\n\nvar undoSelection = /*@__PURE__*/cmd(0\n/* BranchName.Done */\n, true);\n/**\nRedo a change or selection change.\n*/\n\nvar redoSelection = /*@__PURE__*/cmd(1\n/* BranchName.Undone */\n, true);\n\nfunction depth(side) {\n  return function (state) {\n    var histState = state.field(historyField_, false);\n    if (!histState) return 0;\n    var branch = side == 0\n    /* BranchName.Done */\n    ? histState.done : histState.undone;\n    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n  };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\n\n\nvar undoDepth = /*@__PURE__*/depth(0\n/* BranchName.Done */\n);\n/**\nThe amount of redoable change events available in a given state.\n*/\n\nvar redoDepth = /*@__PURE__*/depth(1\n/* BranchName.Undone */\n); // History events store groups of changes or effects that need to be\n// undone/redone together.\n\nvar HistEvent = /*#__PURE__*/function () {\n  function HistEvent( // The changes in this event. Normal events hold at least one\n  // change or effect. But it may be necessary to store selection\n  // events before the first change, in which case a special type of\n  // instance is created which doesn't hold any changes, with\n  // changes == startSelection == undefined\n  changes, // The effects associated with this event\n  effects, // Accumulated mapping (from addToHistory==false) that should be\n  // applied to events below this one.\n  mapped, // The selection before this event\n  startSelection, // Stores selection changes after this event, to be used for\n  // selection undo/redo.\n  selectionsAfter) {\n    _classCallCheck(this, HistEvent);\n\n    this.changes = changes;\n    this.effects = effects;\n    this.mapped = mapped;\n    this.startSelection = startSelection;\n    this.selectionsAfter = selectionsAfter;\n  }\n\n  _createClass(HistEvent, [{\n    key: \"setSelAfter\",\n    value: function setSelAfter(after) {\n      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _a, _b, _c;\n\n      return {\n        changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n        selectionsAfter: this.selectionsAfter.map(function (s) {\n          return s.toJSON();\n        })\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));\n    } // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n\n  }, {\n    key: \"fromTransaction\",\n    value: function fromTransaction(tr, selection) {\n      var effects = none;\n\n      var _iterator5 = _createForOfIteratorHelper(tr.startState.facet(invertedEffects)),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var invert = _step5.value;\n          var result = invert(tr);\n          if (result.length) effects = effects.concat(result);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      if (!effects.length && tr.changes.empty) return null;\n      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n  }, {\n    key: \"selection\",\n    value: function selection(selections) {\n      return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n  }]);\n\n  return HistEvent;\n}();\n\nfunction updateBranch(branch, to, maxLen, newEvent) {\n  var start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n  var newBranch = branch.slice(start, to);\n  newBranch.push(newEvent);\n  return newBranch;\n}\n\nfunction isAdjacent(a, b) {\n  var ranges = [],\n      isAdjacent = false;\n  a.iterChangedRanges(function (f, t) {\n    return ranges.push(f, t);\n  });\n  b.iterChangedRanges(function (_f, _t, f, t) {\n    for (var i = 0; i < ranges.length;) {\n      var from = ranges[i++],\n          to = ranges[i++];\n      if (t >= from && f <= to) isAdjacent = true;\n    }\n  });\n  return isAdjacent;\n}\n\nfunction eqSelectionShape(a, b) {\n  return a.ranges.length == b.ranges.length && a.ranges.filter(function (r, i) {\n    return r.empty != b.ranges[i].empty;\n  }).length === 0;\n}\n\nfunction conc(a, b) {\n  return !a.length ? b : !b.length ? a : a.concat(b);\n}\n\nvar none = [];\nvar MaxSelectionsPerEvent = 200;\n\nfunction _addSelection(branch, selection) {\n  if (!branch.length) {\n    return [HistEvent.selection([selection])];\n  } else {\n    var lastEvent = branch[branch.length - 1];\n    var sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n    if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n    sels.push(selection);\n    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n  }\n} // Assumes the top item has one or more selectionAfter values\n\n\nfunction popSelection(branch) {\n  var last = branch[branch.length - 1];\n  var newBranch = branch.slice();\n  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n  return newBranch;\n} // Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\n\n\nfunction addMappingToBranch(branch, mapping) {\n  if (!branch.length) return branch;\n  var length = branch.length,\n      selections = none;\n\n  while (length) {\n    var event = mapEvent(branch[length - 1], mapping, selections);\n\n    if (event.changes && !event.changes.empty || event.effects.length) {\n      // Event survived mapping\n      var result = branch.slice(0, length);\n      result[length - 1] = event;\n      return result;\n    } else {\n      // Drop this event, since there's no changes or effects left\n      mapping = event.mapped;\n      length--;\n      selections = event.selectionsAfter;\n    }\n  }\n\n  return selections.length ? [HistEvent.selection(selections)] : none;\n}\n\nfunction mapEvent(event, mapping, extraSelections) {\n  var selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(function (s) {\n    return s.map(mapping);\n  }) : none, extraSelections); // Change-less events don't store mappings (they are always the last event in a branch)\n\n  if (!event.changes) return HistEvent.selection(selections);\n  var mappedChanges = event.changes.map(mapping),\n      before = mapping.mapDesc(event.changes, true);\n  var fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\n\nvar joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\n\nvar HistoryState = /*#__PURE__*/function () {\n  function HistoryState(done, undone) {\n    var prevTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var prevUserEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n    _classCallCheck(this, HistoryState);\n\n    this.done = done;\n    this.undone = undone;\n    this.prevTime = prevTime;\n    this.prevUserEvent = prevUserEvent;\n  }\n\n  _createClass(HistoryState, [{\n    key: \"isolate\",\n    value: function isolate() {\n      return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n  }, {\n    key: \"addChanges\",\n    value: function addChanges(event, time, userEvent, config, tr) {\n      var done = this.done,\n          lastEvent = done[done.length - 1];\n\n      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event\n      userEvent == \"input.type.compose\")) {\n        done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n      } else {\n        done = updateBranch(done, done.length, config.minDepth, event);\n      }\n\n      return new HistoryState(done, none, time, userEvent);\n    }\n  }, {\n    key: \"addSelection\",\n    value: function addSelection(selection, time, userEvent, newGroupDelay) {\n      var last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n      if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n      return new HistoryState(_addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n  }, {\n    key: \"addMapping\",\n    value: function addMapping(mapping) {\n      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(side, state, onlySelection) {\n      var branch = side == 0\n      /* BranchName.Done */\n      ? this.done : this.undone;\n      if (branch.length == 0) return null;\n      var event = branch[branch.length - 1],\n          selection = event.selectionsAfter[0] || state.selection;\n\n      if (onlySelection && event.selectionsAfter.length) {\n        return state.update({\n          selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n          annotations: fromHistory.of({\n            side: side,\n            rest: popSelection(branch),\n            selection: selection\n          }),\n          userEvent: side == 0\n          /* BranchName.Done */\n          ? \"select.undo\" : \"select.redo\",\n          scrollIntoView: true\n        });\n      } else if (!event.changes) {\n        return null;\n      } else {\n        var rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n        if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n        return state.update({\n          changes: event.changes,\n          selection: event.startSelection,\n          effects: event.effects,\n          annotations: fromHistory.of({\n            side: side,\n            rest: rest,\n            selection: selection\n          }),\n          filter: false,\n          userEvent: side == 0\n          /* BranchName.Done */\n          ? \"undo\" : \"redo\",\n          scrollIntoView: true\n        });\n      }\n    }\n  }]);\n\n  return HistoryState;\n}();\n\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/\n\nvar historyKeymap = [{\n  key: \"Mod-z\",\n  run: undo,\n  preventDefault: true\n}, {\n  key: \"Mod-y\",\n  mac: \"Mod-Shift-z\",\n  run: redo,\n  preventDefault: true\n}, {\n  linux: \"Ctrl-Shift-z\",\n  run: redo,\n  preventDefault: true\n}, {\n  key: \"Mod-u\",\n  run: undoSelection,\n  preventDefault: true\n}, {\n  key: \"Alt-u\",\n  mac: \"Mod-Shift-u\",\n  run: redoSelection,\n  preventDefault: true\n}];\n\nfunction updateSel(sel, by) {\n  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\n\nfunction setSel(state, selection) {\n  return state.update({\n    selection: selection,\n    scrollIntoView: true,\n    userEvent: \"select\"\n  });\n}\n\nfunction moveSel(_ref4, how) {\n  var state = _ref4.state,\n      dispatch = _ref4.dispatch;\n  var selection = updateSel(state.selection, how);\n  if (selection.eq(state.selection, true)) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\n\nfunction rangeEnd(range, forward) {\n  return EditorSelection.cursor(forward ? range.to : range.from);\n}\n\nfunction cursorByChar(view, forward) {\n  return moveSel(view, function (range) {\n    return range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward);\n  });\n}\n\nfunction ltrAtCursor(view) {\n  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\n\n\nvar cursorCharLeft = function cursorCharLeft(view) {\n  return cursorByChar(view, !ltrAtCursor(view));\n};\n/**\nMove the selection one character to the right.\n*/\n\n\nvar cursorCharRight = function cursorCharRight(view) {\n  return cursorByChar(view, ltrAtCursor(view));\n};\n/**\nMove the selection one character forward.\n*/\n\n\nvar cursorCharForward = function cursorCharForward(view) {\n  return cursorByChar(view, true);\n};\n/**\nMove the selection one character backward.\n*/\n\n\nvar cursorCharBackward = function cursorCharBackward(view) {\n  return cursorByChar(view, false);\n};\n\nfunction byCharLogical(state, range, forward) {\n  var pos = range.head,\n      line = state.doc.lineAt(pos);\n  if (pos == (forward ? line.to : line.from)) pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);else pos = line.from + findClusterBreak(line.text, pos - line.from, forward);\n  return EditorSelection.cursor(pos, forward ? -1 : 1);\n}\n\nfunction moveByCharLogical(target, forward) {\n  return moveSel(target, function (range) {\n    return range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward);\n  });\n}\n/**\nMove the selection one character forward, in logical\n(non-text-direction-aware) string index order.\n*/\n\n\nvar cursorCharForwardLogical = function cursorCharForwardLogical(target) {\n  return moveByCharLogical(target, true);\n};\n/**\nMove the selection one character backward, in logical string index\norder.\n*/\n\n\nvar cursorCharBackwardLogical = function cursorCharBackwardLogical(target) {\n  return moveByCharLogical(target, false);\n};\n\nfunction cursorByGroup(view, forward) {\n  return moveSel(view, function (range) {\n    return range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward);\n  });\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\n\n\nvar cursorGroupLeft = function cursorGroupLeft(view) {\n  return cursorByGroup(view, !ltrAtCursor(view));\n};\n/**\nMove the selection one group to the right.\n*/\n\n\nvar cursorGroupRight = function cursorGroupRight(view) {\n  return cursorByGroup(view, ltrAtCursor(view));\n};\n/**\nMove the selection one group forward.\n*/\n\n\nvar cursorGroupForward = function cursorGroupForward(view) {\n  return cursorByGroup(view, true);\n};\n/**\nMove the selection one group backward.\n*/\n\n\nvar cursorGroupBackward = function cursorGroupBackward(view) {\n  return cursorByGroup(view, false);\n};\n\nvar segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ? /*@__PURE__*/new Intl.Segmenter(undefined, {\n  granularity: \"word\"\n}) : null;\n\nfunction moveBySubword(view, range, forward) {\n  var categorize = view.state.charCategorizer(range.from);\n  var cat = CharCategory.Space,\n      pos = range.from,\n      steps = 0;\n  var done = false,\n      sawUpper = false,\n      sawLower = false;\n\n  var step = function step(next) {\n    if (done) return false;\n    pos += forward ? next.length : -next.length;\n    var nextCat = categorize(next),\n        ahead;\n    if (nextCat == CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next)) nextCat = -1; // Treat word punctuation specially\n\n    if (cat == CharCategory.Space) cat = nextCat;\n    if (cat != nextCat) return false;\n\n    if (cat == CharCategory.Word) {\n      if (next.toLowerCase() == next) {\n        if (!forward && sawUpper) return false;\n        sawLower = true;\n      } else if (sawLower) {\n        if (forward) return false;\n        done = true;\n      } else {\n        if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n        sawUpper = true;\n      }\n    }\n\n    steps++;\n    return true;\n  };\n\n  var end = view.moveByChar(range, forward, function (start) {\n    step(start);\n    return step;\n  });\n\n  if (segmenter && cat == CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n    var from = Math.min(range.head, end.head),\n        to = Math.max(range.head, end.head);\n    var skipped = view.state.sliceDoc(from, to);\n\n    if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n      var segments = Array.from(segmenter.segment(skipped));\n\n      if (segments.length > 1) {\n        if (forward) return EditorSelection.cursor(range.head + segments[1].index, -1);\n        return EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n      }\n    }\n  }\n\n  return end;\n}\n\nfunction cursorBySubword(view, forward) {\n  return moveSel(view, function (range) {\n    return range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward);\n  });\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\n\n\nvar cursorSubwordForward = function cursorSubwordForward(view) {\n  return cursorBySubword(view, true);\n};\n/**\nMove the selection one group or camel-case subword backward.\n*/\n\n\nvar cursorSubwordBackward = function cursorSubwordBackward(view) {\n  return cursorBySubword(view, false);\n};\n\nfunction interestingNode(state, node, bracketProp) {\n  if (node.type.prop(bracketProp)) return true;\n  var len = node.to - node.from;\n  return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\n\nfunction moveBySyntax(state, start, forward) {\n  var pos = syntaxTree(state).resolveInner(start.head);\n  var bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy; // Scan forward through child nodes to see if there's an interesting\n  // node ahead.\n\n  for (var at = start.head;;) {\n    var next = forward ? pos.childAfter(at) : pos.childBefore(at);\n    if (!next) break;\n    if (interestingNode(state, next, bracketProp)) pos = next;else at = forward ? next.to : next.from;\n  }\n\n  var bracket = pos.type.prop(bracketProp),\n      match,\n      newPos;\n  if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;else newPos = forward ? pos.to : pos.from;\n  return EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\n\n\nvar cursorSyntaxLeft = function cursorSyntaxLeft(view) {\n  return moveSel(view, function (range) {\n    return moveBySyntax(view.state, range, !ltrAtCursor(view));\n  });\n};\n/**\nMove the cursor over the next syntactic element to the right.\n*/\n\n\nvar cursorSyntaxRight = function cursorSyntaxRight(view) {\n  return moveSel(view, function (range) {\n    return moveBySyntax(view.state, range, ltrAtCursor(view));\n  });\n};\n\nfunction cursorByLine(view, forward) {\n  return moveSel(view, function (range) {\n    if (!range.empty) return rangeEnd(range, forward);\n    var moved = view.moveVertically(range, forward);\n    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n  });\n}\n/**\nMove the selection one line up.\n*/\n\n\nvar cursorLineUp = function cursorLineUp(view) {\n  return cursorByLine(view, false);\n};\n/**\nMove the selection one line down.\n*/\n\n\nvar cursorLineDown = function cursorLineDown(view) {\n  return cursorByLine(view, true);\n};\n\nfunction pageInfo(view) {\n  var selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n  var marginTop = 0,\n      marginBottom = 0,\n      height;\n\n  if (selfScroll) {\n    var _iterator6 = _createForOfIteratorHelper(view.state.facet(EditorView.scrollMargins)),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var source = _step6.value;\n        var margins = source(view);\n        if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n        if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n  } else {\n    height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n  }\n\n  return {\n    marginTop: marginTop,\n    marginBottom: marginBottom,\n    selfScroll: selfScroll,\n    height: Math.max(view.defaultLineHeight, height - 5)\n  };\n}\n\nfunction cursorByPage(view, forward) {\n  var page = pageInfo(view);\n  var state = view.state,\n      selection = updateSel(state.selection, function (range) {\n    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);\n  });\n  if (selection.eq(state.selection)) return false;\n  var effect;\n\n  if (page.selfScroll) {\n    var startPos = view.coordsAtPos(state.selection.main.head);\n    var scrollRect = view.scrollDOM.getBoundingClientRect();\n    var scrollTop = scrollRect.top + page.marginTop,\n        scrollBottom = scrollRect.bottom - page.marginBottom;\n    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = EditorView.scrollIntoView(selection.main.head, {\n      y: \"start\",\n      yMargin: startPos.top - scrollTop\n    });\n  }\n\n  view.dispatch(setSel(state, selection), {\n    effects: effect\n  });\n  return true;\n}\n/**\nMove the selection one page up.\n*/\n\n\nvar cursorPageUp = function cursorPageUp(view) {\n  return cursorByPage(view, false);\n};\n/**\nMove the selection one page down.\n*/\n\n\nvar cursorPageDown = function cursorPageDown(view) {\n  return cursorByPage(view, true);\n};\n\nfunction moveByLineBoundary(view, start, forward) {\n  var line = view.lineBlockAt(start.head),\n      moved = view.moveToLineBoundary(start, forward);\n  if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n\n  if (!forward && moved.head == line.from && line.length) {\n    var space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n    if (space && start.head != line.from + space) moved = EditorSelection.cursor(line.from + space);\n  }\n\n  return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\n\n\nvar cursorLineBoundaryForward = function cursorLineBoundaryForward(view) {\n  return moveSel(view, function (range) {\n    return moveByLineBoundary(view, range, true);\n  });\n};\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\n\n\nvar cursorLineBoundaryBackward = function cursorLineBoundaryBackward(view) {\n  return moveSel(view, function (range) {\n    return moveByLineBoundary(view, range, false);\n  });\n};\n/**\nMove the selection one line wrap point to the left.\n*/\n\n\nvar cursorLineBoundaryLeft = function cursorLineBoundaryLeft(view) {\n  return moveSel(view, function (range) {\n    return moveByLineBoundary(view, range, !ltrAtCursor(view));\n  });\n};\n/**\nMove the selection one line wrap point to the right.\n*/\n\n\nvar cursorLineBoundaryRight = function cursorLineBoundaryRight(view) {\n  return moveSel(view, function (range) {\n    return moveByLineBoundary(view, range, ltrAtCursor(view));\n  });\n};\n/**\nMove the selection to the start of the line.\n*/\n\n\nvar cursorLineStart = function cursorLineStart(view) {\n  return moveSel(view, function (range) {\n    return EditorSelection.cursor(view.lineBlockAt(range.head).from, 1);\n  });\n};\n/**\nMove the selection to the end of the line.\n*/\n\n\nvar cursorLineEnd = function cursorLineEnd(view) {\n  return moveSel(view, function (range) {\n    return EditorSelection.cursor(view.lineBlockAt(range.head).to, -1);\n  });\n};\n\nfunction toMatchingBracket(state, dispatch, extend) {\n  var found = false,\n      selection = updateSel(state.selection, function (range) {\n    var matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);\n    if (!matching || !matching.end) return range;\n    found = true;\n    var head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);\n  });\n  if (!found) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\n\n\nvar cursorMatchingBracket = function cursorMatchingBracket(_ref5) {\n  var state = _ref5.state,\n      dispatch = _ref5.dispatch;\n  return toMatchingBracket(state, dispatch, false);\n};\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\n\n\nvar selectMatchingBracket = function selectMatchingBracket(_ref6) {\n  var state = _ref6.state,\n      dispatch = _ref6.dispatch;\n  return toMatchingBracket(state, dispatch, true);\n};\n\nfunction extendSel(target, how) {\n  var selection = updateSel(target.state.selection, function (range) {\n    var head = how(range);\n    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n  });\n  if (selection.eq(target.state.selection)) return false;\n  target.dispatch(setSel(target.state, selection));\n  return true;\n}\n\nfunction selectByChar(view, forward) {\n  return extendSel(view, function (range) {\n    return view.moveByChar(range, forward);\n  });\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\n\n\nvar selectCharLeft = function selectCharLeft(view) {\n  return selectByChar(view, !ltrAtCursor(view));\n};\n/**\nMove the selection head one character to the right.\n*/\n\n\nvar selectCharRight = function selectCharRight(view) {\n  return selectByChar(view, ltrAtCursor(view));\n};\n/**\nMove the selection head one character forward.\n*/\n\n\nvar selectCharForward = function selectCharForward(view) {\n  return selectByChar(view, true);\n};\n/**\nMove the selection head one character backward.\n*/\n\n\nvar selectCharBackward = function selectCharBackward(view) {\n  return selectByChar(view, false);\n};\n/**\nMove the selection head one character forward by logical\n(non-direction aware) string index order.\n*/\n\n\nvar selectCharForwardLogical = function selectCharForwardLogical(target) {\n  return extendSel(target, function (range) {\n    return byCharLogical(target.state, range, true);\n  });\n};\n/**\nMove the selection head one character backward by logical string\nindex order.\n*/\n\n\nvar selectCharBackwardLogical = function selectCharBackwardLogical(target) {\n  return extendSel(target, function (range) {\n    return byCharLogical(target.state, range, false);\n  });\n};\n\nfunction selectByGroup(view, forward) {\n  return extendSel(view, function (range) {\n    return view.moveByGroup(range, forward);\n  });\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\n\n\nvar selectGroupLeft = function selectGroupLeft(view) {\n  return selectByGroup(view, !ltrAtCursor(view));\n};\n/**\nMove the selection head one group to the right.\n*/\n\n\nvar selectGroupRight = function selectGroupRight(view) {\n  return selectByGroup(view, ltrAtCursor(view));\n};\n/**\nMove the selection head one group forward.\n*/\n\n\nvar selectGroupForward = function selectGroupForward(view) {\n  return selectByGroup(view, true);\n};\n/**\nMove the selection head one group backward.\n*/\n\n\nvar selectGroupBackward = function selectGroupBackward(view) {\n  return selectByGroup(view, false);\n};\n\nfunction selectBySubword(view, forward) {\n  return extendSel(view, function (range) {\n    return moveBySubword(view, range, forward);\n  });\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\n\n\nvar selectSubwordForward = function selectSubwordForward(view) {\n  return selectBySubword(view, true);\n};\n/**\nMove the selection head one group or subword backward.\n*/\n\n\nvar selectSubwordBackward = function selectSubwordBackward(view) {\n  return selectBySubword(view, false);\n};\n/**\nMove the selection head over the next syntactic element to the left.\n*/\n\n\nvar selectSyntaxLeft = function selectSyntaxLeft(view) {\n  return extendSel(view, function (range) {\n    return moveBySyntax(view.state, range, !ltrAtCursor(view));\n  });\n};\n/**\nMove the selection head over the next syntactic element to the right.\n*/\n\n\nvar selectSyntaxRight = function selectSyntaxRight(view) {\n  return extendSel(view, function (range) {\n    return moveBySyntax(view.state, range, ltrAtCursor(view));\n  });\n};\n\nfunction selectByLine(view, forward) {\n  return extendSel(view, function (range) {\n    return view.moveVertically(range, forward);\n  });\n}\n/**\nMove the selection head one line up.\n*/\n\n\nvar selectLineUp = function selectLineUp(view) {\n  return selectByLine(view, false);\n};\n/**\nMove the selection head one line down.\n*/\n\n\nvar selectLineDown = function selectLineDown(view) {\n  return selectByLine(view, true);\n};\n\nfunction selectByPage(view, forward) {\n  return extendSel(view, function (range) {\n    return view.moveVertically(range, forward, pageInfo(view).height);\n  });\n}\n/**\nMove the selection head one page up.\n*/\n\n\nvar selectPageUp = function selectPageUp(view) {\n  return selectByPage(view, false);\n};\n/**\nMove the selection head one page down.\n*/\n\n\nvar selectPageDown = function selectPageDown(view) {\n  return selectByPage(view, true);\n};\n/**\nMove the selection head to the next line boundary.\n*/\n\n\nvar selectLineBoundaryForward = function selectLineBoundaryForward(view) {\n  return extendSel(view, function (range) {\n    return moveByLineBoundary(view, range, true);\n  });\n};\n/**\nMove the selection head to the previous line boundary.\n*/\n\n\nvar selectLineBoundaryBackward = function selectLineBoundaryBackward(view) {\n  return extendSel(view, function (range) {\n    return moveByLineBoundary(view, range, false);\n  });\n};\n/**\nMove the selection head one line boundary to the left.\n*/\n\n\nvar selectLineBoundaryLeft = function selectLineBoundaryLeft(view) {\n  return extendSel(view, function (range) {\n    return moveByLineBoundary(view, range, !ltrAtCursor(view));\n  });\n};\n/**\nMove the selection head one line boundary to the right.\n*/\n\n\nvar selectLineBoundaryRight = function selectLineBoundaryRight(view) {\n  return extendSel(view, function (range) {\n    return moveByLineBoundary(view, range, ltrAtCursor(view));\n  });\n};\n/**\nMove the selection head to the start of the line.\n*/\n\n\nvar selectLineStart = function selectLineStart(view) {\n  return extendSel(view, function (range) {\n    return EditorSelection.cursor(view.lineBlockAt(range.head).from);\n  });\n};\n/**\nMove the selection head to the end of the line.\n*/\n\n\nvar selectLineEnd = function selectLineEnd(view) {\n  return extendSel(view, function (range) {\n    return EditorSelection.cursor(view.lineBlockAt(range.head).to);\n  });\n};\n/**\nMove the selection to the start of the document.\n*/\n\n\nvar cursorDocStart = function cursorDocStart(_ref7) {\n  var state = _ref7.state,\n      dispatch = _ref7.dispatch;\n  dispatch(setSel(state, {\n    anchor: 0\n  }));\n  return true;\n};\n/**\nMove the selection to the end of the document.\n*/\n\n\nvar cursorDocEnd = function cursorDocEnd(_ref8) {\n  var state = _ref8.state,\n      dispatch = _ref8.dispatch;\n  dispatch(setSel(state, {\n    anchor: state.doc.length\n  }));\n  return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\n\n\nvar selectDocStart = function selectDocStart(_ref9) {\n  var state = _ref9.state,\n      dispatch = _ref9.dispatch;\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: 0\n  }));\n  return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\n\n\nvar selectDocEnd = function selectDocEnd(_ref10) {\n  var state = _ref10.state,\n      dispatch = _ref10.dispatch;\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: state.doc.length\n  }));\n  return true;\n};\n/**\nSelect the entire document.\n*/\n\n\nvar selectAll = function selectAll(_ref11) {\n  var state = _ref11.state,\n      dispatch = _ref11.dispatch;\n  dispatch(state.update({\n    selection: {\n      anchor: 0,\n      head: state.doc.length\n    },\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\n\n\nvar selectLine = function selectLine(_ref12) {\n  var state = _ref12.state,\n      dispatch = _ref12.dispatch;\n  var ranges = selectedLineBlocks(state).map(function (_ref13) {\n    var from = _ref13.from,\n        to = _ref13.to;\n    return EditorSelection.range(from, Math.min(to + 1, state.doc.length));\n  });\n  dispatch(state.update({\n    selection: EditorSelection.create(ranges),\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\n\n\nvar selectParentSyntax = function selectParentSyntax(_ref14) {\n  var state = _ref14.state,\n      dispatch = _ref14.dispatch;\n  var selection = updateSel(state.selection, function (range) {\n    var tree = syntaxTree(state),\n        stack = tree.resolveStack(range.from, 1);\n\n    if (range.empty) {\n      var stackBefore = tree.resolveStack(range.from, -1);\n      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to) stack = stackBefore;\n    }\n\n    for (var cur = stack; cur; cur = cur.next) {\n      var _cur = cur,\n          node = _cur.node;\n      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur.next) return EditorSelection.range(node.to, node.from);\n    }\n\n    return range;\n  });\n  if (selection.eq(state.selection)) return false;\n  dispatch(setSel(state, selection));\n  return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\n\n\nvar simplifySelection = function simplifySelection(_ref15) {\n  var state = _ref15.state,\n      dispatch = _ref15.dispatch;\n  var cur = state.selection,\n      selection = null;\n  if (cur.ranges.length > 1) selection = EditorSelection.create([cur.main]);else if (!cur.main.empty) selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);\n  if (!selection) return false;\n  dispatch(setSel(state, selection));\n  return true;\n};\n\nfunction deleteBy(target, by) {\n  if (target.state.readOnly) return false;\n  var event = \"delete.selection\",\n      state = target.state;\n  var changes = state.changeByRange(function (range) {\n    var from = range.from,\n        to = range.to;\n\n    if (from == to) {\n      var towards = by(range);\n\n      if (towards < from) {\n        event = \"delete.backward\";\n        towards = skipAtomic(target, towards, false);\n      } else if (towards > from) {\n        event = \"delete.forward\";\n        towards = skipAtomic(target, towards, true);\n      }\n\n      from = Math.min(from, towards);\n      to = Math.max(to, towards);\n    } else {\n      from = skipAtomic(target, from, false);\n      to = skipAtomic(target, to, true);\n    }\n\n    return from == to ? {\n      range: range\n    } : {\n      changes: {\n        from: from,\n        to: to\n      },\n      range: EditorSelection.cursor(from, from < range.head ? -1 : 1)\n    };\n  });\n  if (changes.changes.empty) return false;\n  target.dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: event,\n    effects: event == \"delete.selection\" ? EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n  }));\n  return true;\n}\n\nfunction skipAtomic(target, pos, forward) {\n  if (target instanceof EditorView) {\n    var _iterator7 = _createForOfIteratorHelper(target.state.facet(EditorView.atomicRanges).map(function (f) {\n      return f(target);\n    })),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var ranges = _step7.value;\n        ranges.between(pos, pos, function (from, to) {\n          if (from < pos && to > pos) pos = forward ? to : from;\n        });\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n  }\n\n  return pos;\n}\n\nvar deleteByChar = function deleteByChar(target, forward, byIndentUnit) {\n  return deleteBy(target, function (range) {\n    var pos = range.from,\n        state = target.state,\n        line = state.doc.lineAt(pos),\n        before,\n        targetPos;\n\n    if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n      if (before[before.length - 1] == \"\\t\") return pos - 1;\n      var col = countColumn(before, state.tabSize),\n          drop = col % getIndentUnit(state) || getIndentUnit(state);\n\n      for (var i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++) {\n        pos--;\n      }\n\n      targetPos = pos;\n    } else {\n      targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;\n      if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;\n    }\n\n    return targetPos;\n  });\n};\n/**\nDelete the selection, or, for cursor selections, the character or\nindentation unit before the cursor.\n*/\n\n\nvar deleteCharBackward = function deleteCharBackward(view) {\n  return deleteByChar(view, false, true);\n};\n/**\nDelete the selection or the character before the cursor. Does not\nimplement any extended behavior like deleting whole indentation\nunits in one go.\n*/\n\n\nvar deleteCharBackwardStrict = function deleteCharBackwardStrict(view) {\n  return deleteByChar(view, false, false);\n};\n/**\nDelete the selection or the character after the cursor.\n*/\n\n\nvar deleteCharForward = function deleteCharForward(view) {\n  return deleteByChar(view, true, false);\n};\n\nvar deleteByGroup = function deleteByGroup(target, forward) {\n  return deleteBy(target, function (range) {\n    var pos = range.head,\n        state = target.state,\n        line = state.doc.lineAt(pos);\n    var categorize = state.charCategorizer(pos);\n\n    for (var cat = null;;) {\n      if (pos == (forward ? line.to : line.from)) {\n        if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n        break;\n      }\n\n      var next = findClusterBreak(line.text, pos - line.from, forward) + line.from;\n      var nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n      var nextCat = categorize(nextChar);\n      if (cat != null && nextCat != cat) break;\n      if (nextChar != \" \" || pos != range.head) cat = nextCat;\n      pos = next;\n    }\n\n    return pos;\n  });\n};\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\n\n\nvar deleteGroupBackward = function deleteGroupBackward(target) {\n  return deleteByGroup(target, false);\n};\n/**\nDelete the selection or forward until the end of the next group.\n*/\n\n\nvar deleteGroupForward = function deleteGroupForward(target) {\n  return deleteByGroup(target, true);\n};\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\n\n\nvar deleteToLineEnd = function deleteToLineEnd(view) {\n  return deleteBy(view, function (range) {\n    var lineEnd = view.lineBlockAt(range.head).to;\n    return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n  });\n};\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\n\n\nvar deleteToLineStart = function deleteToLineStart(view) {\n  return deleteBy(view, function (range) {\n    var lineStart = view.lineBlockAt(range.head).from;\n    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n  });\n};\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/\n\n\nvar deleteLineBoundaryBackward = function deleteLineBoundaryBackward(view) {\n  return deleteBy(view, function (range) {\n    var lineStart = view.moveToLineBoundary(range, false).head;\n    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n  });\n};\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/\n\n\nvar deleteLineBoundaryForward = function deleteLineBoundaryForward(view) {\n  return deleteBy(view, function (range) {\n    var lineStart = view.moveToLineBoundary(range, true).head;\n    return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n  });\n};\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\n\n\nvar deleteTrailingWhitespace = function deleteTrailingWhitespace(_ref16) {\n  var state = _ref16.state,\n      dispatch = _ref16.dispatch;\n  if (state.readOnly) return false;\n  var changes = [];\n\n  for (var pos = 0, prev = \"\", iter = state.doc.iter();;) {\n    iter.next();\n\n    if (iter.lineBreak || iter.done) {\n      var trailing = prev.search(/\\s+$/);\n      if (trailing > -1) changes.push({\n        from: pos - (prev.length - trailing),\n        to: pos\n      });\n      if (iter.done) break;\n      prev = \"\";\n    } else {\n      prev = iter.value;\n    }\n\n    pos += iter.value.length;\n  }\n\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes: changes,\n    userEvent: \"delete\"\n  }));\n  return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\n\n\nvar splitLine = function splitLine(_ref17) {\n  var state = _ref17.state,\n      dispatch = _ref17.dispatch;\n  if (state.readOnly) return false;\n  var changes = state.changeByRange(function (range) {\n    return {\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: Text.of([\"\", \"\"])\n      },\n      range: EditorSelection.cursor(range.from)\n    };\n  });\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\n\n\nvar transposeChars = function transposeChars(_ref18) {\n  var state = _ref18.state,\n      dispatch = _ref18.dispatch;\n  if (state.readOnly) return false;\n  var changes = state.changeByRange(function (range) {\n    if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n      range: range\n    };\n    var pos = range.from,\n        line = state.doc.lineAt(pos);\n    var from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;\n    var to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;\n    return {\n      changes: {\n        from: from,\n        to: to,\n        insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n      },\n      range: EditorSelection.cursor(to)\n    };\n  });\n  if (changes.changes.empty) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"move.character\"\n  }));\n  return true;\n};\n\nfunction selectedLineBlocks(state) {\n  var blocks = [],\n      upto = -1;\n\n  var _iterator8 = _createForOfIteratorHelper(state.selection.ranges),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var range = _step8.value;\n      var startLine = state.doc.lineAt(range.from),\n          endLine = state.doc.lineAt(range.to);\n      if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n\n      if (upto >= startLine.number) {\n        var prev = blocks[blocks.length - 1];\n        prev.to = endLine.to;\n        prev.ranges.push(range);\n      } else {\n        blocks.push({\n          from: startLine.from,\n          to: endLine.to,\n          ranges: [range]\n        });\n      }\n\n      upto = endLine.number + 1;\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return blocks;\n}\n\nfunction moveLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  var changes = [],\n      ranges = [];\n\n  var _iterator9 = _createForOfIteratorHelper(selectedLineBlocks(state)),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var block = _step9.value;\n      if (forward ? block.to == state.doc.length : block.from == 0) continue;\n      var nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n      var size = nextLine.length + 1;\n\n      if (forward) {\n        changes.push({\n          from: block.to,\n          to: nextLine.to\n        }, {\n          from: block.from,\n          insert: nextLine.text + state.lineBreak\n        });\n\n        var _iterator10 = _createForOfIteratorHelper(block.ranges),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var r = _step10.value;\n            ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      } else {\n        changes.push({\n          from: nextLine.from,\n          to: block.from\n        }, {\n          from: block.to,\n          insert: state.lineBreak + nextLine.text\n        });\n\n        var _iterator11 = _createForOfIteratorHelper(block.ranges),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var _r = _step11.value;\n            ranges.push(EditorSelection.range(_r.anchor - size, _r.head - size));\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes: changes,\n    scrollIntoView: true,\n    selection: EditorSelection.create(ranges, state.selection.mainIndex),\n    userEvent: \"move.line\"\n  }));\n  return true;\n}\n/**\nMove the selected lines up one line.\n*/\n\n\nvar moveLineUp = function moveLineUp(_ref19) {\n  var state = _ref19.state,\n      dispatch = _ref19.dispatch;\n  return moveLine(state, dispatch, false);\n};\n/**\nMove the selected lines down one line.\n*/\n\n\nvar moveLineDown = function moveLineDown(_ref20) {\n  var state = _ref20.state,\n      dispatch = _ref20.dispatch;\n  return moveLine(state, dispatch, true);\n};\n\nfunction copyLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  var changes = [];\n\n  var _iterator12 = _createForOfIteratorHelper(selectedLineBlocks(state)),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var block = _step12.value;\n      if (forward) changes.push({\n        from: block.from,\n        insert: state.doc.slice(block.from, block.to) + state.lineBreak\n      });else changes.push({\n        from: block.to,\n        insert: state.lineBreak + state.doc.slice(block.from, block.to)\n      });\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  dispatch(state.update({\n    changes: changes,\n    scrollIntoView: true,\n    userEvent: \"input.copyline\"\n  }));\n  return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\n\n\nvar copyLineUp = function copyLineUp(_ref21) {\n  var state = _ref21.state,\n      dispatch = _ref21.dispatch;\n  return copyLine(state, dispatch, false);\n};\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\n\n\nvar copyLineDown = function copyLineDown(_ref22) {\n  var state = _ref22.state,\n      dispatch = _ref22.dispatch;\n  return copyLine(state, dispatch, true);\n};\n/**\nDelete selected lines.\n*/\n\n\nvar deleteLine = function deleteLine(view) {\n  if (view.state.readOnly) return false;\n  var state = view.state,\n      changes = state.changes(selectedLineBlocks(state).map(function (_ref23) {\n    var from = _ref23.from,\n        to = _ref23.to;\n    if (from > 0) from--;else if (to < state.doc.length) to++;\n    return {\n      from: from,\n      to: to\n    };\n  }));\n  var selection = updateSel(state.selection, function (range) {\n    var dist = undefined;\n\n    if (view.lineWrapping) {\n      var block = view.lineBlockAt(range.head),\n          pos = view.coordsAtPos(range.head, range.assoc || 1);\n      if (pos) dist = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;\n    }\n\n    return view.moveVertically(range, true, dist);\n  }).map(changes);\n  view.dispatch({\n    changes: changes,\n    selection: selection,\n    scrollIntoView: true,\n    userEvent: \"delete.line\"\n  });\n  return true;\n};\n/**\nReplace the selection with a newline.\n*/\n\n\nvar insertNewline = function insertNewline(_ref24) {\n  var state = _ref24.state,\n      dispatch = _ref24.dispatch;\n  dispatch(state.update(state.replaceSelection(state.lineBreak), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nReplace the selection with a newline and the same amount of\nindentation as the line above.\n*/\n\n\nvar insertNewlineKeepIndent = function insertNewlineKeepIndent(_ref25) {\n  var state = _ref25.state,\n      dispatch = _ref25.dispatch;\n  dispatch(state.update(state.changeByRange(function (range) {\n    var indent = /^\\s*/.exec(state.doc.lineAt(range.from).text)[0];\n    return {\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: state.lineBreak + indent\n      },\n      range: EditorSelection.cursor(range.from + indent.length + 1)\n    };\n  }), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n\nfunction isBetweenBrackets(state, pos) {\n  if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n    from: pos,\n    to: pos\n  };\n  var context = syntaxTree(state).resolveInner(pos);\n  var before = context.childBefore(pos),\n      after = context.childAfter(pos),\n      closedBy;\n  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\\S/.test(state.sliceDoc(before.to, after.from))) return {\n    from: before.to,\n    to: after.from\n  };\n  return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\n\n\nvar insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\n\nvar insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\n\nfunction newlineAndIndent(atEof) {\n  return function (_ref26) {\n    var state = _ref26.state,\n        dispatch = _ref26.dispatch;\n    if (state.readOnly) return false;\n    var changes = state.changeByRange(function (range) {\n      var from = range.from,\n          to = range.to,\n          line = state.doc.lineAt(from);\n      var explode = !atEof && from == to && isBetweenBrackets(state, from);\n      if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n      var cx = new IndentContext(state, {\n        simulateBreak: from,\n        simulateDoubleBreak: !!explode\n      });\n      var indent = getIndentation(cx, from);\n      if (indent == null) indent = countColumn(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n\n      while (to < line.to && /\\s/.test(line.text[to - line.from])) {\n        to++;\n      }\n\n      if (explode) {\n        from = explode.from;\n        to = explode.to;\n      } else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n\n      var insert = [\"\", indentString(state, indent)];\n      if (explode) insert.push(indentString(state, cx.lineIndent(line.from, -1)));\n      return {\n        changes: {\n          from: from,\n          to: to,\n          insert: Text.of(insert)\n        },\n        range: EditorSelection.cursor(from + 1 + insert[1].length)\n      };\n    });\n    dispatch(state.update(changes, {\n      scrollIntoView: true,\n      userEvent: \"input\"\n    }));\n    return true;\n  };\n}\n\nfunction changeBySelectedLine(state, f) {\n  var atLine = -1;\n  return state.changeByRange(function (range) {\n    var changes = [];\n\n    for (var pos = range.from; pos <= range.to;) {\n      var line = state.doc.lineAt(pos);\n\n      if (line.number > atLine && (range.empty || range.to > line.from)) {\n        f(line, changes, range);\n        atLine = line.number;\n      }\n\n      pos = line.to + 1;\n    }\n\n    var changeSet = state.changes(changes);\n    return {\n      changes: changes,\n      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n    };\n  });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\n\n\nvar indentSelection = function indentSelection(_ref27) {\n  var state = _ref27.state,\n      dispatch = _ref27.dispatch;\n  if (state.readOnly) return false;\n  var updated = Object.create(null);\n  var context = new IndentContext(state, {\n    overrideIndentation: function overrideIndentation(start) {\n      var found = updated[start];\n      return found == null ? -1 : found;\n    }\n  });\n  var changes = changeBySelectedLine(state, function (line, changes, range) {\n    var indent = getIndentation(context, line.from);\n    if (indent == null) return;\n    if (!/\\S/.test(line.text)) indent = 0;\n    var cur = /^\\s*/.exec(line.text)[0];\n    var norm = indentString(state, indent);\n\n    if (cur != norm || range.from < line.from + cur.length) {\n      updated[line.from] = indent;\n      changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n  });\n  if (!changes.changes.empty) dispatch(state.update(changes, {\n    userEvent: \"indent\"\n  }));\n  return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\n\n\nvar indentMore = function indentMore(_ref28) {\n  var state = _ref28.state,\n      dispatch = _ref28.dispatch;\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, function (line, changes) {\n    changes.push({\n      from: line.from,\n      insert: state.facet(indentUnit)\n    });\n  }), {\n    userEvent: \"input.indent\"\n  }));\n  return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\n\n\nvar indentLess = function indentLess(_ref29) {\n  var state = _ref29.state,\n      dispatch = _ref29.dispatch;\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, function (line, changes) {\n    var space = /^\\s*/.exec(line.text)[0];\n    if (!space) return;\n    var col = countColumn(space, state.tabSize),\n        keep = 0;\n    var insert = indentString(state, Math.max(0, col - getIndentUnit(state)));\n\n    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) {\n      keep++;\n    }\n\n    changes.push({\n      from: line.from + keep,\n      to: line.from + space.length,\n      insert: insert.slice(keep)\n    });\n  }), {\n    userEvent: \"delete.dedent\"\n  }));\n  return true;\n};\n/**\nEnables or disables\n[tab-focus mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode). While on, this\nprevents the editor's key bindings from capturing Tab or\nShift-Tab, making it possible for the user to move focus out of\nthe editor with the keyboard.\n*/\n\n\nvar toggleTabFocusMode = function toggleTabFocusMode(view) {\n  view.setTabFocusMode();\n  return true;\n};\n/**\nTemporarily enables [tab-focus\nmode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode) for two seconds or until\nanother key is pressed.\n*/\n\n\nvar temporarilySetTabFocusMode = function temporarilySetTabFocusMode(view) {\n  view.setTabFocusMode(2000);\n  return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\n\n\nvar insertTab = function insertTab(_ref30) {\n  var state = _ref30.state,\n      dispatch = _ref30.dispatch;\n  if (state.selection.ranges.some(function (r) {\n    return !r.empty;\n  })) return indentMore({\n    state: state,\n    dispatch: dispatch\n  });\n  dispatch(state.update(state.replaceSelection(\"\\t\"), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\n\n\nvar emacsStyleKeymap = [{\n  key: \"Ctrl-b\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Ctrl-f\",\n  run: cursorCharRight,\n  shift: selectCharRight\n}, {\n  key: \"Ctrl-p\",\n  run: cursorLineUp,\n  shift: selectLineUp\n}, {\n  key: \"Ctrl-n\",\n  run: cursorLineDown,\n  shift: selectLineDown\n}, {\n  key: \"Ctrl-a\",\n  run: cursorLineStart,\n  shift: selectLineStart\n}, {\n  key: \"Ctrl-e\",\n  run: cursorLineEnd,\n  shift: selectLineEnd\n}, {\n  key: \"Ctrl-d\",\n  run: deleteCharForward\n}, {\n  key: \"Ctrl-h\",\n  run: deleteCharBackward\n}, {\n  key: \"Ctrl-k\",\n  run: deleteToLineEnd\n}, {\n  key: \"Ctrl-Alt-h\",\n  run: deleteGroupBackward\n}, {\n  key: \"Ctrl-o\",\n  run: splitLine\n}, {\n  key: \"Ctrl-t\",\n  run: transposeChars\n}, {\n  key: \"Ctrl-v\",\n  run: cursorPageDown\n}];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter and Shift-Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/\n\nvar standardKeymap = /*@__PURE__*/[{\n  key: \"ArrowLeft\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowLeft\",\n  mac: \"Alt-ArrowLeft\",\n  run: cursorGroupLeft,\n  shift: selectGroupLeft,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowLeft\",\n  run: cursorLineBoundaryLeft,\n  shift: selectLineBoundaryLeft,\n  preventDefault: true\n}, {\n  key: \"ArrowRight\",\n  run: cursorCharRight,\n  shift: selectCharRight,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowRight\",\n  mac: \"Alt-ArrowRight\",\n  run: cursorGroupRight,\n  shift: selectGroupRight,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowRight\",\n  run: cursorLineBoundaryRight,\n  shift: selectLineBoundaryRight,\n  preventDefault: true\n}, {\n  key: \"ArrowUp\",\n  run: cursorLineUp,\n  shift: selectLineUp,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowUp\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  mac: \"Ctrl-ArrowUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"ArrowDown\",\n  run: cursorLineDown,\n  shift: selectLineDown,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowDown\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  mac: \"Ctrl-ArrowDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"PageUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"PageDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"Home\",\n  run: cursorLineBoundaryBackward,\n  shift: selectLineBoundaryBackward,\n  preventDefault: true\n}, {\n  key: \"Mod-Home\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  key: \"End\",\n  run: cursorLineBoundaryForward,\n  shift: selectLineBoundaryForward,\n  preventDefault: true\n}, {\n  key: \"Mod-End\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  key: \"Enter\",\n  run: insertNewlineAndIndent,\n  shift: insertNewlineAndIndent\n}, {\n  key: \"Mod-a\",\n  run: selectAll\n}, {\n  key: \"Backspace\",\n  run: deleteCharBackward,\n  shift: deleteCharBackward\n}, {\n  key: \"Delete\",\n  run: deleteCharForward\n}, {\n  key: \"Mod-Backspace\",\n  mac: \"Alt-Backspace\",\n  run: deleteGroupBackward\n}, {\n  key: \"Mod-Delete\",\n  mac: \"Alt-Delete\",\n  run: deleteGroupForward\n}, {\n  mac: \"Mod-Backspace\",\n  run: deleteLineBoundaryBackward\n}, {\n  mac: \"Mod-Delete\",\n  run: deleteLineBoundaryForward\n}].concat( /*@__PURE__*/emacsStyleKeymap.map(function (b) {\n  return {\n    mac: b.key,\n    run: b.run,\n    shift: b.shift\n  };\n}));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n- Ctrl-m (Alt-Shift-m on macOS): [`toggleTabFocusMode`](https://codemirror.net/6/docs/ref/#commands.toggleTabFocusMode).\n*/\n\nvar defaultKeymap = /*@__PURE__*/[{\n  key: \"Alt-ArrowLeft\",\n  mac: \"Ctrl-ArrowLeft\",\n  run: cursorSyntaxLeft,\n  shift: selectSyntaxLeft\n}, {\n  key: \"Alt-ArrowRight\",\n  mac: \"Ctrl-ArrowRight\",\n  run: cursorSyntaxRight,\n  shift: selectSyntaxRight\n}, {\n  key: \"Alt-ArrowUp\",\n  run: moveLineUp\n}, {\n  key: \"Shift-Alt-ArrowUp\",\n  run: copyLineUp\n}, {\n  key: \"Alt-ArrowDown\",\n  run: moveLineDown\n}, {\n  key: \"Shift-Alt-ArrowDown\",\n  run: copyLineDown\n}, {\n  key: \"Escape\",\n  run: simplifySelection\n}, {\n  key: \"Mod-Enter\",\n  run: insertBlankLine\n}, {\n  key: \"Alt-l\",\n  mac: \"Ctrl-l\",\n  run: selectLine\n}, {\n  key: \"Mod-i\",\n  run: selectParentSyntax,\n  preventDefault: true\n}, {\n  key: \"Mod-[\",\n  run: indentLess\n}, {\n  key: \"Mod-]\",\n  run: indentMore\n}, {\n  key: \"Mod-Alt-\\\\\",\n  run: indentSelection\n}, {\n  key: \"Shift-Mod-k\",\n  run: deleteLine\n}, {\n  key: \"Shift-Mod-\\\\\",\n  run: cursorMatchingBracket\n}, {\n  key: \"Mod-/\",\n  run: toggleComment\n}, {\n  key: \"Alt-A\",\n  run: toggleBlockComment\n}, {\n  key: \"Ctrl-m\",\n  mac: \"Shift-Alt-m\",\n  run: toggleTabFocusMode\n}].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\n\nvar indentWithTab = {\n  key: \"Tab\",\n  run: indentMore,\n  shift: indentLess\n};\nexport { blockComment, blockUncomment, copyLineDown, copyLineUp, cursorCharBackward, cursorCharBackwardLogical, cursorCharForward, cursorCharForwardLogical, cursorCharLeft, cursorCharRight, cursorDocEnd, cursorDocStart, cursorGroupBackward, cursorGroupForward, cursorGroupLeft, cursorGroupRight, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorLineBoundaryLeft, cursorLineBoundaryRight, cursorLineDown, cursorLineEnd, cursorLineStart, cursorLineUp, cursorMatchingBracket, cursorPageDown, cursorPageUp, cursorSubwordBackward, cursorSubwordForward, cursorSyntaxLeft, cursorSyntaxRight, defaultKeymap, deleteCharBackward, deleteCharBackwardStrict, deleteCharForward, deleteGroupBackward, deleteGroupForward, deleteLine, deleteLineBoundaryBackward, deleteLineBoundaryForward, deleteToLineEnd, deleteToLineStart, deleteTrailingWhitespace, emacsStyleKeymap, history, historyField, historyKeymap, indentLess, indentMore, indentSelection, indentWithTab, insertBlankLine, insertNewline, insertNewlineAndIndent, insertNewlineKeepIndent, insertTab, invertedEffects, isolateHistory, lineComment, lineUncomment, moveLineDown, moveLineUp, redo, redoDepth, redoSelection, selectAll, selectCharBackward, selectCharBackwardLogical, selectCharForward, selectCharForwardLogical, selectCharLeft, selectCharRight, selectDocEnd, selectDocStart, selectGroupBackward, selectGroupForward, selectGroupLeft, selectGroupRight, selectLine, selectLineBoundaryBackward, selectLineBoundaryForward, selectLineBoundaryLeft, selectLineBoundaryRight, selectLineDown, selectLineEnd, selectLineStart, selectLineUp, selectMatchingBracket, selectPageDown, selectPageUp, selectParentSyntax, selectSubwordBackward, selectSubwordForward, selectSyntaxLeft, selectSyntaxRight, simplifySelection, splitLine, standardKeymap, temporarilySetTabFocusMode, toggleBlockComment, toggleBlockCommentByLine, toggleComment, toggleLineComment, toggleTabFocusMode, transposeChars, undo, undoDepth, undoSelection };","map":{"version":3,"sources":["/Users/sairahulpadma/Desktop/leetcodeUI/frontend/node_modules/@codemirror/commands/dist/index.js"],"names":["Annotation","Facet","combineConfig","StateField","Transaction","ChangeSet","ChangeDesc","EditorSelection","StateEffect","Text","findClusterBreak","countColumn","CharCategory","EditorView","Direction","IndentContext","getIndentation","indentString","matchBrackets","syntaxTree","getIndentUnit","indentUnit","NodeProp","toggleComment","target","state","line","doc","lineAt","selection","main","from","config","getConfig","toggleLineComment","block","toggleBlockCommentByLine","command","f","option","dispatch","readOnly","tr","update","changeLineComment","lineComment","lineUncomment","toggleBlockComment","changeBlockComment","blockComment","blockUncomment","o","s","selectedLineRanges","pos","data","languageDataAt","length","SearchMargin","findBlockComment","to","open","close","textBefore","sliceDoc","textAfter","spaceBefore","exec","spaceAfter","beforeOff","slice","margin","startText","endText","startSpace","endSpace","endOff","test","charAt","ranges","r","fromLine","toLine","last","push","text","tokens","map","every","c","comments","i","changes","range","insert","some","comment","token","lines","prevLine","startI","minIndent","indent","empty","single","l","changeSet","fromHistory","define","isolateHistory","invertedEffects","historyConfig","combine","configs","minDepth","newGroupDelay","joinToEvent","_t","isAdjacent","Math","max","min","a","b","adj","historyField_","create","HistoryState","facet","fromHist","annotation","item","HistEvent","fromTransaction","side","other","undone","done","updateBranch","addSelection","startState","rest","isolate","addToHistory","addMapping","desc","event","time","userEvent","addChanges","toJSON","value","e","fromJSON","json","history","of","domEventHandlers","beforeinput","view","inputType","undo","redo","preventDefault","historyField","cmd","historyState","field","pop","undoSelection","redoSelection","depth","histState","branch","undoDepth","redoDepth","effects","mapped","startSelection","selectionsAfter","after","_a","_b","_c","none","invert","result","concat","undefined","selections","maxLen","newEvent","start","newBranch","iterChangedRanges","t","_f","eqSelectionShape","filter","conc","MaxSelectionsPerEvent","lastEvent","sels","eq","setSelAfter","popSelection","addMappingToBranch","mapping","mapEvent","extraSelections","mappedChanges","before","mapDesc","fullMapping","composeDesc","mapEffects","joinableUserEvent","prevTime","prevUserEvent","compose","onlySelection","annotations","scrollIntoView","historyKeymap","key","run","mac","linux","updateSel","sel","by","mainIndex","setSel","moveSel","how","rangeEnd","forward","cursor","cursorByChar","moveByChar","ltrAtCursor","textDirectionAt","head","LTR","cursorCharLeft","cursorCharRight","cursorCharForward","cursorCharBackward","byCharLogical","moveByCharLogical","cursorCharForwardLogical","cursorCharBackwardLogical","cursorByGroup","moveByGroup","cursorGroupLeft","cursorGroupRight","cursorGroupForward","cursorGroupBackward","segmenter","Intl","Segmenter","granularity","moveBySubword","categorize","charCategorizer","cat","Space","steps","sawUpper","sawLower","step","next","nextCat","ahead","Word","charCodeAt","toLowerCase","end","skipped","segments","Array","segment","index","cursorBySubword","cursorSubwordForward","cursorSubwordBackward","interestingNode","node","bracketProp","type","prop","len","firstChild","moveBySyntax","resolveInner","closedBy","openedBy","at","childAfter","childBefore","bracket","match","newPos","matched","cursorSyntaxLeft","cursorSyntaxRight","cursorByLine","moved","moveVertically","moveToLineBoundary","cursorLineUp","cursorLineDown","pageInfo","selfScroll","scrollDOM","clientHeight","scrollHeight","marginTop","marginBottom","height","scrollMargins","source","margins","top","bottom","dom","ownerDocument","defaultView","window","innerHeight","defaultLineHeight","cursorByPage","page","effect","startPos","coordsAtPos","scrollRect","getBoundingClientRect","scrollTop","scrollBottom","y","yMargin","cursorPageUp","cursorPageDown","moveByLineBoundary","lineBlockAt","space","cursorLineBoundaryForward","cursorLineBoundaryBackward","cursorLineBoundaryLeft","cursorLineBoundaryRight","cursorLineStart","cursorLineEnd","toMatchingBracket","extend","found","matching","anchor","cursorMatchingBracket","selectMatchingBracket","extendSel","goalColumn","bidiLevel","selectByChar","selectCharLeft","selectCharRight","selectCharForward","selectCharBackward","selectCharForwardLogical","selectCharBackwardLogical","selectByGroup","selectGroupLeft","selectGroupRight","selectGroupForward","selectGroupBackward","selectBySubword","selectSubwordForward","selectSubwordBackward","selectSyntaxLeft","selectSyntaxRight","selectByLine","selectLineUp","selectLineDown","selectByPage","selectPageUp","selectPageDown","selectLineBoundaryForward","selectLineBoundaryBackward","selectLineBoundaryLeft","selectLineBoundaryRight","selectLineStart","selectLineEnd","cursorDocStart","cursorDocEnd","selectDocStart","selectDocEnd","selectAll","selectLine","selectedLineBlocks","selectParentSyntax","tree","stack","resolveStack","stackBefore","cur","simplifySelection","deleteBy","changeByRange","towards","skipAtomic","announce","phrase","atomicRanges","between","deleteByChar","byIndentUnit","targetPos","col","tabSize","drop","number","deleteCharBackward","deleteCharBackwardStrict","deleteCharForward","deleteByGroup","nextChar","deleteGroupBackward","deleteGroupForward","deleteToLineEnd","lineEnd","deleteToLineStart","lineStart","deleteLineBoundaryBackward","deleteLineBoundaryForward","deleteTrailingWhitespace","prev","iter","lineBreak","trailing","search","splitLine","transposeChars","append","blocks","upto","startLine","endLine","moveLine","nextLine","size","moveLineUp","moveLineDown","copyLine","copyLineUp","copyLineDown","deleteLine","dist","lineWrapping","assoc","documentTop","insertNewline","replaceSelection","insertNewlineKeepIndent","isBetweenBrackets","context","indexOf","name","insertNewlineAndIndent","newlineAndIndent","insertBlankLine","atEof","explode","cx","simulateBreak","simulateDoubleBreak","lineIndent","changeBySelectedLine","atLine","mapPos","indentSelection","updated","Object","overrideIndentation","norm","indentMore","indentLess","keep","toggleTabFocusMode","setTabFocusMode","temporarilySetTabFocusMode","insertTab","emacsStyleKeymap","shift","standardKeymap","defaultKeymap","indentWithTab"],"mappings":"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","sourcesContent":["import { Annotation, Facet, combineConfig, StateField, Transaction, ChangeSet, ChangeDesc, EditorSelection, StateEffect, Text, findClusterBreak, countColumn, CharCategory } from '@codemirror/state';\nimport { EditorView, Direction } from '@codemirror/view';\nimport { IndentContext, getIndentation, indentString, matchBrackets, syntaxTree, getIndentUnit, indentUnit } from '@codemirror/language';\nimport { NodeProp } from '@lezer/common';\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\nconst toggleComment = target => {\n    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch }) => {\n        if (state.readOnly)\n            return false;\n        let tr = f(option, state);\n        if (!tr)\n            return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* CommentOption.Toggle */);\n/**\nComment the current selection using line comments.\n*/\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1 /* CommentOption.Comment */);\n/**\nUncomment the current selection using line comments.\n*/\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2 /* CommentOption.Uncomment */);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* CommentOption.Toggle */);\n/**\nComment the current selection using block comments.\n*/\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1 /* CommentOption.Comment */);\n/**\nUncomment the current selection using block comments.\n*/\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2 /* CommentOption.Uncomment */);\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/\nconst toggleBlockCommentByLine = /*@__PURE__*/command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */);\nfunction getConfig(state, pos) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\nfunction findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&\n        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },\n            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    }\n    else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open &&\n        endText.slice(endOff, endOff + close.length) == close) {\n        return { open: { pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },\n            close: { pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };\n    }\n    return null;\n}\nfunction selectedLineRanges(state) {\n    let ranges = [];\n    for (let r of state.selection.ranges) {\n        let fromLine = state.doc.lineAt(r.from);\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n        if (toLine.from > fromLine.from && toLine.from == r.to)\n            toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);\n        let last = ranges.length - 1;\n        if (last >= 0 && ranges[last].to > fromLine.from)\n            ranges[last].to = toLine.to;\n        else\n            ranges.push({ from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length, to: toLine.to });\n    }\n    return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n    let tokens = ranges.map(r => getConfig(state, r.from).block);\n    if (!tokens.every(c => c))\n        return null;\n    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* CommentOption.Uncomment */ && !comments.every(c => c)) {\n        return { changes: state.changes(ranges.map((range, i) => {\n                if (comments[i])\n                    return [];\n                return [{ from: range.from, insert: tokens[i].open + \" \" }, { from: range.to, insert: \" \" + tokens[i].close }];\n            })) };\n    }\n    else if (option != 1 /* CommentOption.Comment */ && comments.some(c => c)) {\n        let changes = [];\n        for (let i = 0, comment; i < comments.length; i++)\n            if (comment = comments[i]) {\n                let token = tokens[i], { open, close } = comment;\n                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });\n            }\n        return { changes };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges) {\n        let startI = lines.length, minIndent = 1e9;\n        let token = getConfig(state, from).line;\n        if (!token)\n            continue;\n        for (let pos = from; pos <= to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent)\n                    minIndent = indent;\n                lines.push({ line, comment, token, indent, empty, single: false });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9)\n            for (let i = startI; i < lines.length; i++)\n                if (lines[i].indent < lines[i].line.text.length)\n                    lines[i].indent = minIndent;\n        if (lines.length == startI + 1)\n            lines[startI].single = true;\n    }\n    if (option != 2 /* CommentOption.Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)\n            if (single || !empty)\n                changes.push({ from: line.from + indent, insert: token + \" \" });\n        let changeSet = state.changes(changes);\n        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };\n    }\n    else if (option != 1 /* CommentOption.Comment */ && lines.some(l => l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)\n            if (comment >= 0) {\n                let from = line.from + comment, to = from + token.length;\n                if (line.text[to - line.from] == \" \")\n                    to++;\n                changes.push({ from, to });\n            }\n        return { changes };\n    }\n    return null;\n}\n\nconst fromHistory = /*@__PURE__*/Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\nconst isolateHistory = /*@__PURE__*/Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\nconst invertedEffects = /*@__PURE__*/Facet.define();\nconst historyConfig = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            minDepth: 100,\n            newGroupDelay: 500,\n            joinToEvent: (_t, isAdjacent) => isAdjacent,\n        }, {\n            minDepth: Math.max,\n            newGroupDelay: Math.min,\n            joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)\n        });\n    }\n});\nconst historyField_ = /*@__PURE__*/StateField.define({\n    create() {\n        return HistoryState.empty;\n    },\n    update(state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;\n            let other = from == 0 /* BranchName.Done */ ? state.undone : state.done;\n            if (item)\n                other = updateBranch(other, other.length, config.minDepth, item);\n            else\n                other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\")\n            state = state.isolate();\n        if (tr.annotation(Transaction.addToHistory) === false)\n            return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);\n        if (event)\n            state = state.addChanges(event, time, userEvent, config, tr);\n        else if (tr.selection)\n            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\")\n            state = state.isolate();\n        return state;\n    },\n    toJSON(value) {\n        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };\n    },\n    fromJSON(json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/\nfunction history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        EditorView.domEventHandlers({\n            beforeinput(e, view) {\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n                if (!command)\n                    return false;\n                e.preventDefault();\n                return command(view);\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\nconst historyField = historyField_;\nfunction cmd(side, selection) {\n    return function ({ state, dispatch }) {\n        if (!selection && state.readOnly)\n            return false;\n        let historyState = state.field(historyField_, false);\n        if (!historyState)\n            return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr)\n            return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\nconst undo = /*@__PURE__*/cmd(0 /* BranchName.Done */, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\nconst redo = /*@__PURE__*/cmd(1 /* BranchName.Undone */, false);\n/**\nUndo a change or selection change.\n*/\nconst undoSelection = /*@__PURE__*/cmd(0 /* BranchName.Done */, true);\n/**\nRedo a change or selection change.\n*/\nconst redoSelection = /*@__PURE__*/cmd(1 /* BranchName.Undone */, true);\nfunction depth(side) {\n    return function (state) {\n        let histState = state.field(historyField_, false);\n        if (!histState)\n            return 0;\n        let branch = side == 0 /* BranchName.Done */ ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\nconst undoDepth = /*@__PURE__*/depth(0 /* BranchName.Done */);\n/**\nThe amount of redoable change events available in a given state.\n*/\nconst redoDepth = /*@__PURE__*/depth(1 /* BranchName.Undone */);\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(\n    // The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, \n    // The effects associated with this event\n    effects, \n    // Accumulated mapping (from addToHistory==false) that should be\n    // applied to events below this one.\n    mapped, \n    // The selection before this event\n    startSelection, \n    // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter) {\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr, selection) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)) {\n            let result = invert(tr);\n            if (result.length)\n                effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty)\n            return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t) => ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t) => {\n        for (let i = 0; i < ranges.length;) {\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to)\n                isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length &&\n        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [HistEvent.selection([selection])];\n    }\n    else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection))\n            return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length)\n        return branch;\n    let length = branch.length, selections = none;\n    while (length) {\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        }\n        else { // Drop this event, since there's no changes or effects left\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [HistEvent.selection(selections)] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes)\n        return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, config, tr) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&\n            (!userEvent || joinableUserEvent.test(userEvent)) &&\n            ((!lastEvent.selectionsAfter.length &&\n                time - this.prevTime < config.newGroupDelay &&\n                config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes))) ||\n                // For compose (but not compose.start) events, always join with previous event\n                userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        }\n        else {\n            done = updateBranch(done, done.length, config.minDepth, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 &&\n            time - this.prevTime < newGroupDelay &&\n            userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) &&\n            eqSelectionShape(last[last.length - 1], selection))\n            return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, onlySelection) {\n        let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;\n        if (branch.length == 0)\n            return null;\n        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;\n        if (onlySelection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),\n                userEvent: side == 0 /* BranchName.Done */ ? \"select.undo\" : \"select.redo\",\n                scrollIntoView: true\n            });\n        }\n        else if (!event.changes) {\n            return null;\n        }\n        else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped)\n                rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({ side, rest, selection }),\n                filter: false,\n                userEvent: side == 0 /* BranchName.Done */ ? \"undo\" : \"redo\",\n                scrollIntoView: true\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/\nconst historyKeymap = [\n    { key: \"Mod-z\", run: undo, preventDefault: true },\n    { key: \"Mod-y\", mac: \"Mod-Shift-z\", run: redo, preventDefault: true },\n    { linux: \"Ctrl-Shift-z\", run: redo, preventDefault: true },\n    { key: \"Mod-u\", run: undoSelection, preventDefault: true },\n    { key: \"Alt-u\", mac: \"Mod-Shift-u\", run: redoSelection, preventDefault: true }\n];\n\nfunction updateSel(sel, by) {\n    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({ selection, scrollIntoView: true, userEvent: \"select\" });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection, true))\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\nconst cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/\nconst cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/\nconst cursorCharForward = view => cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/\nconst cursorCharBackward = view => cursorByChar(view, false);\nfunction byCharLogical(state, range, forward) {\n    let pos = range.head, line = state.doc.lineAt(pos);\n    if (pos == (forward ? line.to : line.from))\n        pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);\n    else\n        pos = line.from + findClusterBreak(line.text, pos - line.from, forward);\n    return EditorSelection.cursor(pos, forward ? -1 : 1);\n}\nfunction moveByCharLogical(target, forward) {\n    return moveSel(target, range => range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one character forward, in logical\n(non-text-direction-aware) string index order.\n*/\nconst cursorCharForwardLogical = target => moveByCharLogical(target, true);\n/**\nMove the selection one character backward, in logical string index\norder.\n*/\nconst cursorCharBackwardLogical = target => moveByCharLogical(target, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\nconst cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/\nconst cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/\nconst cursorGroupBackward = view => cursorByGroup(view, false);\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ?\n    /*@__PURE__*/new (Intl.Segmenter)(undefined, { granularity: \"word\" }) : null;\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    let cat = CharCategory.Space, pos = range.from, steps = 0;\n    let done = false, sawUpper = false, sawLower = false;\n    let step = (next) => {\n        if (done)\n            return false;\n        pos += forward ? next.length : -next.length;\n        let nextCat = categorize(next), ahead;\n        if (nextCat == CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next))\n            nextCat = -1; // Treat word punctuation specially\n        if (cat == CharCategory.Space)\n            cat = nextCat;\n        if (cat != nextCat)\n            return false;\n        if (cat == CharCategory.Word) {\n            if (next.toLowerCase() == next) {\n                if (!forward && sawUpper)\n                    return false;\n                sawLower = true;\n            }\n            else if (sawLower) {\n                if (forward)\n                    return false;\n                done = true;\n            }\n            else {\n                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word &&\n                    ahead.toLowerCase() == ahead)\n                    return false;\n                sawUpper = true;\n            }\n        }\n        steps++;\n        return true;\n    };\n    let end = view.moveByChar(range, forward, start => {\n        step(start);\n        return step;\n    });\n    if (segmenter && cat == CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);\n        let skipped = view.state.sliceDoc(from, to);\n        if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n            let segments = Array.from(segmenter.segment(skipped));\n            if (segments.length > 1) {\n                if (forward)\n                    return EditorSelection.cursor(range.head + segments[1].index, -1);\n                return EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n            }\n        }\n    }\n    return end;\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\nconst cursorSubwordForward = view => cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/\nconst cursorSubwordBackward = view => cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp))\n        return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = syntaxTree(state).resolveInner(start.head);\n    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for (let at = start.head;;) {\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next)\n            break;\n        if (interestingNode(state, next, bracketProp))\n            pos = next;\n        else\n            at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)\n        newPos = forward ? match.end.to : match.end.from;\n    else\n        newPos = forward ? pos.to : pos.from;\n    return EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, range => {\n        if (!range.empty)\n            return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/\nconst cursorLineUp = view => cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/\nconst cursorLineDown = view => cursorByLine(view, true);\nfunction pageInfo(view) {\n    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n    let marginTop = 0, marginBottom = 0, height;\n    if (selfScroll) {\n        for (let source of view.state.facet(EditorView.scrollMargins)) {\n            let margins = source(view);\n            if (margins === null || margins === void 0 ? void 0 : margins.top)\n                marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n            if (margins === null || margins === void 0 ? void 0 : margins.bottom)\n                marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n        }\n        height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n    }\n    else {\n        height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n    }\n    return { marginTop, marginBottom, selfScroll,\n        height: Math.max(view.defaultLineHeight, height - 5) };\n}\nfunction cursorByPage(view, forward) {\n    let page = pageInfo(view);\n    let { state } = view, selection = updateSel(state.selection, range => {\n        return range.empty ? view.moveVertically(range, forward, page.height)\n            : rangeEnd(range, forward);\n    });\n    if (selection.eq(state.selection))\n        return false;\n    let effect;\n    if (page.selfScroll) {\n        let startPos = view.coordsAtPos(state.selection.main.head);\n        let scrollRect = view.scrollDOM.getBoundingClientRect();\n        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;\n        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)\n            effect = EditorView.scrollIntoView(selection.main.head, { y: \"start\", yMargin: startPos.top - scrollTop });\n    }\n    view.dispatch(setSel(state, selection), { effects: effect });\n    return true;\n}\n/**\nMove the selection one page up.\n*/\nconst cursorPageUp = view => cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/\nconst cursorPageDown = view => cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))\n        moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space)\n            moved = EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/\nconst cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/\nconst cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/\nconst cursorLineStart = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/\nconst cursorLineEnd = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, range => {\n        let matching = matchBrackets(state, range.head, -1)\n            || matchBrackets(state, range.head, 1)\n            || (range.head > 0 && matchBrackets(state, range.head - 1, 1))\n            || (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1));\n        if (!matching || !matching.end)\n            return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);\n    });\n    if (!found)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\nconst cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\nconst selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);\nfunction extendSel(target, how) {\n    let selection = updateSel(target.state.selection, range => {\n        let head = how(range);\n        return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n    });\n    if (selection.eq(target.state.selection))\n        return false;\n    target.dispatch(setSel(target.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, range => view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\nconst selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/\nconst selectCharRight = view => selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/\nconst selectCharForward = view => selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/\nconst selectCharBackward = view => selectByChar(view, false);\n/**\nMove the selection head one character forward by logical\n(non-direction aware) string index order.\n*/\nconst selectCharForwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, true));\n/**\nMove the selection head one character backward by logical string\nindex order.\n*/\nconst selectCharBackwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, false));\nfunction selectByGroup(view, forward) {\n    return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\nconst selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/\nconst selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/\nconst selectGroupForward = view => selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/\nconst selectGroupBackward = view => selectByGroup(view, false);\nfunction selectBySubword(view, forward) {\n    return extendSel(view, range => moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\nconst selectSubwordForward = view => selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/\nconst selectSubwordBackward = view => selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/\nconst selectLineUp = view => selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/\nconst selectLineDown = view => selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/\nconst selectPageUp = view => selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/\nconst selectPageDown = view => selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/\nconst selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/\nconst selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/\nconst selectLineStart = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/\nconst selectLineEnd = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/\nconst cursorDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: 0 }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/\nconst cursorDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.doc.length }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\nconst selectDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\nconst selectDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));\n    return true;\n};\n/**\nSelect the entire document.\n*/\nconst selectAll = ({ state, dispatch }) => {\n    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: \"select\" }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\nconst selectLine = ({ state, dispatch }) => {\n    let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: \"select\" }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\nconst selectParentSyntax = ({ state, dispatch }) => {\n    let selection = updateSel(state.selection, range => {\n        let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);\n        if (range.empty) {\n            let stackBefore = tree.resolveStack(range.from, -1);\n            if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)\n                stack = stackBefore;\n        }\n        for (let cur = stack; cur; cur = cur.next) {\n            let { node } = cur;\n            if (((node.from < range.from && node.to >= range.to) ||\n                (node.to > range.to && node.from <= range.from)) &&\n                cur.next)\n                return EditorSelection.range(node.to, node.from);\n        }\n        return range;\n    });\n    if (selection.eq(state.selection))\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\nconst simplifySelection = ({ state, dispatch }) => {\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1)\n        selection = EditorSelection.create([cur.main]);\n    else if (!cur.main.empty)\n        selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);\n    if (!selection)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(target, by) {\n    if (target.state.readOnly)\n        return false;\n    let event = \"delete.selection\", { state } = target;\n    let changes = state.changeByRange(range => {\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(range);\n            if (towards < from) {\n                event = \"delete.backward\";\n                towards = skipAtomic(target, towards, false);\n            }\n            else if (towards > from) {\n                event = \"delete.forward\";\n                towards = skipAtomic(target, towards, true);\n            }\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        }\n        else {\n            from = skipAtomic(target, from, false);\n            to = skipAtomic(target, to, true);\n        }\n        return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };\n    });\n    if (changes.changes.empty)\n        return false;\n    target.dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: event,\n        effects: event == \"delete.selection\" ? EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n    }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof EditorView)\n        for (let ranges of target.state.facet(EditorView.atomicRanges).map(f => f(target)))\n            ranges.between(pos, pos, (from, to) => {\n                if (from < pos && to > pos)\n                    pos = forward ? to : from;\n            });\n    return pos;\n}\nconst deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, range => {\n    let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n    if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 &&\n        !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n        if (before[before.length - 1] == \"\\t\")\n            return pos - 1;\n        let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);\n        for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)\n            pos--;\n        targetPos = pos;\n    }\n    else {\n        targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;\n        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))\n            targetPos += forward ? 1 : -1;\n        else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))\n            targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;\n    }\n    return targetPos;\n});\n/**\nDelete the selection, or, for cursor selections, the character or\nindentation unit before the cursor.\n*/\nconst deleteCharBackward = view => deleteByChar(view, false, true);\n/**\nDelete the selection or the character before the cursor. Does not\nimplement any extended behavior like deleting whole indentation\nunits in one go.\n*/\nconst deleteCharBackwardStrict = view => deleteByChar(view, false, false);\n/**\nDelete the selection or the character after the cursor.\n*/\nconst deleteCharForward = view => deleteByChar(view, true, false);\nconst deleteByGroup = (target, forward) => deleteBy(target, range => {\n    let pos = range.head, { state } = target, line = state.doc.lineAt(pos);\n    let categorize = state.charCategorizer(pos);\n    for (let cat = null;;) {\n        if (pos == (forward ? line.to : line.from)) {\n            if (pos == range.head && line.number != (forward ? state.doc.lines : 1))\n                pos += forward ? 1 : -1;\n            break;\n        }\n        let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;\n        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n        let nextCat = categorize(nextChar);\n        if (cat != null && nextCat != cat)\n            break;\n        if (nextChar != \" \" || pos != range.head)\n            cat = nextCat;\n        pos = next;\n    }\n    return pos;\n});\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\nconst deleteGroupBackward = target => deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/\nconst deleteGroupForward = target => deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\nconst deleteToLineEnd = view => deleteBy(view, range => {\n    let lineEnd = view.lineBlockAt(range.head).to;\n    return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\nconst deleteToLineStart = view => deleteBy(view, range => {\n    let lineStart = view.lineBlockAt(range.head).from;\n    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/\nconst deleteLineBoundaryBackward = view => deleteBy(view, range => {\n    let lineStart = view.moveToLineBoundary(range, false).head;\n    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/\nconst deleteLineBoundaryForward = view => deleteBy(view, range => {\n    let lineStart = view.moveToLineBoundary(range, true).head;\n    return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n});\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\nconst deleteTrailingWhitespace = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = [];\n    for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1)\n                changes.push({ from: pos - (prev.length - trailing), to: pos });\n            if (iter.done)\n                break;\n            prev = \"\";\n        }\n        else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({ changes, userEvent: \"delete\" }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\nconst splitLine = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = state.changeByRange(range => {\n        return { changes: { from: range.from, to: range.to, insert: Text.of([\"\", \"\"]) },\n            range: EditorSelection.cursor(range.from) };\n    });\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\nconst transposeChars = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = state.changeByRange(range => {\n        if (!range.empty || range.from == 0 || range.from == state.doc.length)\n            return { range };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;\n        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },\n            range: EditorSelection.cursor(to) };\n    });\n    if (changes.changes.empty)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"move.character\" }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges) {\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from)\n            endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        }\n        else {\n            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly)\n        return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward ? block.to == state.doc.length : block.from == 0)\n            continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });\n            for (let r of block.ranges)\n                ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        }\n        else {\n            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });\n            for (let r of block.ranges)\n                ranges.push(EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/\nconst moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/\nconst moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly)\n        return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward)\n            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });\n        else\n            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });\n    }\n    dispatch(state.update({ changes, scrollIntoView: true, userEvent: \"input.copyline\" }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\nconst copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\nconst copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/\nconst deleteLine = view => {\n    if (view.state.readOnly)\n        return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {\n        if (from > 0)\n            from--;\n        else if (to < state.doc.length)\n            to++;\n        return { from, to };\n    }));\n    let selection = updateSel(state.selection, range => {\n        let dist = undefined;\n        if (view.lineWrapping) {\n            let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (pos)\n                dist = (block.bottom + view.documentTop) - pos.bottom + view.defaultLineHeight / 2;\n        }\n        return view.moveVertically(range, true, dist);\n    }).map(changes);\n    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: \"delete.line\" });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/\nconst insertNewline = ({ state, dispatch }) => {\n    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nReplace the selection with a newline and the same amount of\nindentation as the line above.\n*/\nconst insertNewlineKeepIndent = ({ state, dispatch }) => {\n    dispatch(state.update(state.changeByRange(range => {\n        let indent = /^\\s*/.exec(state.doc.lineAt(range.from).text)[0];\n        return {\n            changes: { from: range.from, to: range.to, insert: state.lineBreak + indent },\n            range: EditorSelection.cursor(range.from + indent.length + 1)\n        };\n    }), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1)))\n        return { from: pos, to: pos };\n    let context = syntaxTree(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos &&\n        (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&\n        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from &&\n        !/\\S/.test(state.sliceDoc(before.to, after.from)))\n        return { from: before.to, to: after.from };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\nconst insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\nconst insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch }) => {\n        if (state.readOnly)\n            return false;\n        let changes = state.changeByRange(range => {\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof)\n                from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });\n            let indent = getIndentation(cx, from);\n            if (indent == null)\n                indent = countColumn(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n            while (to < line.to && /\\s/.test(line.text[to - line.from]))\n                to++;\n            if (explode)\n                ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from)))\n                from = line.from;\n            let insert = [\"\", indentString(state, indent)];\n            if (explode)\n                insert.push(indentString(state, cx.lineIndent(line.from, -1)));\n            return { changes: { from, to, insert: Text.of(insert) },\n                range: EditorSelection.cursor(from + 1 + insert[1].length) };\n        });\n        dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange(range => {\n        let changes = [];\n        for (let pos = range.from; pos <= range.to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return { changes,\n            range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\nconst indentSelection = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let updated = Object.create(null);\n    let context = new IndentContext(state, { overrideIndentation: start => {\n            let found = updated[start];\n            return found == null ? -1 : found;\n        } });\n    let changes = changeBySelectedLine(state, (line, changes, range) => {\n        let indent = getIndentation(context, line.from);\n        if (indent == null)\n            return;\n        if (!/\\S/.test(line.text))\n            indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n    });\n    if (!changes.changes.empty)\n        dispatch(state.update(changes, { userEvent: \"indent\" }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\nconst indentMore = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        changes.push({ from: line.from, insert: state.facet(indentUnit) });\n    }), { userEvent: \"input.indent\" }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\nconst indentLess = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space)\n            return;\n        let col = countColumn(space, state.tabSize), keep = 0;\n        let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));\n        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))\n            keep++;\n        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });\n    }), { userEvent: \"delete.dedent\" }));\n    return true;\n};\n/**\nEnables or disables\n[tab-focus mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode). While on, this\nprevents the editor's key bindings from capturing Tab or\nShift-Tab, making it possible for the user to move focus out of\nthe editor with the keyboard.\n*/\nconst toggleTabFocusMode = view => {\n    view.setTabFocusMode();\n    return true;\n};\n/**\nTemporarily enables [tab-focus\nmode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode) for two seconds or until\nanother key is pressed.\n*/\nconst temporarilySetTabFocusMode = view => {\n    view.setTabFocusMode(2000);\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\nconst insertTab = ({ state, dispatch }) => {\n    if (state.selection.ranges.some(r => !r.empty))\n        return indentMore({ state, dispatch });\n    dispatch(state.update(state.replaceSelection(\"\\t\"), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\nconst emacsStyleKeymap = [\n    { key: \"Ctrl-b\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\n    { key: \"Ctrl-f\", run: cursorCharRight, shift: selectCharRight },\n    { key: \"Ctrl-p\", run: cursorLineUp, shift: selectLineUp },\n    { key: \"Ctrl-n\", run: cursorLineDown, shift: selectLineDown },\n    { key: \"Ctrl-a\", run: cursorLineStart, shift: selectLineStart },\n    { key: \"Ctrl-e\", run: cursorLineEnd, shift: selectLineEnd },\n    { key: \"Ctrl-d\", run: deleteCharForward },\n    { key: \"Ctrl-h\", run: deleteCharBackward },\n    { key: \"Ctrl-k\", run: deleteToLineEnd },\n    { key: \"Ctrl-Alt-h\", run: deleteGroupBackward },\n    { key: \"Ctrl-o\", run: splitLine },\n    { key: \"Ctrl-t\", run: transposeChars },\n    { key: \"Ctrl-v\", run: cursorPageDown },\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter and Shift-Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/\nconst standardKeymap = /*@__PURE__*/[\n    { key: \"ArrowLeft\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\n    { key: \"Mod-ArrowLeft\", mac: \"Alt-ArrowLeft\", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },\n    { mac: \"Cmd-ArrowLeft\", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },\n    { key: \"ArrowRight\", run: cursorCharRight, shift: selectCharRight, preventDefault: true },\n    { key: \"Mod-ArrowRight\", mac: \"Alt-ArrowRight\", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },\n    { mac: \"Cmd-ArrowRight\", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },\n    { key: \"ArrowUp\", run: cursorLineUp, shift: selectLineUp, preventDefault: true },\n    { mac: \"Cmd-ArrowUp\", run: cursorDocStart, shift: selectDocStart },\n    { mac: \"Ctrl-ArrowUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"ArrowDown\", run: cursorLineDown, shift: selectLineDown, preventDefault: true },\n    { mac: \"Cmd-ArrowDown\", run: cursorDocEnd, shift: selectDocEnd },\n    { mac: \"Ctrl-ArrowDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"PageUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"PageDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"Home\", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },\n    { key: \"Mod-Home\", run: cursorDocStart, shift: selectDocStart },\n    { key: \"End\", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },\n    { key: \"Mod-End\", run: cursorDocEnd, shift: selectDocEnd },\n    { key: \"Enter\", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },\n    { key: \"Mod-a\", run: selectAll },\n    { key: \"Backspace\", run: deleteCharBackward, shift: deleteCharBackward },\n    { key: \"Delete\", run: deleteCharForward },\n    { key: \"Mod-Backspace\", mac: \"Alt-Backspace\", run: deleteGroupBackward },\n    { key: \"Mod-Delete\", mac: \"Alt-Delete\", run: deleteGroupForward },\n    { mac: \"Mod-Backspace\", run: deleteLineBoundaryBackward },\n    { mac: \"Mod-Delete\", run: deleteLineBoundaryForward }\n].concat(/*@__PURE__*/emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n- Ctrl-m (Alt-Shift-m on macOS): [`toggleTabFocusMode`](https://codemirror.net/6/docs/ref/#commands.toggleTabFocusMode).\n*/\nconst defaultKeymap = /*@__PURE__*/[\n    { key: \"Alt-ArrowLeft\", mac: \"Ctrl-ArrowLeft\", run: cursorSyntaxLeft, shift: selectSyntaxLeft },\n    { key: \"Alt-ArrowRight\", mac: \"Ctrl-ArrowRight\", run: cursorSyntaxRight, shift: selectSyntaxRight },\n    { key: \"Alt-ArrowUp\", run: moveLineUp },\n    { key: \"Shift-Alt-ArrowUp\", run: copyLineUp },\n    { key: \"Alt-ArrowDown\", run: moveLineDown },\n    { key: \"Shift-Alt-ArrowDown\", run: copyLineDown },\n    { key: \"Escape\", run: simplifySelection },\n    { key: \"Mod-Enter\", run: insertBlankLine },\n    { key: \"Alt-l\", mac: \"Ctrl-l\", run: selectLine },\n    { key: \"Mod-i\", run: selectParentSyntax, preventDefault: true },\n    { key: \"Mod-[\", run: indentLess },\n    { key: \"Mod-]\", run: indentMore },\n    { key: \"Mod-Alt-\\\\\", run: indentSelection },\n    { key: \"Shift-Mod-k\", run: deleteLine },\n    { key: \"Shift-Mod-\\\\\", run: cursorMatchingBracket },\n    { key: \"Mod-/\", run: toggleComment },\n    { key: \"Alt-A\", run: toggleBlockComment },\n    { key: \"Ctrl-m\", mac: \"Shift-Alt-m\", run: toggleTabFocusMode },\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\nconst indentWithTab = { key: \"Tab\", run: indentMore, shift: indentLess };\n\nexport { blockComment, blockUncomment, copyLineDown, copyLineUp, cursorCharBackward, cursorCharBackwardLogical, cursorCharForward, cursorCharForwardLogical, cursorCharLeft, cursorCharRight, cursorDocEnd, cursorDocStart, cursorGroupBackward, cursorGroupForward, cursorGroupLeft, cursorGroupRight, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorLineBoundaryLeft, cursorLineBoundaryRight, cursorLineDown, cursorLineEnd, cursorLineStart, cursorLineUp, cursorMatchingBracket, cursorPageDown, cursorPageUp, cursorSubwordBackward, cursorSubwordForward, cursorSyntaxLeft, cursorSyntaxRight, defaultKeymap, deleteCharBackward, deleteCharBackwardStrict, deleteCharForward, deleteGroupBackward, deleteGroupForward, deleteLine, deleteLineBoundaryBackward, deleteLineBoundaryForward, deleteToLineEnd, deleteToLineStart, deleteTrailingWhitespace, emacsStyleKeymap, history, historyField, historyKeymap, indentLess, indentMore, indentSelection, indentWithTab, insertBlankLine, insertNewline, insertNewlineAndIndent, insertNewlineKeepIndent, insertTab, invertedEffects, isolateHistory, lineComment, lineUncomment, moveLineDown, moveLineUp, redo, redoDepth, redoSelection, selectAll, selectCharBackward, selectCharBackwardLogical, selectCharForward, selectCharForwardLogical, selectCharLeft, selectCharRight, selectDocEnd, selectDocStart, selectGroupBackward, selectGroupForward, selectGroupLeft, selectGroupRight, selectLine, selectLineBoundaryBackward, selectLineBoundaryForward, selectLineBoundaryLeft, selectLineBoundaryRight, selectLineDown, selectLineEnd, selectLineStart, selectLineUp, selectMatchingBracket, selectPageDown, selectPageUp, selectParentSyntax, selectSubwordBackward, selectSubwordForward, selectSyntaxLeft, selectSyntaxRight, simplifySelection, splitLine, standardKeymap, temporarilySetTabFocusMode, toggleBlockComment, toggleBlockCommentByLine, toggleComment, toggleLineComment, toggleTabFocusMode, transposeChars, undo, undoDepth, undoSelection };\n"]},"metadata":{},"sourceType":"module"}