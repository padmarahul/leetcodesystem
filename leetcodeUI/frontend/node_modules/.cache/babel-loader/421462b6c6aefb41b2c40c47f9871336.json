{"ast":null,"code":"import { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\n\nconst snippets = [/*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n  label: \"function\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n  label: \"for\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n  label: \"for\",\n  detail: \"of loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n  label: \"do\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n  label: \"while\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n  label: \"try\",\n  detail: \"/ catch block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n  label: \"if\",\n  detail: \"block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n  label: \"if\",\n  detail: \"/ else block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n  label: \"class\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n  label: \"import\",\n  detail: \"named\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n  label: \"import\",\n  detail: \"default\",\n  type: \"keyword\"\n})];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/\n\nconst typescriptSnippets = /*@__PURE__*/snippets.concat([/*@__PURE__*/snippetCompletion(\"interface ${name} {\\n\\t${}\\n}\", {\n  label: \"interface\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"type ${name} = ${type}\", {\n  label: \"type\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"enum ${name} {\\n\\t${}\\n}\", {\n  label: \"enum\",\n  detail: \"definition\",\n  type: \"keyword\"\n})]);\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\"Script\", \"Block\", \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\", \"ForStatement\"]);\n\nfunction defID(type) {\n  return (node, def) => {\n    let id = node.node.getChild(\"VariableDefinition\");\n    if (id) def(id, type);\n    return true;\n  };\n}\n\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n  FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n  ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n  ClassExpression: () => true,\n  EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n  TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n  NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n\n  VariableDefinition(node, def) {\n    if (!node.matchContext(functionContext)) def(node, \"variable\");\n  },\n\n  TypeDefinition(node, def) {\n    def(node, \"type\");\n  },\n\n  __proto__: null\n};\n\nfunction getScope(doc, node) {\n  let cached = cache.get(node);\n  if (cached) return cached;\n  let completions = [],\n      top = true;\n\n  function def(node, type) {\n    let name = doc.sliceString(node.from, node.to);\n    completions.push({\n      label: name,\n      type\n    });\n  }\n\n  node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n    if (top) {\n      top = false;\n    } else if (node.name) {\n      let gather = gatherCompletions[node.name];\n      if (gather && gather(node, def) || ScopeNodes.has(node.name)) return false;\n    } else if (node.to - node.from > 8192) {\n      // Allow caching for bigger internal nodes\n      for (let c of getScope(doc, node.node)) completions.push(c);\n\n      return false;\n    }\n  });\n  cache.set(node, completions);\n  return completions;\n}\n\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\"TemplateString\", \"String\", \"RegExp\", \"LineComment\", \"BlockComment\", \"VariableDefinition\", \"TypeDefinition\", \"Label\", \"PropertyDefinition\", \"PropertyName\", \"PrivatePropertyDefinition\", \"PrivatePropertyName\", \".\", \"?.\"];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\n\nfunction localCompletionSource(context) {\n  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n  if (dontComplete.indexOf(inner.name) > -1) return null;\n  let isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n  if (!isWord && !context.explicit) return null;\n  let options = [];\n\n  for (let pos = inner; pos; pos = pos.parent) {\n    if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n  }\n\n  return {\n    options,\n    from: isWord ? inner.from : context.pos,\n    validFor: Identifier\n  };\n}\n\nfunction pathFor(read, member, name) {\n  var _a;\n\n  let path = [];\n\n  for (;;) {\n    let obj = member.firstChild,\n        prop;\n\n    if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n      path.push(read(obj));\n      return {\n        path: path.reverse(),\n        name\n      };\n    } else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = prop = obj.lastChild) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n      path.push(read(prop));\n      member = obj;\n    } else {\n      return null;\n    }\n  }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\n\n\nfunction completionPath(context) {\n  let read = node => context.state.doc.sliceString(node.from, node.to);\n\n  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n\n  if (inner.name == \"PropertyName\") {\n    return pathFor(read, inner.parent, read(inner));\n  } else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n    return pathFor(read, inner.parent, \"\");\n  } else if (dontComplete.indexOf(inner.name) > -1) {\n    return null;\n  } else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n    return {\n      path: [],\n      name: read(inner)\n    };\n  } else if (inner.name == \"MemberExpression\") {\n    return pathFor(read, inner, \"\");\n  } else {\n    return context.explicit ? {\n      path: [],\n      name: \"\"\n    } : null;\n  }\n}\n\nfunction enumeratePropertyCompletions(obj, top) {\n  let options = [],\n      seen = new Set();\n\n  for (let depth = 0;; depth++) {\n    for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n      if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name)) continue;\n      seen.add(name);\n      let value;\n\n      try {\n        value = obj[name];\n      } catch (_) {\n        continue;\n      }\n\n      options.push({\n        label: name,\n        type: typeof value == \"function\" ? /^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\" : top ? \"variable\" : \"property\",\n        boost: -depth\n      });\n    }\n\n    let next = Object.getPrototypeOf(obj);\n    if (!next) return options;\n    obj = next;\n  }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\n\n\nfunction scopeCompletionSource(scope) {\n  let cache = new Map();\n  return context => {\n    let path = completionPath(context);\n    if (!path) return null;\n    let target = scope;\n\n    for (let step of path.path) {\n      target = target[step];\n      if (!target) return null;\n    }\n\n    let options = cache.get(target);\n    if (!options) cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n    return {\n      from: context.pos - path.name.length,\n      options,\n      validFor: Identifier\n    };\n  };\n}\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\n\n\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n  name: \"javascript\",\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      IfStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|else\\b)/\n      }),\n      TryStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|catch\\b|finally\\b)/\n      }),\n      LabeledStatement: flatIndent,\n      SwitchBody: context => {\n        let after = context.textAfter,\n            closed = /^\\s*\\}/.test(after),\n            isCase = /^\\s*(case|default)\\b/.test(after);\n        return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n      },\n      Block: /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      ArrowFunction: cx => cx.baseIndent + cx.unit,\n      \"TemplateString BlockComment\": () => null,\n      \"Statement Property\": /*@__PURE__*/continuedIndent({\n        except: /^{/\n      }),\n\n      JSXElement(context) {\n        let closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n\n      JSXEscape(context) {\n        let closed = /\\s*\\}/.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n\n      \"JSXOpenTag JSXSelfClosingTag\"(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n\n      BlockComment(tree) {\n        return {\n          from: tree.from + 2,\n          to: tree.to - 2\n        };\n      }\n\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"]\n    },\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    },\n    indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n    wordChars: \"$\"\n  }\n});\nconst jsxSublanguage = {\n  test: node => /^JSX/.test(node.name),\n  facet: /*@__PURE__*/defineLanguageFacet({\n    commentTokens: {\n      block: {\n        open: \"{/*\",\n        close: \"*/}\"\n      }\n    }\n  })\n};\n/**\nA language provider for TypeScript.\n*/\n\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"ts\"\n}, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\n\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"jsx\",\n  props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\n\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"jsx ts\",\n  props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\n\nlet kwCompletion = name => ({\n  label: name,\n  type: \"keyword\"\n});\n\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/keywords.concat( /*@__PURE__*/[\"declare\", \"implements\", \"private\", \"protected\", \"public\"].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\nand local variable completion.\n*/\n\nfunction javascript(config = {}) {\n  let lang = config.jsx ? config.typescript ? tsxLanguage : jsxLanguage : config.typescript ? typescriptLanguage : javascriptLanguage;\n  let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n  return new LanguageSupport(lang, [javascriptLanguage.data.of({\n    autocomplete: ifNotIn(dontComplete, completeFromList(completions))\n  }), javascriptLanguage.data.of({\n    autocomplete: localCompletionSource\n  }), config.jsx ? autoCloseTags : []]);\n}\n\nfunction findOpenTag(node) {\n  for (;;) {\n    if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\") return node;\n    if (node.name == \"JSXEscape\" || !node.parent) return null;\n    node = node.parent;\n  }\n}\n\nfunction elementName(doc, tree, max = doc.length) {\n  for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n    if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" || ch.name == \"JSXMemberExpression\") return doc.sliceString(ch.from, Math.min(ch.to, max));\n  }\n\n  return \"\";\n}\n\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\n\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {\n  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly || from != to || text != \">\" && text != \"/\" || !javascriptLanguage.isActiveAt(view.state, from, -1)) return false;\n  let base = defaultInsert(),\n      {\n    state\n  } = base;\n  let closeTags = state.changeByRange(range => {\n    var _a;\n\n    let {\n      head\n    } = range,\n        around = syntaxTree(state).resolveInner(head - 1, -1),\n        name;\n    if (around.name == \"JSXStartTag\") around = around.parent;\n    if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n      return {\n        range,\n        changes: {\n          from: head,\n          insert: `</>`\n        }\n      };\n    } else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n      let empty = around.parent,\n          base = empty.parent;\n\n      if (base && empty.from == head - 2 && ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n        let insert = `${name}>`;\n        return {\n          range: EditorSelection.cursor(head + insert.length, -1),\n          changes: {\n            from: head,\n            insert\n          }\n        };\n      }\n    } else if (text == \">\") {\n      let openTag = findOpenTag(around);\n      if (openTag && openTag.name == \"JSXOpenTag\" && !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) && (name = elementName(state.doc, openTag, head))) return {\n        range,\n        changes: {\n          from: head,\n          insert: `</${name}>`\n        }\n      };\n    }\n    return {\n      range\n    };\n  });\n  if (closeTags.changes.empty) return false;\n  view.dispatch([base, state.update(closeTags, {\n    userEvent: \"input.complete\",\n    scrollIntoView: true\n  })]);\n  return true;\n});\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\n\nfunction esLint(eslint, config) {\n  if (!config) {\n    config = {\n      parserOptions: {\n        ecmaVersion: 2019,\n        sourceType: \"module\"\n      },\n      env: {\n        browser: true,\n        node: true,\n        es6: true,\n        es2015: true,\n        es2017: true,\n        es2020: true\n      },\n      rules: {}\n    };\n    eslint.getRules().forEach((desc, name) => {\n      if (desc.meta.docs.recommended) config.rules[name] = 2;\n    });\n  }\n\n  return view => {\n    let {\n      state\n    } = view,\n        found = [];\n\n    for (let {\n      from,\n      to\n    } of javascriptLanguage.findRegions(state)) {\n      let fromLine = state.doc.lineAt(from),\n          offset = {\n        line: fromLine.number - 1,\n        col: from - fromLine.from,\n        pos: from\n      };\n\n      for (let d of eslint.verify(state.sliceDoc(from, to), config)) found.push(translateDiagnostic(d, state.doc, offset));\n    }\n\n    return found;\n  };\n}\n\nfunction mapPos(line, col, doc, offset) {\n  return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\n\nfunction translateDiagnostic(input, doc, offset) {\n  let start = mapPos(input.line, input.column, doc, offset);\n  let result = {\n    from: start,\n    to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n    message: input.message,\n    source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n    severity: input.severity == 1 ? \"warning\" : \"error\"\n  };\n\n  if (input.fix) {\n    let {\n      range,\n      text\n    } = input.fix,\n        from = range[0] + offset.pos - start,\n        to = range[1] + offset.pos - start;\n    result.actions = [{\n      name: \"fix\",\n\n      apply(view, start) {\n        view.dispatch({\n          changes: {\n            from: start + from,\n            to: start + to,\n            insert: text\n          },\n          scrollIntoView: true\n        });\n      }\n\n    }];\n  }\n\n  return result;\n}\n\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage, typescriptSnippets };","map":{"version":3,"sources":["/Users/sairahulpadma/Desktop/leetcodesystem/leetcodeUI/frontend/node_modules/@codemirror/lang-javascript/dist/index.js"],"names":["parser","syntaxTree","LRLanguage","indentNodeProp","continuedIndent","flatIndent","delimitedIndent","foldNodeProp","foldInside","defineLanguageFacet","sublanguageProp","LanguageSupport","EditorSelection","EditorView","snippetCompletion","ifNotIn","completeFromList","NodeWeakMap","IterMode","snippets","label","detail","type","typescriptSnippets","concat","cache","ScopeNodes","Set","defID","node","def","id","getChild","functionContext","gatherCompletions","FunctionDeclaration","ClassDeclaration","ClassExpression","EnumDeclaration","TypeAliasDeclaration","NamespaceDeclaration","VariableDefinition","matchContext","TypeDefinition","__proto__","getScope","doc","cached","get","completions","top","name","sliceString","from","to","push","cursor","IncludeAnonymous","iterate","gather","has","c","set","Identifier","dontComplete","localCompletionSource","context","inner","state","resolveInner","pos","indexOf","isWord","test","sliceDoc","explicit","options","parent","validFor","pathFor","read","member","_a","path","obj","firstChild","prop","reverse","lastChild","completionPath","enumeratePropertyCompletions","seen","depth","Object","getOwnPropertyNames","keys","add","value","_","boost","next","getPrototypeOf","scopeCompletionSource","scope","Map","target","step","length","javascriptLanguage","define","configure","props","IfStatement","except","TryStatement","LabeledStatement","SwitchBody","after","textAfter","closed","isCase","baseIndent","unit","Block","closing","ArrowFunction","cx","JSXElement","lineIndent","JSXEscape","column","BlockComment","tree","languageData","closeBrackets","brackets","commentTokens","line","block","open","close","indentOnInput","wordChars","jsxSublanguage","facet","typescriptLanguage","dialect","jsxLanguage","n","isTop","undefined","tsxLanguage","kwCompletion","keywords","split","map","typescriptKeywords","javascript","config","lang","jsx","typescript","data","of","autocomplete","autoCloseTags","findOpenTag","elementName","max","ch","nextSibling","Math","min","android","navigator","userAgent","inputHandler","view","text","defaultInsert","composing","compositionStarted","readOnly","isActiveAt","base","closeTags","changeByRange","range","head","around","changes","insert","empty","openTag","dispatch","update","userEvent","scrollIntoView","esLint","eslint","parserOptions","ecmaVersion","sourceType","env","browser","es6","es2015","es2017","es2020","rules","getRules","forEach","desc","meta","docs","recommended","found","findRegions","fromLine","lineAt","offset","number","col","d","verify","translateDiagnostic","mapPos","input","start","result","endLine","endColumn","message","source","ruleId","severity","fix","actions","apply"],"mappings":"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","sourcesContent":["import { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [\n    /*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/\nconst typescriptSnippets = /*@__PURE__*/snippets.concat([\n    /*@__PURE__*/snippetCompletion(\"interface ${name} {\\n\\t${}\\n}\", {\n        label: \"interface\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"type ${name} = ${type}\", {\n        label: \"type\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"enum ${name} {\\n\\t${}\\n}\", {\n        label: \"enum\",\n        detail: \"definition\",\n        type: \"keyword\"\n    })\n]);\n\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Block\",\n    \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def) => {\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n    ClassExpression: () => true,\n    EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n    VariableDefinition(node, def) { if (!node.matchContext(functionContext))\n        def(node, \"variable\"); },\n    TypeDefinition(node, def) { def(node, \"type\"); },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n        if (top) {\n            top = false;\n        }\n        else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name))\n                return false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\", \"String\", \"RegExp\",\n    \"LineComment\", \"BlockComment\",\n    \"VariableDefinition\", \"TypeDefinition\", \"Label\",\n    \"PropertyDefinition\", \"PropertyName\",\n    \"PrivatePropertyDefinition\", \"PrivatePropertyName\",\n    \".\", \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for (;;) {\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return { path: path.reverse(), name };\n        }\n        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        }\n        else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n    let read = (node) => context.state.doc.sliceString(node.from, node.to);\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    }\n    else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    }\n    else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    }\n    else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return { path: [], name: read(inner) };\n    }\n    else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    }\n    else {\n        return context.explicit ? { path: [], name: \"\" } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for (let depth = 0;; depth++) {\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n            if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name))\n                continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            }\n            catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? (/^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\")\n                    : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next)\n            return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context) => {\n        let path = completionPath(context);\n        if (!path)\n            return null;\n        let target = scope;\n        for (let step of path.path) {\n            target = target[step];\n            if (!target)\n                return null;\n        }\n        let options = cache.get(target);\n        if (!options)\n            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                IfStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|catch\\b|finally\\b)/ }),\n                LabeledStatement: flatIndent,\n                SwitchBody: context => {\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                ArrowFunction: cx => cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": () => null,\n                \"Statement Property\": /*@__PURE__*/continuedIndent({ except: /^{/ }),\n                JSXElement(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape(context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] },\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: node => /^JSX/.test(node.name),\n    facet: /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"{/*\", close: \"*/}\" } } })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({ dialect: \"ts\" }, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nlet kwCompletion = (name) => ({ label: name, type: \"keyword\" });\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/keywords.concat(/*@__PURE__*/[\"declare\", \"implements\", \"private\", \"protected\", \"public\"].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\nand local variable completion.\n*/\nfunction javascript(config = {}) {\n    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)\n        : config.typescript ? typescriptLanguage : javascriptLanguage;\n    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n    return new LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: ifNotIn(dontComplete, completeFromList(completions))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : [],\n    ]);\n}\nfunction findOpenTag(node) {\n    for (;;) {\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\")\n            return node;\n        if (node.name == \"JSXEscape\" || !node.parent)\n            return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" ||\n            ch.name == \"JSXMemberExpression\")\n            return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly ||\n        from != to || (text != \">\" && text != \"/\") ||\n        !javascriptLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let base = defaultInsert(), { state } = base;\n    let closeTags = state.changeByRange(range => {\n        var _a;\n        let { head } = range, around = syntaxTree(state).resolveInner(head - 1, -1), name;\n        if (around.name == \"JSXStartTag\")\n            around = around.parent;\n        if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return { range, changes: { from: head, insert: `</>` } };\n        }\n        else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n            let empty = around.parent, base = empty.parent;\n            if (base && empty.from == head - 2 &&\n                ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n                let insert = `${name}>`;\n                return { range: EditorSelection.cursor(head + insert.length, -1), changes: { from: head, insert } };\n            }\n        }\n        else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && openTag.name == \"JSXOpenTag\" &&\n                !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) &&\n                (name = elementName(state.doc, openTag, head)))\n                return { range, changes: { from: head, insert: `</${name}>` } };\n        }\n        return { range };\n    });\n    if (closeTags.changes.empty)\n        return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, { userEvent: \"input.complete\", scrollIntoView: true })\n    ]);\n    return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: { ecmaVersion: 2019, sourceType: \"module\" },\n            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name) => {\n            if (desc.meta.docs.recommended)\n                config.rules[name] = 2;\n        });\n    }\n    return (view) => {\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)) {\n            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))\n                found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\",\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [{\n                name: \"fix\",\n                apply(view, start) {\n                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });\n                }\n            }];\n    }\n    return result;\n}\n\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage, typescriptSnippets };\n"]},"metadata":{},"sourceType":"module"}