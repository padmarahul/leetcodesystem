{"ast":null,"code":"import { Annotation, Facet, combineConfig, StateField, Transaction, ChangeSet, ChangeDesc, EditorSelection, StateEffect, Text, findClusterBreak, countColumn, CharCategory } from '@codemirror/state';\nimport { EditorView, Direction } from '@codemirror/view';\nimport { IndentContext, getIndentation, indentString, matchBrackets, syntaxTree, getIndentUnit, indentUnit } from '@codemirror/language';\nimport { NodeProp } from '@lezer/common';\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\n\nconst toggleComment = target => {\n  let {\n    state\n  } = target,\n      line = state.doc.lineAt(state.selection.main.from),\n      config = getConfig(target.state, line.from);\n  return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\n\nfunction command(f, option) {\n  return ({\n    state,\n    dispatch\n  }) => {\n    if (state.readOnly) return false;\n    let tr = f(option, state);\n    if (!tr) return false;\n    dispatch(state.update(tr));\n    return true;\n  };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\n\n\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0\n/* CommentOption.Toggle */\n);\n/**\nComment the current selection using line comments.\n*/\n\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1\n/* CommentOption.Comment */\n);\n/**\nUncomment the current selection using line comments.\n*/\n\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2\n/* CommentOption.Uncomment */\n);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\n\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0\n/* CommentOption.Toggle */\n);\n/**\nComment the current selection using block comments.\n*/\n\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1\n/* CommentOption.Comment */\n);\n/**\nUncomment the current selection using block comments.\n*/\n\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2\n/* CommentOption.Uncomment */\n);\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/\n\nconst toggleBlockCommentByLine = /*@__PURE__*/command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0\n/* CommentOption.Toggle */\n);\n\nfunction getConfig(state, pos) {\n  let data = state.languageDataAt(\"commentTokens\", pos);\n  return data.length ? data[0] : {};\n}\n\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\n\nfunction findBlockComment(state, {\n  open,\n  close\n}, from, to) {\n  let textBefore = state.sliceDoc(from - SearchMargin, from);\n  let textAfter = state.sliceDoc(to, to + SearchMargin);\n  let spaceBefore = /\\s*$/.exec(textBefore)[0].length,\n      spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n  let beforeOff = textBefore.length - spaceBefore;\n\n  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n    return {\n      open: {\n        pos: from - spaceBefore,\n        margin: spaceBefore && 1\n      },\n      close: {\n        pos: to + spaceAfter,\n        margin: spaceAfter && 1\n      }\n    };\n  }\n\n  let startText, endText;\n\n  if (to - from <= 2 * SearchMargin) {\n    startText = endText = state.sliceDoc(from, to);\n  } else {\n    startText = state.sliceDoc(from, from + SearchMargin);\n    endText = state.sliceDoc(to - SearchMargin, to);\n  }\n\n  let startSpace = /^\\s*/.exec(startText)[0].length,\n      endSpace = /\\s*$/.exec(endText)[0].length;\n  let endOff = endText.length - endSpace - close.length;\n\n  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n    return {\n      open: {\n        pos: from + startSpace + open.length,\n        margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n      },\n      close: {\n        pos: to - endSpace - close.length,\n        margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n      }\n    };\n  }\n\n  return null;\n}\n\nfunction selectedLineRanges(state) {\n  let ranges = [];\n\n  for (let r of state.selection.ranges) {\n    let fromLine = state.doc.lineAt(r.from);\n    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n    if (toLine.from > fromLine.from && toLine.from == r.to) toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;else ranges.push({\n      from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length,\n      to: toLine.to\n    });\n  }\n\n  return ranges;\n} // Performs toggle, comment and uncomment of block comments in\n// languages that support them.\n\n\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n  let tokens = ranges.map(r => getConfig(state, r.from).block);\n  if (!tokens.every(c => c)) return null;\n  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n\n  if (option != 2\n  /* CommentOption.Uncomment */\n  && !comments.every(c => c)) {\n    return {\n      changes: state.changes(ranges.map((range, i) => {\n        if (comments[i]) return [];\n        return [{\n          from: range.from,\n          insert: tokens[i].open + \" \"\n        }, {\n          from: range.to,\n          insert: \" \" + tokens[i].close\n        }];\n      }))\n    };\n  } else if (option != 1\n  /* CommentOption.Comment */\n  && comments.some(c => c)) {\n    let changes = [];\n\n    for (let i = 0, comment; i < comments.length; i++) if (comment = comments[i]) {\n      let token = tokens[i],\n          {\n        open,\n        close\n      } = comment;\n      changes.push({\n        from: open.pos - token.open.length,\n        to: open.pos + open.margin\n      }, {\n        from: close.pos - close.margin,\n        to: close.pos + token.close.length\n      });\n    }\n\n    return {\n      changes\n    };\n  }\n\n  return null;\n} // Performs toggle, comment and uncomment of line comments.\n\n\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n  let lines = [];\n  let prevLine = -1;\n\n  for (let {\n    from,\n    to\n  } of ranges) {\n    let startI = lines.length,\n        minIndent = 1e9;\n    let token = getConfig(state, from).line;\n    if (!token) continue;\n\n    for (let pos = from; pos <= to;) {\n      let line = state.doc.lineAt(pos);\n\n      if (line.from > prevLine && (from == to || to > line.from)) {\n        prevLine = line.from;\n        let indent = /^\\s*/.exec(line.text)[0].length;\n        let empty = indent == line.length;\n        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n        if (indent < line.text.length && indent < minIndent) minIndent = indent;\n        lines.push({\n          line,\n          comment,\n          token,\n          indent,\n          empty,\n          single: false\n        });\n      }\n\n      pos = line.to + 1;\n    }\n\n    if (minIndent < 1e9) for (let i = startI; i < lines.length; i++) if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n    if (lines.length == startI + 1) lines[startI].single = true;\n  }\n\n  if (option != 2\n  /* CommentOption.Uncomment */\n  && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n    let changes = [];\n\n    for (let {\n      line,\n      token,\n      indent,\n      empty,\n      single\n    } of lines) if (single || !empty) changes.push({\n      from: line.from + indent,\n      insert: token + \" \"\n    });\n\n    let changeSet = state.changes(changes);\n    return {\n      changes: changeSet,\n      selection: state.selection.map(changeSet, 1)\n    };\n  } else if (option != 1\n  /* CommentOption.Comment */\n  && lines.some(l => l.comment >= 0)) {\n    let changes = [];\n\n    for (let {\n      line,\n      comment,\n      token\n    } of lines) if (comment >= 0) {\n      let from = line.from + comment,\n          to = from + token.length;\n      if (line.text[to - line.from] == \" \") to++;\n      changes.push({\n        from,\n        to\n      });\n    }\n\n    return {\n      changes\n    };\n  }\n\n  return null;\n}\n\nconst fromHistory = /*@__PURE__*/Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\n\nconst isolateHistory = /*@__PURE__*/Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\n\nconst invertedEffects = /*@__PURE__*/Facet.define();\nconst historyConfig = /*@__PURE__*/Facet.define({\n  combine(configs) {\n    return combineConfig(configs, {\n      minDepth: 100,\n      newGroupDelay: 500,\n      joinToEvent: (_t, isAdjacent) => isAdjacent\n    }, {\n      minDepth: Math.max,\n      newGroupDelay: Math.min,\n      joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)\n    });\n  }\n\n});\nconst historyField_ = /*@__PURE__*/StateField.define({\n  create() {\n    return HistoryState.empty;\n  },\n\n  update(state, tr) {\n    let config = tr.state.facet(historyConfig);\n    let fromHist = tr.annotation(fromHistory);\n\n    if (fromHist) {\n      let item = HistEvent.fromTransaction(tr, fromHist.selection),\n          from = fromHist.side;\n      let other = from == 0\n      /* BranchName.Done */\n      ? state.undone : state.done;\n      if (item) other = updateBranch(other, other.length, config.minDepth, item);else other = addSelection(other, tr.startState.selection);\n      return new HistoryState(from == 0\n      /* BranchName.Done */\n      ? fromHist.rest : other, from == 0\n      /* BranchName.Done */\n      ? other : fromHist.rest);\n    }\n\n    let isolate = tr.annotation(isolateHistory);\n    if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n    if (tr.annotation(Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n    let event = HistEvent.fromTransaction(tr);\n    let time = tr.annotation(Transaction.time),\n        userEvent = tr.annotation(Transaction.userEvent);\n    if (event) state = state.addChanges(event, time, userEvent, config, tr);else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n    if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n    return state;\n  },\n\n  toJSON(value) {\n    return {\n      done: value.done.map(e => e.toJSON()),\n      undone: value.undone.map(e => e.toJSON())\n    };\n  },\n\n  fromJSON(json) {\n    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n  }\n\n});\n/**\nCreate a history extension with the given configuration.\n*/\n\nfunction history(config = {}) {\n  return [historyField_, historyConfig.of(config), EditorView.domEventHandlers({\n    beforeinput(e, view) {\n      let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n      if (!command) return false;\n      e.preventDefault();\n      return command(view);\n    }\n\n  })];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\n\n\nconst historyField = historyField_;\n\nfunction cmd(side, selection) {\n  return function ({\n    state,\n    dispatch\n  }) {\n    if (!selection && state.readOnly) return false;\n    let historyState = state.field(historyField_, false);\n    if (!historyState) return false;\n    let tr = historyState.pop(side, state, selection);\n    if (!tr) return false;\n    dispatch(tr);\n    return true;\n  };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\n\n\nconst undo = /*@__PURE__*/cmd(0\n/* BranchName.Done */\n, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\n\nconst redo = /*@__PURE__*/cmd(1\n/* BranchName.Undone */\n, false);\n/**\nUndo a change or selection change.\n*/\n\nconst undoSelection = /*@__PURE__*/cmd(0\n/* BranchName.Done */\n, true);\n/**\nRedo a change or selection change.\n*/\n\nconst redoSelection = /*@__PURE__*/cmd(1\n/* BranchName.Undone */\n, true);\n\nfunction depth(side) {\n  return function (state) {\n    let histState = state.field(historyField_, false);\n    if (!histState) return 0;\n    let branch = side == 0\n    /* BranchName.Done */\n    ? histState.done : histState.undone;\n    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n  };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\n\n\nconst undoDepth = /*@__PURE__*/depth(0\n/* BranchName.Done */\n);\n/**\nThe amount of redoable change events available in a given state.\n*/\n\nconst redoDepth = /*@__PURE__*/depth(1\n/* BranchName.Undone */\n); // History events store groups of changes or effects that need to be\n// undone/redone together.\n\nclass HistEvent {\n  constructor( // The changes in this event. Normal events hold at least one\n  // change or effect. But it may be necessary to store selection\n  // events before the first change, in which case a special type of\n  // instance is created which doesn't hold any changes, with\n  // changes == startSelection == undefined\n  changes, // The effects associated with this event\n  effects, // Accumulated mapping (from addToHistory==false) that should be\n  // applied to events below this one.\n  mapped, // The selection before this event\n  startSelection, // Stores selection changes after this event, to be used for\n  // selection undo/redo.\n  selectionsAfter) {\n    this.changes = changes;\n    this.effects = effects;\n    this.mapped = mapped;\n    this.startSelection = startSelection;\n    this.selectionsAfter = selectionsAfter;\n  }\n\n  setSelAfter(after) {\n    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n  }\n\n  toJSON() {\n    var _a, _b, _c;\n\n    return {\n      changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n      selectionsAfter: this.selectionsAfter.map(s => s.toJSON())\n    };\n  }\n\n  static fromJSON(json) {\n    return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));\n  } // This does not check `addToHistory` and such, it assumes the\n  // transaction needs to be converted to an item. Returns null when\n  // there are no changes or effects in the transaction.\n\n\n  static fromTransaction(tr, selection) {\n    let effects = none;\n\n    for (let invert of tr.startState.facet(invertedEffects)) {\n      let result = invert(tr);\n      if (result.length) effects = effects.concat(result);\n    }\n\n    if (!effects.length && tr.changes.empty) return null;\n    return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n  }\n\n  static selection(selections) {\n    return new HistEvent(undefined, none, undefined, undefined, selections);\n  }\n\n}\n\nfunction updateBranch(branch, to, maxLen, newEvent) {\n  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n  let newBranch = branch.slice(start, to);\n  newBranch.push(newEvent);\n  return newBranch;\n}\n\nfunction isAdjacent(a, b) {\n  let ranges = [],\n      isAdjacent = false;\n  a.iterChangedRanges((f, t) => ranges.push(f, t));\n  b.iterChangedRanges((_f, _t, f, t) => {\n    for (let i = 0; i < ranges.length;) {\n      let from = ranges[i++],\n          to = ranges[i++];\n      if (t >= from && f <= to) isAdjacent = true;\n    }\n  });\n  return isAdjacent;\n}\n\nfunction eqSelectionShape(a, b) {\n  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\n\nfunction conc(a, b) {\n  return !a.length ? b : !b.length ? a : a.concat(b);\n}\n\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\n\nfunction addSelection(branch, selection) {\n  if (!branch.length) {\n    return [HistEvent.selection([selection])];\n  } else {\n    let lastEvent = branch[branch.length - 1];\n    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n    if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n    sels.push(selection);\n    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n  }\n} // Assumes the top item has one or more selectionAfter values\n\n\nfunction popSelection(branch) {\n  let last = branch[branch.length - 1];\n  let newBranch = branch.slice();\n  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n  return newBranch;\n} // Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\n\n\nfunction addMappingToBranch(branch, mapping) {\n  if (!branch.length) return branch;\n  let length = branch.length,\n      selections = none;\n\n  while (length) {\n    let event = mapEvent(branch[length - 1], mapping, selections);\n\n    if (event.changes && !event.changes.empty || event.effects.length) {\n      // Event survived mapping\n      let result = branch.slice(0, length);\n      result[length - 1] = event;\n      return result;\n    } else {\n      // Drop this event, since there's no changes or effects left\n      mapping = event.mapped;\n      length--;\n      selections = event.selectionsAfter;\n    }\n  }\n\n  return selections.length ? [HistEvent.selection(selections)] : none;\n}\n\nfunction mapEvent(event, mapping, extraSelections) {\n  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections); // Change-less events don't store mappings (they are always the last event in a branch)\n\n  if (!event.changes) return HistEvent.selection(selections);\n  let mappedChanges = event.changes.map(mapping),\n      before = mapping.mapDesc(event.changes, true);\n  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\n\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\n\nclass HistoryState {\n  constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n    this.done = done;\n    this.undone = undone;\n    this.prevTime = prevTime;\n    this.prevUserEvent = prevUserEvent;\n  }\n\n  isolate() {\n    return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n  }\n\n  addChanges(event, time, userEvent, config, tr) {\n    let done = this.done,\n        lastEvent = done[done.length - 1];\n\n    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event\n    userEvent == \"input.type.compose\")) {\n      done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n    } else {\n      done = updateBranch(done, done.length, config.minDepth, event);\n    }\n\n    return new HistoryState(done, none, time, userEvent);\n  }\n\n  addSelection(selection, time, userEvent, newGroupDelay) {\n    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n    return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n  }\n\n  addMapping(mapping) {\n    return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n  }\n\n  pop(side, state, onlySelection) {\n    let branch = side == 0\n    /* BranchName.Done */\n    ? this.done : this.undone;\n    if (branch.length == 0) return null;\n    let event = branch[branch.length - 1],\n        selection = event.selectionsAfter[0] || state.selection;\n\n    if (onlySelection && event.selectionsAfter.length) {\n      return state.update({\n        selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n        annotations: fromHistory.of({\n          side,\n          rest: popSelection(branch),\n          selection\n        }),\n        userEvent: side == 0\n        /* BranchName.Done */\n        ? \"select.undo\" : \"select.redo\",\n        scrollIntoView: true\n      });\n    } else if (!event.changes) {\n      return null;\n    } else {\n      let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n      if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n      return state.update({\n        changes: event.changes,\n        selection: event.startSelection,\n        effects: event.effects,\n        annotations: fromHistory.of({\n          side,\n          rest,\n          selection\n        }),\n        filter: false,\n        userEvent: side == 0\n        /* BranchName.Done */\n        ? \"undo\" : \"redo\",\n        scrollIntoView: true\n      });\n    }\n  }\n\n}\n\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/\n\nconst historyKeymap = [{\n  key: \"Mod-z\",\n  run: undo,\n  preventDefault: true\n}, {\n  key: \"Mod-y\",\n  mac: \"Mod-Shift-z\",\n  run: redo,\n  preventDefault: true\n}, {\n  linux: \"Ctrl-Shift-z\",\n  run: redo,\n  preventDefault: true\n}, {\n  key: \"Mod-u\",\n  run: undoSelection,\n  preventDefault: true\n}, {\n  key: \"Alt-u\",\n  mac: \"Mod-Shift-u\",\n  run: redoSelection,\n  preventDefault: true\n}];\n\nfunction updateSel(sel, by) {\n  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\n\nfunction setSel(state, selection) {\n  return state.update({\n    selection,\n    scrollIntoView: true,\n    userEvent: \"select\"\n  });\n}\n\nfunction moveSel({\n  state,\n  dispatch\n}, how) {\n  let selection = updateSel(state.selection, how);\n  if (selection.eq(state.selection, true)) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\n\nfunction rangeEnd(range, forward) {\n  return EditorSelection.cursor(forward ? range.to : range.from);\n}\n\nfunction cursorByChar(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\n\nfunction ltrAtCursor(view) {\n  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\n\n\nconst cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/\n\n\nconst cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/\n\n\nconst cursorCharForward = view => cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/\n\n\nconst cursorCharBackward = view => cursorByChar(view, false);\n\nfunction byCharLogical(state, range, forward) {\n  let pos = range.head,\n      line = state.doc.lineAt(pos);\n  if (pos == (forward ? line.to : line.from)) pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);else pos = line.from + findClusterBreak(line.text, pos - line.from, forward);\n  return EditorSelection.cursor(pos, forward ? -1 : 1);\n}\n\nfunction moveByCharLogical(target, forward) {\n  return moveSel(target, range => range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one character forward, in logical\n(non-text-direction-aware) string index order.\n*/\n\n\nconst cursorCharForwardLogical = target => moveByCharLogical(target, true);\n/**\nMove the selection one character backward, in logical string index\norder.\n*/\n\n\nconst cursorCharBackwardLogical = target => moveByCharLogical(target, false);\n\nfunction cursorByGroup(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\n\n\nconst cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/\n\n\nconst cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/\n\n\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/\n\n\nconst cursorGroupBackward = view => cursorByGroup(view, false);\n\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ? /*@__PURE__*/new Intl.Segmenter(undefined, {\n  granularity: \"word\"\n}) : null;\n\nfunction moveBySubword(view, range, forward) {\n  let categorize = view.state.charCategorizer(range.from);\n  let cat = CharCategory.Space,\n      pos = range.from,\n      steps = 0;\n  let done = false,\n      sawUpper = false,\n      sawLower = false;\n\n  let step = next => {\n    if (done) return false;\n    pos += forward ? next.length : -next.length;\n    let nextCat = categorize(next),\n        ahead;\n    if (nextCat == CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next)) nextCat = -1; // Treat word punctuation specially\n\n    if (cat == CharCategory.Space) cat = nextCat;\n    if (cat != nextCat) return false;\n\n    if (cat == CharCategory.Word) {\n      if (next.toLowerCase() == next) {\n        if (!forward && sawUpper) return false;\n        sawLower = true;\n      } else if (sawLower) {\n        if (forward) return false;\n        done = true;\n      } else {\n        if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n        sawUpper = true;\n      }\n    }\n\n    steps++;\n    return true;\n  };\n\n  let end = view.moveByChar(range, forward, start => {\n    step(start);\n    return step;\n  });\n\n  if (segmenter && cat == CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n    let from = Math.min(range.head, end.head),\n        to = Math.max(range.head, end.head);\n    let skipped = view.state.sliceDoc(from, to);\n\n    if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n      let segments = Array.from(segmenter.segment(skipped));\n\n      if (segments.length > 1) {\n        if (forward) return EditorSelection.cursor(range.head + segments[1].index, -1);\n        return EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n      }\n    }\n  }\n\n  return end;\n}\n\nfunction cursorBySubword(view, forward) {\n  return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\n\n\nconst cursorSubwordForward = view => cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/\n\n\nconst cursorSubwordBackward = view => cursorBySubword(view, false);\n\nfunction interestingNode(state, node, bracketProp) {\n  if (node.type.prop(bracketProp)) return true;\n  let len = node.to - node.from;\n  return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\n\nfunction moveBySyntax(state, start, forward) {\n  let pos = syntaxTree(state).resolveInner(start.head);\n  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy; // Scan forward through child nodes to see if there's an interesting\n  // node ahead.\n\n  for (let at = start.head;;) {\n    let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n    if (!next) break;\n    if (interestingNode(state, next, bracketProp)) pos = next;else at = forward ? next.to : next.from;\n  }\n\n  let bracket = pos.type.prop(bracketProp),\n      match,\n      newPos;\n  if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;else newPos = forward ? pos.to : pos.from;\n  return EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\n\n\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/\n\n\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\n\nfunction cursorByLine(view, forward) {\n  return moveSel(view, range => {\n    if (!range.empty) return rangeEnd(range, forward);\n    let moved = view.moveVertically(range, forward);\n    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n  });\n}\n/**\nMove the selection one line up.\n*/\n\n\nconst cursorLineUp = view => cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/\n\n\nconst cursorLineDown = view => cursorByLine(view, true);\n\nfunction pageInfo(view) {\n  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n  let marginTop = 0,\n      marginBottom = 0,\n      height;\n\n  if (selfScroll) {\n    for (let source of view.state.facet(EditorView.scrollMargins)) {\n      let margins = source(view);\n      if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n      if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n    }\n\n    height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n  } else {\n    height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n  }\n\n  return {\n    marginTop,\n    marginBottom,\n    selfScroll,\n    height: Math.max(view.defaultLineHeight, height - 5)\n  };\n}\n\nfunction cursorByPage(view, forward) {\n  let page = pageInfo(view);\n  let {\n    state\n  } = view,\n      selection = updateSel(state.selection, range => {\n    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);\n  });\n  if (selection.eq(state.selection)) return false;\n  let effect;\n\n  if (page.selfScroll) {\n    let startPos = view.coordsAtPos(state.selection.main.head);\n    let scrollRect = view.scrollDOM.getBoundingClientRect();\n    let scrollTop = scrollRect.top + page.marginTop,\n        scrollBottom = scrollRect.bottom - page.marginBottom;\n    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = EditorView.scrollIntoView(selection.main.head, {\n      y: \"start\",\n      yMargin: startPos.top - scrollTop\n    });\n  }\n\n  view.dispatch(setSel(state, selection), {\n    effects: effect\n  });\n  return true;\n}\n/**\nMove the selection one page up.\n*/\n\n\nconst cursorPageUp = view => cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/\n\n\nconst cursorPageDown = view => cursorByPage(view, true);\n\nfunction moveByLineBoundary(view, start, forward) {\n  let line = view.lineBlockAt(start.head),\n      moved = view.moveToLineBoundary(start, forward);\n  if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n\n  if (!forward && moved.head == line.from && line.length) {\n    let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n    if (space && start.head != line.from + space) moved = EditorSelection.cursor(line.from + space);\n  }\n\n  return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\n\n\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\n\n\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/\n\n\nconst cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/\n\n\nconst cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/\n\n\nconst cursorLineStart = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/\n\n\nconst cursorLineEnd = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\n\nfunction toMatchingBracket(state, dispatch, extend) {\n  let found = false,\n      selection = updateSel(state.selection, range => {\n    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);\n    if (!matching || !matching.end) return range;\n    found = true;\n    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);\n  });\n  if (!found) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\n\n\nconst cursorMatchingBracket = ({\n  state,\n  dispatch\n}) => toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\n\n\nconst selectMatchingBracket = ({\n  state,\n  dispatch\n}) => toMatchingBracket(state, dispatch, true);\n\nfunction extendSel(target, how) {\n  let selection = updateSel(target.state.selection, range => {\n    let head = how(range);\n    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n  });\n  if (selection.eq(target.state.selection)) return false;\n  target.dispatch(setSel(target.state, selection));\n  return true;\n}\n\nfunction selectByChar(view, forward) {\n  return extendSel(view, range => view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\n\n\nconst selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/\n\n\nconst selectCharRight = view => selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/\n\n\nconst selectCharForward = view => selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/\n\n\nconst selectCharBackward = view => selectByChar(view, false);\n/**\nMove the selection head one character forward by logical\n(non-direction aware) string index order.\n*/\n\n\nconst selectCharForwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, true));\n/**\nMove the selection head one character backward by logical string\nindex order.\n*/\n\n\nconst selectCharBackwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, false));\n\nfunction selectByGroup(view, forward) {\n  return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\n\n\nconst selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/\n\n\nconst selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/\n\n\nconst selectGroupForward = view => selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/\n\n\nconst selectGroupBackward = view => selectByGroup(view, false);\n\nfunction selectBySubword(view, forward) {\n  return extendSel(view, range => moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\n\n\nconst selectSubwordForward = view => selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/\n\n\nconst selectSubwordBackward = view => selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/\n\n\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/\n\n\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\n\nfunction selectByLine(view, forward) {\n  return extendSel(view, range => view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/\n\n\nconst selectLineUp = view => selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/\n\n\nconst selectLineDown = view => selectByLine(view, true);\n\nfunction selectByPage(view, forward) {\n  return extendSel(view, range => view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/\n\n\nconst selectPageUp = view => selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/\n\n\nconst selectPageDown = view => selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/\n\n\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/\n\n\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/\n\n\nconst selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/\n\n\nconst selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/\n\n\nconst selectLineStart = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/\n\n\nconst selectLineEnd = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/\n\n\nconst cursorDocStart = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: 0\n  }));\n  return true;\n};\n/**\nMove the selection to the end of the document.\n*/\n\n\nconst cursorDocEnd = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: state.doc.length\n  }));\n  return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\n\n\nconst selectDocStart = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: 0\n  }));\n  return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\n\n\nconst selectDocEnd = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: state.doc.length\n  }));\n  return true;\n};\n/**\nSelect the entire document.\n*/\n\n\nconst selectAll = ({\n  state,\n  dispatch\n}) => {\n  dispatch(state.update({\n    selection: {\n      anchor: 0,\n      head: state.doc.length\n    },\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\n\n\nconst selectLine = ({\n  state,\n  dispatch\n}) => {\n  let ranges = selectedLineBlocks(state).map(({\n    from,\n    to\n  }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n  dispatch(state.update({\n    selection: EditorSelection.create(ranges),\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\n\n\nconst selectParentSyntax = ({\n  state,\n  dispatch\n}) => {\n  let selection = updateSel(state.selection, range => {\n    let tree = syntaxTree(state),\n        stack = tree.resolveStack(range.from, 1);\n\n    if (range.empty) {\n      let stackBefore = tree.resolveStack(range.from, -1);\n      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to) stack = stackBefore;\n    }\n\n    for (let cur = stack; cur; cur = cur.next) {\n      let {\n        node\n      } = cur;\n      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur.next) return EditorSelection.range(node.to, node.from);\n    }\n\n    return range;\n  });\n  if (selection.eq(state.selection)) return false;\n  dispatch(setSel(state, selection));\n  return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\n\n\nconst simplifySelection = ({\n  state,\n  dispatch\n}) => {\n  let cur = state.selection,\n      selection = null;\n  if (cur.ranges.length > 1) selection = EditorSelection.create([cur.main]);else if (!cur.main.empty) selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);\n  if (!selection) return false;\n  dispatch(setSel(state, selection));\n  return true;\n};\n\nfunction deleteBy(target, by) {\n  if (target.state.readOnly) return false;\n  let event = \"delete.selection\",\n      {\n    state\n  } = target;\n  let changes = state.changeByRange(range => {\n    let {\n      from,\n      to\n    } = range;\n\n    if (from == to) {\n      let towards = by(range);\n\n      if (towards < from) {\n        event = \"delete.backward\";\n        towards = skipAtomic(target, towards, false);\n      } else if (towards > from) {\n        event = \"delete.forward\";\n        towards = skipAtomic(target, towards, true);\n      }\n\n      from = Math.min(from, towards);\n      to = Math.max(to, towards);\n    } else {\n      from = skipAtomic(target, from, false);\n      to = skipAtomic(target, to, true);\n    }\n\n    return from == to ? {\n      range\n    } : {\n      changes: {\n        from,\n        to\n      },\n      range: EditorSelection.cursor(from, from < range.head ? -1 : 1)\n    };\n  });\n  if (changes.changes.empty) return false;\n  target.dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: event,\n    effects: event == \"delete.selection\" ? EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n  }));\n  return true;\n}\n\nfunction skipAtomic(target, pos, forward) {\n  if (target instanceof EditorView) for (let ranges of target.state.facet(EditorView.atomicRanges).map(f => f(target))) ranges.between(pos, pos, (from, to) => {\n    if (from < pos && to > pos) pos = forward ? to : from;\n  });\n  return pos;\n}\n\nconst deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, range => {\n  let pos = range.from,\n      {\n    state\n  } = target,\n      line = state.doc.lineAt(pos),\n      before,\n      targetPos;\n\n  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n    if (before[before.length - 1] == \"\\t\") return pos - 1;\n    let col = countColumn(before, state.tabSize),\n        drop = col % getIndentUnit(state) || getIndentUnit(state);\n\n    for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++) pos--;\n\n    targetPos = pos;\n  } else {\n    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;\n    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;\n  }\n\n  return targetPos;\n});\n/**\nDelete the selection, or, for cursor selections, the character or\nindentation unit before the cursor.\n*/\n\n\nconst deleteCharBackward = view => deleteByChar(view, false, true);\n/**\nDelete the selection or the character before the cursor. Does not\nimplement any extended behavior like deleting whole indentation\nunits in one go.\n*/\n\n\nconst deleteCharBackwardStrict = view => deleteByChar(view, false, false);\n/**\nDelete the selection or the character after the cursor.\n*/\n\n\nconst deleteCharForward = view => deleteByChar(view, true, false);\n\nconst deleteByGroup = (target, forward) => deleteBy(target, range => {\n  let pos = range.head,\n      {\n    state\n  } = target,\n      line = state.doc.lineAt(pos);\n  let categorize = state.charCategorizer(pos);\n\n  for (let cat = null;;) {\n    if (pos == (forward ? line.to : line.from)) {\n      if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n      break;\n    }\n\n    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;\n    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n    let nextCat = categorize(nextChar);\n    if (cat != null && nextCat != cat) break;\n    if (nextChar != \" \" || pos != range.head) cat = nextCat;\n    pos = next;\n  }\n\n  return pos;\n});\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\n\n\nconst deleteGroupBackward = target => deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/\n\n\nconst deleteGroupForward = target => deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\n\n\nconst deleteToLineEnd = view => deleteBy(view, range => {\n  let lineEnd = view.lineBlockAt(range.head).to;\n  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\n\n\nconst deleteToLineStart = view => deleteBy(view, range => {\n  let lineStart = view.lineBlockAt(range.head).from;\n  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/\n\n\nconst deleteLineBoundaryBackward = view => deleteBy(view, range => {\n  let lineStart = view.moveToLineBoundary(range, false).head;\n  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/\n\n\nconst deleteLineBoundaryForward = view => deleteBy(view, range => {\n  let lineStart = view.moveToLineBoundary(range, true).head;\n  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n});\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\n\n\nconst deleteTrailingWhitespace = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let changes = [];\n\n  for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n    iter.next();\n\n    if (iter.lineBreak || iter.done) {\n      let trailing = prev.search(/\\s+$/);\n      if (trailing > -1) changes.push({\n        from: pos - (prev.length - trailing),\n        to: pos\n      });\n      if (iter.done) break;\n      prev = \"\";\n    } else {\n      prev = iter.value;\n    }\n\n    pos += iter.value.length;\n  }\n\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes,\n    userEvent: \"delete\"\n  }));\n  return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\n\n\nconst splitLine = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let changes = state.changeByRange(range => {\n    return {\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: Text.of([\"\", \"\"])\n      },\n      range: EditorSelection.cursor(range.from)\n    };\n  });\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\n\n\nconst transposeChars = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let changes = state.changeByRange(range => {\n    if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n      range\n    };\n    let pos = range.from,\n        line = state.doc.lineAt(pos);\n    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;\n    let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;\n    return {\n      changes: {\n        from,\n        to,\n        insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n      },\n      range: EditorSelection.cursor(to)\n    };\n  });\n  if (changes.changes.empty) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"move.character\"\n  }));\n  return true;\n};\n\nfunction selectedLineBlocks(state) {\n  let blocks = [],\n      upto = -1;\n\n  for (let range of state.selection.ranges) {\n    let startLine = state.doc.lineAt(range.from),\n        endLine = state.doc.lineAt(range.to);\n    if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n\n    if (upto >= startLine.number) {\n      let prev = blocks[blocks.length - 1];\n      prev.to = endLine.to;\n      prev.ranges.push(range);\n    } else {\n      blocks.push({\n        from: startLine.from,\n        to: endLine.to,\n        ranges: [range]\n      });\n    }\n\n    upto = endLine.number + 1;\n  }\n\n  return blocks;\n}\n\nfunction moveLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  let changes = [],\n      ranges = [];\n\n  for (let block of selectedLineBlocks(state)) {\n    if (forward ? block.to == state.doc.length : block.from == 0) continue;\n    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n    let size = nextLine.length + 1;\n\n    if (forward) {\n      changes.push({\n        from: block.to,\n        to: nextLine.to\n      }, {\n        from: block.from,\n        insert: nextLine.text + state.lineBreak\n      });\n\n      for (let r of block.ranges) ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n    } else {\n      changes.push({\n        from: nextLine.from,\n        to: block.from\n      }, {\n        from: block.to,\n        insert: state.lineBreak + nextLine.text\n      });\n\n      for (let r of block.ranges) ranges.push(EditorSelection.range(r.anchor - size, r.head - size));\n    }\n  }\n\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes,\n    scrollIntoView: true,\n    selection: EditorSelection.create(ranges, state.selection.mainIndex),\n    userEvent: \"move.line\"\n  }));\n  return true;\n}\n/**\nMove the selected lines up one line.\n*/\n\n\nconst moveLineUp = ({\n  state,\n  dispatch\n}) => moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/\n\n\nconst moveLineDown = ({\n  state,\n  dispatch\n}) => moveLine(state, dispatch, true);\n\nfunction copyLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  let changes = [];\n\n  for (let block of selectedLineBlocks(state)) {\n    if (forward) changes.push({\n      from: block.from,\n      insert: state.doc.slice(block.from, block.to) + state.lineBreak\n    });else changes.push({\n      from: block.to,\n      insert: state.lineBreak + state.doc.slice(block.from, block.to)\n    });\n  }\n\n  dispatch(state.update({\n    changes,\n    scrollIntoView: true,\n    userEvent: \"input.copyline\"\n  }));\n  return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\n\n\nconst copyLineUp = ({\n  state,\n  dispatch\n}) => copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\n\n\nconst copyLineDown = ({\n  state,\n  dispatch\n}) => copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/\n\n\nconst deleteLine = view => {\n  if (view.state.readOnly) return false;\n  let {\n    state\n  } = view,\n      changes = state.changes(selectedLineBlocks(state).map(({\n    from,\n    to\n  }) => {\n    if (from > 0) from--;else if (to < state.doc.length) to++;\n    return {\n      from,\n      to\n    };\n  }));\n  let selection = updateSel(state.selection, range => {\n    let dist = undefined;\n\n    if (view.lineWrapping) {\n      let block = view.lineBlockAt(range.head),\n          pos = view.coordsAtPos(range.head, range.assoc || 1);\n      if (pos) dist = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;\n    }\n\n    return view.moveVertically(range, true, dist);\n  }).map(changes);\n  view.dispatch({\n    changes,\n    selection,\n    scrollIntoView: true,\n    userEvent: \"delete.line\"\n  });\n  return true;\n};\n/**\nReplace the selection with a newline.\n*/\n\n\nconst insertNewline = ({\n  state,\n  dispatch\n}) => {\n  dispatch(state.update(state.replaceSelection(state.lineBreak), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nReplace the selection with a newline and the same amount of\nindentation as the line above.\n*/\n\n\nconst insertNewlineKeepIndent = ({\n  state,\n  dispatch\n}) => {\n  dispatch(state.update(state.changeByRange(range => {\n    let indent = /^\\s*/.exec(state.doc.lineAt(range.from).text)[0];\n    return {\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: state.lineBreak + indent\n      },\n      range: EditorSelection.cursor(range.from + indent.length + 1)\n    };\n  }), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n\nfunction isBetweenBrackets(state, pos) {\n  if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n    from: pos,\n    to: pos\n  };\n  let context = syntaxTree(state).resolveInner(pos);\n  let before = context.childBefore(pos),\n      after = context.childAfter(pos),\n      closedBy;\n  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\\S/.test(state.sliceDoc(before.to, after.from))) return {\n    from: before.to,\n    to: after.from\n  };\n  return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\n\n\nconst insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\n\nconst insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\n\nfunction newlineAndIndent(atEof) {\n  return ({\n    state,\n    dispatch\n  }) => {\n    if (state.readOnly) return false;\n    let changes = state.changeByRange(range => {\n      let {\n        from,\n        to\n      } = range,\n          line = state.doc.lineAt(from);\n      let explode = !atEof && from == to && isBetweenBrackets(state, from);\n      if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n      let cx = new IndentContext(state, {\n        simulateBreak: from,\n        simulateDoubleBreak: !!explode\n      });\n      let indent = getIndentation(cx, from);\n      if (indent == null) indent = countColumn(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n\n      while (to < line.to && /\\s/.test(line.text[to - line.from])) to++;\n\n      if (explode) ({\n        from,\n        to\n      } = explode);else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n      let insert = [\"\", indentString(state, indent)];\n      if (explode) insert.push(indentString(state, cx.lineIndent(line.from, -1)));\n      return {\n        changes: {\n          from,\n          to,\n          insert: Text.of(insert)\n        },\n        range: EditorSelection.cursor(from + 1 + insert[1].length)\n      };\n    });\n    dispatch(state.update(changes, {\n      scrollIntoView: true,\n      userEvent: \"input\"\n    }));\n    return true;\n  };\n}\n\nfunction changeBySelectedLine(state, f) {\n  let atLine = -1;\n  return state.changeByRange(range => {\n    let changes = [];\n\n    for (let pos = range.from; pos <= range.to;) {\n      let line = state.doc.lineAt(pos);\n\n      if (line.number > atLine && (range.empty || range.to > line.from)) {\n        f(line, changes, range);\n        atLine = line.number;\n      }\n\n      pos = line.to + 1;\n    }\n\n    let changeSet = state.changes(changes);\n    return {\n      changes,\n      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n    };\n  });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\n\n\nconst indentSelection = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let updated = Object.create(null);\n  let context = new IndentContext(state, {\n    overrideIndentation: start => {\n      let found = updated[start];\n      return found == null ? -1 : found;\n    }\n  });\n  let changes = changeBySelectedLine(state, (line, changes, range) => {\n    let indent = getIndentation(context, line.from);\n    if (indent == null) return;\n    if (!/\\S/.test(line.text)) indent = 0;\n    let cur = /^\\s*/.exec(line.text)[0];\n    let norm = indentString(state, indent);\n\n    if (cur != norm || range.from < line.from + cur.length) {\n      updated[line.from] = indent;\n      changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n  });\n  if (!changes.changes.empty) dispatch(state.update(changes, {\n    userEvent: \"indent\"\n  }));\n  return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\n\n\nconst indentMore = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n    changes.push({\n      from: line.from,\n      insert: state.facet(indentUnit)\n    });\n  }), {\n    userEvent: \"input.indent\"\n  }));\n  return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\n\n\nconst indentLess = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n    let space = /^\\s*/.exec(line.text)[0];\n    if (!space) return;\n    let col = countColumn(space, state.tabSize),\n        keep = 0;\n    let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));\n\n    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) keep++;\n\n    changes.push({\n      from: line.from + keep,\n      to: line.from + space.length,\n      insert: insert.slice(keep)\n    });\n  }), {\n    userEvent: \"delete.dedent\"\n  }));\n  return true;\n};\n/**\nEnables or disables\n[tab-focus mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode). While on, this\nprevents the editor's key bindings from capturing Tab or\nShift-Tab, making it possible for the user to move focus out of\nthe editor with the keyboard.\n*/\n\n\nconst toggleTabFocusMode = view => {\n  view.setTabFocusMode();\n  return true;\n};\n/**\nTemporarily enables [tab-focus\nmode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode) for two seconds or until\nanother key is pressed.\n*/\n\n\nconst temporarilySetTabFocusMode = view => {\n  view.setTabFocusMode(2000);\n  return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\n\n\nconst insertTab = ({\n  state,\n  dispatch\n}) => {\n  if (state.selection.ranges.some(r => !r.empty)) return indentMore({\n    state,\n    dispatch\n  });\n  dispatch(state.update(state.replaceSelection(\"\\t\"), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\n\n\nconst emacsStyleKeymap = [{\n  key: \"Ctrl-b\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Ctrl-f\",\n  run: cursorCharRight,\n  shift: selectCharRight\n}, {\n  key: \"Ctrl-p\",\n  run: cursorLineUp,\n  shift: selectLineUp\n}, {\n  key: \"Ctrl-n\",\n  run: cursorLineDown,\n  shift: selectLineDown\n}, {\n  key: \"Ctrl-a\",\n  run: cursorLineStart,\n  shift: selectLineStart\n}, {\n  key: \"Ctrl-e\",\n  run: cursorLineEnd,\n  shift: selectLineEnd\n}, {\n  key: \"Ctrl-d\",\n  run: deleteCharForward\n}, {\n  key: \"Ctrl-h\",\n  run: deleteCharBackward\n}, {\n  key: \"Ctrl-k\",\n  run: deleteToLineEnd\n}, {\n  key: \"Ctrl-Alt-h\",\n  run: deleteGroupBackward\n}, {\n  key: \"Ctrl-o\",\n  run: splitLine\n}, {\n  key: \"Ctrl-t\",\n  run: transposeChars\n}, {\n  key: \"Ctrl-v\",\n  run: cursorPageDown\n}];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter and Shift-Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/\n\nconst standardKeymap = /*@__PURE__*/[{\n  key: \"ArrowLeft\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowLeft\",\n  mac: \"Alt-ArrowLeft\",\n  run: cursorGroupLeft,\n  shift: selectGroupLeft,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowLeft\",\n  run: cursorLineBoundaryLeft,\n  shift: selectLineBoundaryLeft,\n  preventDefault: true\n}, {\n  key: \"ArrowRight\",\n  run: cursorCharRight,\n  shift: selectCharRight,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowRight\",\n  mac: \"Alt-ArrowRight\",\n  run: cursorGroupRight,\n  shift: selectGroupRight,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowRight\",\n  run: cursorLineBoundaryRight,\n  shift: selectLineBoundaryRight,\n  preventDefault: true\n}, {\n  key: \"ArrowUp\",\n  run: cursorLineUp,\n  shift: selectLineUp,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowUp\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  mac: \"Ctrl-ArrowUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"ArrowDown\",\n  run: cursorLineDown,\n  shift: selectLineDown,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowDown\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  mac: \"Ctrl-ArrowDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"PageUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"PageDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"Home\",\n  run: cursorLineBoundaryBackward,\n  shift: selectLineBoundaryBackward,\n  preventDefault: true\n}, {\n  key: \"Mod-Home\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  key: \"End\",\n  run: cursorLineBoundaryForward,\n  shift: selectLineBoundaryForward,\n  preventDefault: true\n}, {\n  key: \"Mod-End\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  key: \"Enter\",\n  run: insertNewlineAndIndent,\n  shift: insertNewlineAndIndent\n}, {\n  key: \"Mod-a\",\n  run: selectAll\n}, {\n  key: \"Backspace\",\n  run: deleteCharBackward,\n  shift: deleteCharBackward\n}, {\n  key: \"Delete\",\n  run: deleteCharForward\n}, {\n  key: \"Mod-Backspace\",\n  mac: \"Alt-Backspace\",\n  run: deleteGroupBackward\n}, {\n  key: \"Mod-Delete\",\n  mac: \"Alt-Delete\",\n  run: deleteGroupForward\n}, {\n  mac: \"Mod-Backspace\",\n  run: deleteLineBoundaryBackward\n}, {\n  mac: \"Mod-Delete\",\n  run: deleteLineBoundaryForward\n}].concat( /*@__PURE__*/emacsStyleKeymap.map(b => ({\n  mac: b.key,\n  run: b.run,\n  shift: b.shift\n})));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n- Ctrl-m (Alt-Shift-m on macOS): [`toggleTabFocusMode`](https://codemirror.net/6/docs/ref/#commands.toggleTabFocusMode).\n*/\n\nconst defaultKeymap = /*@__PURE__*/[{\n  key: \"Alt-ArrowLeft\",\n  mac: \"Ctrl-ArrowLeft\",\n  run: cursorSyntaxLeft,\n  shift: selectSyntaxLeft\n}, {\n  key: \"Alt-ArrowRight\",\n  mac: \"Ctrl-ArrowRight\",\n  run: cursorSyntaxRight,\n  shift: selectSyntaxRight\n}, {\n  key: \"Alt-ArrowUp\",\n  run: moveLineUp\n}, {\n  key: \"Shift-Alt-ArrowUp\",\n  run: copyLineUp\n}, {\n  key: \"Alt-ArrowDown\",\n  run: moveLineDown\n}, {\n  key: \"Shift-Alt-ArrowDown\",\n  run: copyLineDown\n}, {\n  key: \"Escape\",\n  run: simplifySelection\n}, {\n  key: \"Mod-Enter\",\n  run: insertBlankLine\n}, {\n  key: \"Alt-l\",\n  mac: \"Ctrl-l\",\n  run: selectLine\n}, {\n  key: \"Mod-i\",\n  run: selectParentSyntax,\n  preventDefault: true\n}, {\n  key: \"Mod-[\",\n  run: indentLess\n}, {\n  key: \"Mod-]\",\n  run: indentMore\n}, {\n  key: \"Mod-Alt-\\\\\",\n  run: indentSelection\n}, {\n  key: \"Shift-Mod-k\",\n  run: deleteLine\n}, {\n  key: \"Shift-Mod-\\\\\",\n  run: cursorMatchingBracket\n}, {\n  key: \"Mod-/\",\n  run: toggleComment\n}, {\n  key: \"Alt-A\",\n  run: toggleBlockComment\n}, {\n  key: \"Ctrl-m\",\n  mac: \"Shift-Alt-m\",\n  run: toggleTabFocusMode\n}].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\n\nconst indentWithTab = {\n  key: \"Tab\",\n  run: indentMore,\n  shift: indentLess\n};\nexport { blockComment, blockUncomment, copyLineDown, copyLineUp, cursorCharBackward, cursorCharBackwardLogical, cursorCharForward, cursorCharForwardLogical, cursorCharLeft, cursorCharRight, cursorDocEnd, cursorDocStart, cursorGroupBackward, cursorGroupForward, cursorGroupLeft, cursorGroupRight, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorLineBoundaryLeft, cursorLineBoundaryRight, cursorLineDown, cursorLineEnd, cursorLineStart, cursorLineUp, cursorMatchingBracket, cursorPageDown, cursorPageUp, cursorSubwordBackward, cursorSubwordForward, cursorSyntaxLeft, cursorSyntaxRight, defaultKeymap, deleteCharBackward, deleteCharBackwardStrict, deleteCharForward, deleteGroupBackward, deleteGroupForward, deleteLine, deleteLineBoundaryBackward, deleteLineBoundaryForward, deleteToLineEnd, deleteToLineStart, deleteTrailingWhitespace, emacsStyleKeymap, history, historyField, historyKeymap, indentLess, indentMore, indentSelection, indentWithTab, insertBlankLine, insertNewline, insertNewlineAndIndent, insertNewlineKeepIndent, insertTab, invertedEffects, isolateHistory, lineComment, lineUncomment, moveLineDown, moveLineUp, redo, redoDepth, redoSelection, selectAll, selectCharBackward, selectCharBackwardLogical, selectCharForward, selectCharForwardLogical, selectCharLeft, selectCharRight, selectDocEnd, selectDocStart, selectGroupBackward, selectGroupForward, selectGroupLeft, selectGroupRight, selectLine, selectLineBoundaryBackward, selectLineBoundaryForward, selectLineBoundaryLeft, selectLineBoundaryRight, selectLineDown, selectLineEnd, selectLineStart, selectLineUp, selectMatchingBracket, selectPageDown, selectPageUp, selectParentSyntax, selectSubwordBackward, selectSubwordForward, selectSyntaxLeft, selectSyntaxRight, simplifySelection, splitLine, standardKeymap, temporarilySetTabFocusMode, toggleBlockComment, toggleBlockCommentByLine, toggleComment, toggleLineComment, toggleTabFocusMode, transposeChars, undo, undoDepth, undoSelection };","map":{"version":3,"sources":["/Users/sairahulpadma/Desktop/leetcodeUI/frontend/node_modules/@codemirror/commands/dist/index.js"],"names":["Annotation","Facet","combineConfig","StateField","Transaction","ChangeSet","ChangeDesc","EditorSelection","StateEffect","Text","findClusterBreak","countColumn","CharCategory","EditorView","Direction","IndentContext","getIndentation","indentString","matchBrackets","syntaxTree","getIndentUnit","indentUnit","NodeProp","toggleComment","target","state","line","doc","lineAt","selection","main","from","config","getConfig","toggleLineComment","block","toggleBlockCommentByLine","command","f","option","dispatch","readOnly","tr","update","changeLineComment","lineComment","lineUncomment","toggleBlockComment","changeBlockComment","blockComment","blockUncomment","o","s","selectedLineRanges","pos","data","languageDataAt","length","SearchMargin","findBlockComment","open","close","to","textBefore","sliceDoc","textAfter","spaceBefore","exec","spaceAfter","beforeOff","slice","margin","startText","endText","startSpace","endSpace","endOff","test","charAt","ranges","r","fromLine","toLine","last","push","text","tokens","map","every","c","comments","i","changes","range","insert","some","comment","token","lines","prevLine","startI","minIndent","indent","empty","single","l","changeSet","fromHistory","define","isolateHistory","invertedEffects","historyConfig","combine","configs","minDepth","newGroupDelay","joinToEvent","_t","isAdjacent","Math","max","min","a","b","adj","historyField_","create","HistoryState","facet","fromHist","annotation","item","HistEvent","fromTransaction","side","other","undone","done","updateBranch","addSelection","startState","rest","isolate","addToHistory","addMapping","desc","event","time","userEvent","addChanges","toJSON","value","e","fromJSON","json","history","of","domEventHandlers","beforeinput","view","inputType","undo","redo","preventDefault","historyField","cmd","historyState","field","pop","undoSelection","redoSelection","depth","histState","branch","undoDepth","redoDepth","constructor","effects","mapped","startSelection","selectionsAfter","setSelAfter","after","_a","_b","_c","none","invert","result","concat","undefined","selections","maxLen","newEvent","start","newBranch","iterChangedRanges","t","_f","eqSelectionShape","filter","conc","MaxSelectionsPerEvent","lastEvent","sels","eq","popSelection","addMappingToBranch","mapping","mapEvent","extraSelections","mappedChanges","before","mapDesc","fullMapping","composeDesc","mapEffects","joinableUserEvent","prevTime","prevUserEvent","compose","onlySelection","annotations","scrollIntoView","historyKeymap","key","run","mac","linux","updateSel","sel","by","mainIndex","setSel","moveSel","how","rangeEnd","forward","cursor","cursorByChar","moveByChar","ltrAtCursor","textDirectionAt","head","LTR","cursorCharLeft","cursorCharRight","cursorCharForward","cursorCharBackward","byCharLogical","moveByCharLogical","cursorCharForwardLogical","cursorCharBackwardLogical","cursorByGroup","moveByGroup","cursorGroupLeft","cursorGroupRight","cursorGroupForward","cursorGroupBackward","segmenter","Intl","Segmenter","granularity","moveBySubword","categorize","charCategorizer","cat","Space","steps","sawUpper","sawLower","step","next","nextCat","ahead","Word","charCodeAt","toLowerCase","end","skipped","segments","Array","segment","index","cursorBySubword","cursorSubwordForward","cursorSubwordBackward","interestingNode","node","bracketProp","type","prop","len","firstChild","moveBySyntax","resolveInner","closedBy","openedBy","at","childAfter","childBefore","bracket","match","newPos","matched","cursorSyntaxLeft","cursorSyntaxRight","cursorByLine","moved","moveVertically","moveToLineBoundary","cursorLineUp","cursorLineDown","pageInfo","selfScroll","scrollDOM","clientHeight","scrollHeight","marginTop","marginBottom","height","source","scrollMargins","margins","top","bottom","dom","ownerDocument","defaultView","window","innerHeight","defaultLineHeight","cursorByPage","page","effect","startPos","coordsAtPos","scrollRect","getBoundingClientRect","scrollTop","scrollBottom","y","yMargin","cursorPageUp","cursorPageDown","moveByLineBoundary","lineBlockAt","space","cursorLineBoundaryForward","cursorLineBoundaryBackward","cursorLineBoundaryLeft","cursorLineBoundaryRight","cursorLineStart","cursorLineEnd","toMatchingBracket","extend","found","matching","anchor","cursorMatchingBracket","selectMatchingBracket","extendSel","goalColumn","bidiLevel","selectByChar","selectCharLeft","selectCharRight","selectCharForward","selectCharBackward","selectCharForwardLogical","selectCharBackwardLogical","selectByGroup","selectGroupLeft","selectGroupRight","selectGroupForward","selectGroupBackward","selectBySubword","selectSubwordForward","selectSubwordBackward","selectSyntaxLeft","selectSyntaxRight","selectByLine","selectLineUp","selectLineDown","selectByPage","selectPageUp","selectPageDown","selectLineBoundaryForward","selectLineBoundaryBackward","selectLineBoundaryLeft","selectLineBoundaryRight","selectLineStart","selectLineEnd","cursorDocStart","cursorDocEnd","selectDocStart","selectDocEnd","selectAll","selectLine","selectedLineBlocks","selectParentSyntax","tree","stack","resolveStack","stackBefore","cur","simplifySelection","deleteBy","changeByRange","towards","skipAtomic","announce","phrase","atomicRanges","between","deleteByChar","byIndentUnit","targetPos","col","tabSize","drop","number","deleteCharBackward","deleteCharBackwardStrict","deleteCharForward","deleteByGroup","nextChar","deleteGroupBackward","deleteGroupForward","deleteToLineEnd","lineEnd","deleteToLineStart","lineStart","deleteLineBoundaryBackward","deleteLineBoundaryForward","deleteTrailingWhitespace","prev","iter","lineBreak","trailing","search","splitLine","transposeChars","append","blocks","upto","startLine","endLine","moveLine","nextLine","size","moveLineUp","moveLineDown","copyLine","copyLineUp","copyLineDown","deleteLine","dist","lineWrapping","assoc","documentTop","insertNewline","replaceSelection","insertNewlineKeepIndent","isBetweenBrackets","context","indexOf","name","insertNewlineAndIndent","newlineAndIndent","insertBlankLine","atEof","explode","cx","simulateBreak","simulateDoubleBreak","lineIndent","changeBySelectedLine","atLine","mapPos","indentSelection","updated","Object","overrideIndentation","norm","indentMore","indentLess","keep","toggleTabFocusMode","setTabFocusMode","temporarilySetTabFocusMode","insertTab","emacsStyleKeymap","shift","standardKeymap","defaultKeymap","indentWithTab"],"mappings":"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","sourcesContent":["import { Annotation, Facet, combineConfig, StateField, Transaction, ChangeSet, ChangeDesc, EditorSelection, StateEffect, Text, findClusterBreak, countColumn, CharCategory } from '@codemirror/state';\nimport { EditorView, Direction } from '@codemirror/view';\nimport { IndentContext, getIndentation, indentString, matchBrackets, syntaxTree, getIndentUnit, indentUnit } from '@codemirror/language';\nimport { NodeProp } from '@lezer/common';\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\nconst toggleComment = target => {\n    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch }) => {\n        if (state.readOnly)\n            return false;\n        let tr = f(option, state);\n        if (!tr)\n            return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* CommentOption.Toggle */);\n/**\nComment the current selection using line comments.\n*/\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1 /* CommentOption.Comment */);\n/**\nUncomment the current selection using line comments.\n*/\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2 /* CommentOption.Uncomment */);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* CommentOption.Toggle */);\n/**\nComment the current selection using block comments.\n*/\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1 /* CommentOption.Comment */);\n/**\nUncomment the current selection using block comments.\n*/\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2 /* CommentOption.Uncomment */);\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/\nconst toggleBlockCommentByLine = /*@__PURE__*/command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */);\nfunction getConfig(state, pos) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\nfunction findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&\n        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },\n            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    }\n    else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open &&\n        endText.slice(endOff, endOff + close.length) == close) {\n        return { open: { pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },\n            close: { pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };\n    }\n    return null;\n}\nfunction selectedLineRanges(state) {\n    let ranges = [];\n    for (let r of state.selection.ranges) {\n        let fromLine = state.doc.lineAt(r.from);\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n        if (toLine.from > fromLine.from && toLine.from == r.to)\n            toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);\n        let last = ranges.length - 1;\n        if (last >= 0 && ranges[last].to > fromLine.from)\n            ranges[last].to = toLine.to;\n        else\n            ranges.push({ from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length, to: toLine.to });\n    }\n    return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n    let tokens = ranges.map(r => getConfig(state, r.from).block);\n    if (!tokens.every(c => c))\n        return null;\n    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* CommentOption.Uncomment */ && !comments.every(c => c)) {\n        return { changes: state.changes(ranges.map((range, i) => {\n                if (comments[i])\n                    return [];\n                return [{ from: range.from, insert: tokens[i].open + \" \" }, { from: range.to, insert: \" \" + tokens[i].close }];\n            })) };\n    }\n    else if (option != 1 /* CommentOption.Comment */ && comments.some(c => c)) {\n        let changes = [];\n        for (let i = 0, comment; i < comments.length; i++)\n            if (comment = comments[i]) {\n                let token = tokens[i], { open, close } = comment;\n                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });\n            }\n        return { changes };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges) {\n        let startI = lines.length, minIndent = 1e9;\n        let token = getConfig(state, from).line;\n        if (!token)\n            continue;\n        for (let pos = from; pos <= to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent)\n                    minIndent = indent;\n                lines.push({ line, comment, token, indent, empty, single: false });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9)\n            for (let i = startI; i < lines.length; i++)\n                if (lines[i].indent < lines[i].line.text.length)\n                    lines[i].indent = minIndent;\n        if (lines.length == startI + 1)\n            lines[startI].single = true;\n    }\n    if (option != 2 /* CommentOption.Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)\n            if (single || !empty)\n                changes.push({ from: line.from + indent, insert: token + \" \" });\n        let changeSet = state.changes(changes);\n        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };\n    }\n    else if (option != 1 /* CommentOption.Comment */ && lines.some(l => l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)\n            if (comment >= 0) {\n                let from = line.from + comment, to = from + token.length;\n                if (line.text[to - line.from] == \" \")\n                    to++;\n                changes.push({ from, to });\n            }\n        return { changes };\n    }\n    return null;\n}\n\nconst fromHistory = /*@__PURE__*/Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\nconst isolateHistory = /*@__PURE__*/Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\nconst invertedEffects = /*@__PURE__*/Facet.define();\nconst historyConfig = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            minDepth: 100,\n            newGroupDelay: 500,\n            joinToEvent: (_t, isAdjacent) => isAdjacent,\n        }, {\n            minDepth: Math.max,\n            newGroupDelay: Math.min,\n            joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)\n        });\n    }\n});\nconst historyField_ = /*@__PURE__*/StateField.define({\n    create() {\n        return HistoryState.empty;\n    },\n    update(state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;\n            let other = from == 0 /* BranchName.Done */ ? state.undone : state.done;\n            if (item)\n                other = updateBranch(other, other.length, config.minDepth, item);\n            else\n                other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\")\n            state = state.isolate();\n        if (tr.annotation(Transaction.addToHistory) === false)\n            return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);\n        if (event)\n            state = state.addChanges(event, time, userEvent, config, tr);\n        else if (tr.selection)\n            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\")\n            state = state.isolate();\n        return state;\n    },\n    toJSON(value) {\n        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };\n    },\n    fromJSON(json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/\nfunction history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        EditorView.domEventHandlers({\n            beforeinput(e, view) {\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n                if (!command)\n                    return false;\n                e.preventDefault();\n                return command(view);\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\nconst historyField = historyField_;\nfunction cmd(side, selection) {\n    return function ({ state, dispatch }) {\n        if (!selection && state.readOnly)\n            return false;\n        let historyState = state.field(historyField_, false);\n        if (!historyState)\n            return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr)\n            return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\nconst undo = /*@__PURE__*/cmd(0 /* BranchName.Done */, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\nconst redo = /*@__PURE__*/cmd(1 /* BranchName.Undone */, false);\n/**\nUndo a change or selection change.\n*/\nconst undoSelection = /*@__PURE__*/cmd(0 /* BranchName.Done */, true);\n/**\nRedo a change or selection change.\n*/\nconst redoSelection = /*@__PURE__*/cmd(1 /* BranchName.Undone */, true);\nfunction depth(side) {\n    return function (state) {\n        let histState = state.field(historyField_, false);\n        if (!histState)\n            return 0;\n        let branch = side == 0 /* BranchName.Done */ ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\nconst undoDepth = /*@__PURE__*/depth(0 /* BranchName.Done */);\n/**\nThe amount of redoable change events available in a given state.\n*/\nconst redoDepth = /*@__PURE__*/depth(1 /* BranchName.Undone */);\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(\n    // The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, \n    // The effects associated with this event\n    effects, \n    // Accumulated mapping (from addToHistory==false) that should be\n    // applied to events below this one.\n    mapped, \n    // The selection before this event\n    startSelection, \n    // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter) {\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr, selection) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)) {\n            let result = invert(tr);\n            if (result.length)\n                effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty)\n            return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t) => ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t) => {\n        for (let i = 0; i < ranges.length;) {\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to)\n                isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length &&\n        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [HistEvent.selection([selection])];\n    }\n    else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection))\n            return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length)\n        return branch;\n    let length = branch.length, selections = none;\n    while (length) {\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        }\n        else { // Drop this event, since there's no changes or effects left\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [HistEvent.selection(selections)] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes)\n        return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, config, tr) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&\n            (!userEvent || joinableUserEvent.test(userEvent)) &&\n            ((!lastEvent.selectionsAfter.length &&\n                time - this.prevTime < config.newGroupDelay &&\n                config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes))) ||\n                // For compose (but not compose.start) events, always join with previous event\n                userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        }\n        else {\n            done = updateBranch(done, done.length, config.minDepth, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 &&\n            time - this.prevTime < newGroupDelay &&\n            userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) &&\n            eqSelectionShape(last[last.length - 1], selection))\n            return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, onlySelection) {\n        let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;\n        if (branch.length == 0)\n            return null;\n        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;\n        if (onlySelection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),\n                userEvent: side == 0 /* BranchName.Done */ ? \"select.undo\" : \"select.redo\",\n                scrollIntoView: true\n            });\n        }\n        else if (!event.changes) {\n            return null;\n        }\n        else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped)\n                rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({ side, rest, selection }),\n                filter: false,\n                userEvent: side == 0 /* BranchName.Done */ ? \"undo\" : \"redo\",\n                scrollIntoView: true\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/\nconst historyKeymap = [\n    { key: \"Mod-z\", run: undo, preventDefault: true },\n    { key: \"Mod-y\", mac: \"Mod-Shift-z\", run: redo, preventDefault: true },\n    { linux: \"Ctrl-Shift-z\", run: redo, preventDefault: true },\n    { key: \"Mod-u\", run: undoSelection, preventDefault: true },\n    { key: \"Alt-u\", mac: \"Mod-Shift-u\", run: redoSelection, preventDefault: true }\n];\n\nfunction updateSel(sel, by) {\n    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({ selection, scrollIntoView: true, userEvent: \"select\" });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection, true))\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\nconst cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/\nconst cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/\nconst cursorCharForward = view => cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/\nconst cursorCharBackward = view => cursorByChar(view, false);\nfunction byCharLogical(state, range, forward) {\n    let pos = range.head, line = state.doc.lineAt(pos);\n    if (pos == (forward ? line.to : line.from))\n        pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);\n    else\n        pos = line.from + findClusterBreak(line.text, pos - line.from, forward);\n    return EditorSelection.cursor(pos, forward ? -1 : 1);\n}\nfunction moveByCharLogical(target, forward) {\n    return moveSel(target, range => range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one character forward, in logical\n(non-text-direction-aware) string index order.\n*/\nconst cursorCharForwardLogical = target => moveByCharLogical(target, true);\n/**\nMove the selection one character backward, in logical string index\norder.\n*/\nconst cursorCharBackwardLogical = target => moveByCharLogical(target, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\nconst cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/\nconst cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/\nconst cursorGroupBackward = view => cursorByGroup(view, false);\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ?\n    /*@__PURE__*/new (Intl.Segmenter)(undefined, { granularity: \"word\" }) : null;\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    let cat = CharCategory.Space, pos = range.from, steps = 0;\n    let done = false, sawUpper = false, sawLower = false;\n    let step = (next) => {\n        if (done)\n            return false;\n        pos += forward ? next.length : -next.length;\n        let nextCat = categorize(next), ahead;\n        if (nextCat == CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next))\n            nextCat = -1; // Treat word punctuation specially\n        if (cat == CharCategory.Space)\n            cat = nextCat;\n        if (cat != nextCat)\n            return false;\n        if (cat == CharCategory.Word) {\n            if (next.toLowerCase() == next) {\n                if (!forward && sawUpper)\n                    return false;\n                sawLower = true;\n            }\n            else if (sawLower) {\n                if (forward)\n                    return false;\n                done = true;\n            }\n            else {\n                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word &&\n                    ahead.toLowerCase() == ahead)\n                    return false;\n                sawUpper = true;\n            }\n        }\n        steps++;\n        return true;\n    };\n    let end = view.moveByChar(range, forward, start => {\n        step(start);\n        return step;\n    });\n    if (segmenter && cat == CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);\n        let skipped = view.state.sliceDoc(from, to);\n        if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n            let segments = Array.from(segmenter.segment(skipped));\n            if (segments.length > 1) {\n                if (forward)\n                    return EditorSelection.cursor(range.head + segments[1].index, -1);\n                return EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n            }\n        }\n    }\n    return end;\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\nconst cursorSubwordForward = view => cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/\nconst cursorSubwordBackward = view => cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp))\n        return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = syntaxTree(state).resolveInner(start.head);\n    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for (let at = start.head;;) {\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next)\n            break;\n        if (interestingNode(state, next, bracketProp))\n            pos = next;\n        else\n            at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)\n        newPos = forward ? match.end.to : match.end.from;\n    else\n        newPos = forward ? pos.to : pos.from;\n    return EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, range => {\n        if (!range.empty)\n            return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/\nconst cursorLineUp = view => cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/\nconst cursorLineDown = view => cursorByLine(view, true);\nfunction pageInfo(view) {\n    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n    let marginTop = 0, marginBottom = 0, height;\n    if (selfScroll) {\n        for (let source of view.state.facet(EditorView.scrollMargins)) {\n            let margins = source(view);\n            if (margins === null || margins === void 0 ? void 0 : margins.top)\n                marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n            if (margins === null || margins === void 0 ? void 0 : margins.bottom)\n                marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n        }\n        height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n    }\n    else {\n        height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n    }\n    return { marginTop, marginBottom, selfScroll,\n        height: Math.max(view.defaultLineHeight, height - 5) };\n}\nfunction cursorByPage(view, forward) {\n    let page = pageInfo(view);\n    let { state } = view, selection = updateSel(state.selection, range => {\n        return range.empty ? view.moveVertically(range, forward, page.height)\n            : rangeEnd(range, forward);\n    });\n    if (selection.eq(state.selection))\n        return false;\n    let effect;\n    if (page.selfScroll) {\n        let startPos = view.coordsAtPos(state.selection.main.head);\n        let scrollRect = view.scrollDOM.getBoundingClientRect();\n        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;\n        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)\n            effect = EditorView.scrollIntoView(selection.main.head, { y: \"start\", yMargin: startPos.top - scrollTop });\n    }\n    view.dispatch(setSel(state, selection), { effects: effect });\n    return true;\n}\n/**\nMove the selection one page up.\n*/\nconst cursorPageUp = view => cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/\nconst cursorPageDown = view => cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))\n        moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space)\n            moved = EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/\nconst cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/\nconst cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/\nconst cursorLineStart = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/\nconst cursorLineEnd = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, range => {\n        let matching = matchBrackets(state, range.head, -1)\n            || matchBrackets(state, range.head, 1)\n            || (range.head > 0 && matchBrackets(state, range.head - 1, 1))\n            || (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1));\n        if (!matching || !matching.end)\n            return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);\n    });\n    if (!found)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\nconst cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\nconst selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);\nfunction extendSel(target, how) {\n    let selection = updateSel(target.state.selection, range => {\n        let head = how(range);\n        return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n    });\n    if (selection.eq(target.state.selection))\n        return false;\n    target.dispatch(setSel(target.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, range => view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\nconst selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/\nconst selectCharRight = view => selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/\nconst selectCharForward = view => selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/\nconst selectCharBackward = view => selectByChar(view, false);\n/**\nMove the selection head one character forward by logical\n(non-direction aware) string index order.\n*/\nconst selectCharForwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, true));\n/**\nMove the selection head one character backward by logical string\nindex order.\n*/\nconst selectCharBackwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, false));\nfunction selectByGroup(view, forward) {\n    return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\nconst selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/\nconst selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/\nconst selectGroupForward = view => selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/\nconst selectGroupBackward = view => selectByGroup(view, false);\nfunction selectBySubword(view, forward) {\n    return extendSel(view, range => moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\nconst selectSubwordForward = view => selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/\nconst selectSubwordBackward = view => selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/\nconst selectLineUp = view => selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/\nconst selectLineDown = view => selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/\nconst selectPageUp = view => selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/\nconst selectPageDown = view => selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/\nconst selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/\nconst selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/\nconst selectLineStart = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/\nconst selectLineEnd = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/\nconst cursorDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: 0 }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/\nconst cursorDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.doc.length }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\nconst selectDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\nconst selectDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));\n    return true;\n};\n/**\nSelect the entire document.\n*/\nconst selectAll = ({ state, dispatch }) => {\n    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: \"select\" }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\nconst selectLine = ({ state, dispatch }) => {\n    let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: \"select\" }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\nconst selectParentSyntax = ({ state, dispatch }) => {\n    let selection = updateSel(state.selection, range => {\n        let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);\n        if (range.empty) {\n            let stackBefore = tree.resolveStack(range.from, -1);\n            if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)\n                stack = stackBefore;\n        }\n        for (let cur = stack; cur; cur = cur.next) {\n            let { node } = cur;\n            if (((node.from < range.from && node.to >= range.to) ||\n                (node.to > range.to && node.from <= range.from)) &&\n                cur.next)\n                return EditorSelection.range(node.to, node.from);\n        }\n        return range;\n    });\n    if (selection.eq(state.selection))\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\nconst simplifySelection = ({ state, dispatch }) => {\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1)\n        selection = EditorSelection.create([cur.main]);\n    else if (!cur.main.empty)\n        selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);\n    if (!selection)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(target, by) {\n    if (target.state.readOnly)\n        return false;\n    let event = \"delete.selection\", { state } = target;\n    let changes = state.changeByRange(range => {\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(range);\n            if (towards < from) {\n                event = \"delete.backward\";\n                towards = skipAtomic(target, towards, false);\n            }\n            else if (towards > from) {\n                event = \"delete.forward\";\n                towards = skipAtomic(target, towards, true);\n            }\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        }\n        else {\n            from = skipAtomic(target, from, false);\n            to = skipAtomic(target, to, true);\n        }\n        return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };\n    });\n    if (changes.changes.empty)\n        return false;\n    target.dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: event,\n        effects: event == \"delete.selection\" ? EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n    }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof EditorView)\n        for (let ranges of target.state.facet(EditorView.atomicRanges).map(f => f(target)))\n            ranges.between(pos, pos, (from, to) => {\n                if (from < pos && to > pos)\n                    pos = forward ? to : from;\n            });\n    return pos;\n}\nconst deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, range => {\n    let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n    if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 &&\n        !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n        if (before[before.length - 1] == \"\\t\")\n            return pos - 1;\n        let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);\n        for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)\n            pos--;\n        targetPos = pos;\n    }\n    else {\n        targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;\n        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))\n            targetPos += forward ? 1 : -1;\n        else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))\n            targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;\n    }\n    return targetPos;\n});\n/**\nDelete the selection, or, for cursor selections, the character or\nindentation unit before the cursor.\n*/\nconst deleteCharBackward = view => deleteByChar(view, false, true);\n/**\nDelete the selection or the character before the cursor. Does not\nimplement any extended behavior like deleting whole indentation\nunits in one go.\n*/\nconst deleteCharBackwardStrict = view => deleteByChar(view, false, false);\n/**\nDelete the selection or the character after the cursor.\n*/\nconst deleteCharForward = view => deleteByChar(view, true, false);\nconst deleteByGroup = (target, forward) => deleteBy(target, range => {\n    let pos = range.head, { state } = target, line = state.doc.lineAt(pos);\n    let categorize = state.charCategorizer(pos);\n    for (let cat = null;;) {\n        if (pos == (forward ? line.to : line.from)) {\n            if (pos == range.head && line.number != (forward ? state.doc.lines : 1))\n                pos += forward ? 1 : -1;\n            break;\n        }\n        let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;\n        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n        let nextCat = categorize(nextChar);\n        if (cat != null && nextCat != cat)\n            break;\n        if (nextChar != \" \" || pos != range.head)\n            cat = nextCat;\n        pos = next;\n    }\n    return pos;\n});\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\nconst deleteGroupBackward = target => deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/\nconst deleteGroupForward = target => deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\nconst deleteToLineEnd = view => deleteBy(view, range => {\n    let lineEnd = view.lineBlockAt(range.head).to;\n    return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\nconst deleteToLineStart = view => deleteBy(view, range => {\n    let lineStart = view.lineBlockAt(range.head).from;\n    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/\nconst deleteLineBoundaryBackward = view => deleteBy(view, range => {\n    let lineStart = view.moveToLineBoundary(range, false).head;\n    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/\nconst deleteLineBoundaryForward = view => deleteBy(view, range => {\n    let lineStart = view.moveToLineBoundary(range, true).head;\n    return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n});\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\nconst deleteTrailingWhitespace = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = [];\n    for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1)\n                changes.push({ from: pos - (prev.length - trailing), to: pos });\n            if (iter.done)\n                break;\n            prev = \"\";\n        }\n        else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({ changes, userEvent: \"delete\" }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\nconst splitLine = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = state.changeByRange(range => {\n        return { changes: { from: range.from, to: range.to, insert: Text.of([\"\", \"\"]) },\n            range: EditorSelection.cursor(range.from) };\n    });\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\nconst transposeChars = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = state.changeByRange(range => {\n        if (!range.empty || range.from == 0 || range.from == state.doc.length)\n            return { range };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;\n        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },\n            range: EditorSelection.cursor(to) };\n    });\n    if (changes.changes.empty)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"move.character\" }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges) {\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from)\n            endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        }\n        else {\n            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly)\n        return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward ? block.to == state.doc.length : block.from == 0)\n            continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });\n            for (let r of block.ranges)\n                ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        }\n        else {\n            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });\n            for (let r of block.ranges)\n                ranges.push(EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/\nconst moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/\nconst moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly)\n        return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward)\n            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });\n        else\n            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });\n    }\n    dispatch(state.update({ changes, scrollIntoView: true, userEvent: \"input.copyline\" }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\nconst copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\nconst copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/\nconst deleteLine = view => {\n    if (view.state.readOnly)\n        return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {\n        if (from > 0)\n            from--;\n        else if (to < state.doc.length)\n            to++;\n        return { from, to };\n    }));\n    let selection = updateSel(state.selection, range => {\n        let dist = undefined;\n        if (view.lineWrapping) {\n            let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (pos)\n                dist = (block.bottom + view.documentTop) - pos.bottom + view.defaultLineHeight / 2;\n        }\n        return view.moveVertically(range, true, dist);\n    }).map(changes);\n    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: \"delete.line\" });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/\nconst insertNewline = ({ state, dispatch }) => {\n    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nReplace the selection with a newline and the same amount of\nindentation as the line above.\n*/\nconst insertNewlineKeepIndent = ({ state, dispatch }) => {\n    dispatch(state.update(state.changeByRange(range => {\n        let indent = /^\\s*/.exec(state.doc.lineAt(range.from).text)[0];\n        return {\n            changes: { from: range.from, to: range.to, insert: state.lineBreak + indent },\n            range: EditorSelection.cursor(range.from + indent.length + 1)\n        };\n    }), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1)))\n        return { from: pos, to: pos };\n    let context = syntaxTree(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos &&\n        (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&\n        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from &&\n        !/\\S/.test(state.sliceDoc(before.to, after.from)))\n        return { from: before.to, to: after.from };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\nconst insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\nconst insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch }) => {\n        if (state.readOnly)\n            return false;\n        let changes = state.changeByRange(range => {\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof)\n                from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });\n            let indent = getIndentation(cx, from);\n            if (indent == null)\n                indent = countColumn(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n            while (to < line.to && /\\s/.test(line.text[to - line.from]))\n                to++;\n            if (explode)\n                ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from)))\n                from = line.from;\n            let insert = [\"\", indentString(state, indent)];\n            if (explode)\n                insert.push(indentString(state, cx.lineIndent(line.from, -1)));\n            return { changes: { from, to, insert: Text.of(insert) },\n                range: EditorSelection.cursor(from + 1 + insert[1].length) };\n        });\n        dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange(range => {\n        let changes = [];\n        for (let pos = range.from; pos <= range.to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return { changes,\n            range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\nconst indentSelection = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let updated = Object.create(null);\n    let context = new IndentContext(state, { overrideIndentation: start => {\n            let found = updated[start];\n            return found == null ? -1 : found;\n        } });\n    let changes = changeBySelectedLine(state, (line, changes, range) => {\n        let indent = getIndentation(context, line.from);\n        if (indent == null)\n            return;\n        if (!/\\S/.test(line.text))\n            indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n    });\n    if (!changes.changes.empty)\n        dispatch(state.update(changes, { userEvent: \"indent\" }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\nconst indentMore = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        changes.push({ from: line.from, insert: state.facet(indentUnit) });\n    }), { userEvent: \"input.indent\" }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\nconst indentLess = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space)\n            return;\n        let col = countColumn(space, state.tabSize), keep = 0;\n        let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));\n        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))\n            keep++;\n        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });\n    }), { userEvent: \"delete.dedent\" }));\n    return true;\n};\n/**\nEnables or disables\n[tab-focus mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode). While on, this\nprevents the editor's key bindings from capturing Tab or\nShift-Tab, making it possible for the user to move focus out of\nthe editor with the keyboard.\n*/\nconst toggleTabFocusMode = view => {\n    view.setTabFocusMode();\n    return true;\n};\n/**\nTemporarily enables [tab-focus\nmode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode) for two seconds or until\nanother key is pressed.\n*/\nconst temporarilySetTabFocusMode = view => {\n    view.setTabFocusMode(2000);\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\nconst insertTab = ({ state, dispatch }) => {\n    if (state.selection.ranges.some(r => !r.empty))\n        return indentMore({ state, dispatch });\n    dispatch(state.update(state.replaceSelection(\"\\t\"), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\nconst emacsStyleKeymap = [\n    { key: \"Ctrl-b\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\n    { key: \"Ctrl-f\", run: cursorCharRight, shift: selectCharRight },\n    { key: \"Ctrl-p\", run: cursorLineUp, shift: selectLineUp },\n    { key: \"Ctrl-n\", run: cursorLineDown, shift: selectLineDown },\n    { key: \"Ctrl-a\", run: cursorLineStart, shift: selectLineStart },\n    { key: \"Ctrl-e\", run: cursorLineEnd, shift: selectLineEnd },\n    { key: \"Ctrl-d\", run: deleteCharForward },\n    { key: \"Ctrl-h\", run: deleteCharBackward },\n    { key: \"Ctrl-k\", run: deleteToLineEnd },\n    { key: \"Ctrl-Alt-h\", run: deleteGroupBackward },\n    { key: \"Ctrl-o\", run: splitLine },\n    { key: \"Ctrl-t\", run: transposeChars },\n    { key: \"Ctrl-v\", run: cursorPageDown },\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter and Shift-Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/\nconst standardKeymap = /*@__PURE__*/[\n    { key: \"ArrowLeft\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\n    { key: \"Mod-ArrowLeft\", mac: \"Alt-ArrowLeft\", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },\n    { mac: \"Cmd-ArrowLeft\", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },\n    { key: \"ArrowRight\", run: cursorCharRight, shift: selectCharRight, preventDefault: true },\n    { key: \"Mod-ArrowRight\", mac: \"Alt-ArrowRight\", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },\n    { mac: \"Cmd-ArrowRight\", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },\n    { key: \"ArrowUp\", run: cursorLineUp, shift: selectLineUp, preventDefault: true },\n    { mac: \"Cmd-ArrowUp\", run: cursorDocStart, shift: selectDocStart },\n    { mac: \"Ctrl-ArrowUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"ArrowDown\", run: cursorLineDown, shift: selectLineDown, preventDefault: true },\n    { mac: \"Cmd-ArrowDown\", run: cursorDocEnd, shift: selectDocEnd },\n    { mac: \"Ctrl-ArrowDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"PageUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"PageDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"Home\", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },\n    { key: \"Mod-Home\", run: cursorDocStart, shift: selectDocStart },\n    { key: \"End\", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },\n    { key: \"Mod-End\", run: cursorDocEnd, shift: selectDocEnd },\n    { key: \"Enter\", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },\n    { key: \"Mod-a\", run: selectAll },\n    { key: \"Backspace\", run: deleteCharBackward, shift: deleteCharBackward },\n    { key: \"Delete\", run: deleteCharForward },\n    { key: \"Mod-Backspace\", mac: \"Alt-Backspace\", run: deleteGroupBackward },\n    { key: \"Mod-Delete\", mac: \"Alt-Delete\", run: deleteGroupForward },\n    { mac: \"Mod-Backspace\", run: deleteLineBoundaryBackward },\n    { mac: \"Mod-Delete\", run: deleteLineBoundaryForward }\n].concat(/*@__PURE__*/emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n- Ctrl-m (Alt-Shift-m on macOS): [`toggleTabFocusMode`](https://codemirror.net/6/docs/ref/#commands.toggleTabFocusMode).\n*/\nconst defaultKeymap = /*@__PURE__*/[\n    { key: \"Alt-ArrowLeft\", mac: \"Ctrl-ArrowLeft\", run: cursorSyntaxLeft, shift: selectSyntaxLeft },\n    { key: \"Alt-ArrowRight\", mac: \"Ctrl-ArrowRight\", run: cursorSyntaxRight, shift: selectSyntaxRight },\n    { key: \"Alt-ArrowUp\", run: moveLineUp },\n    { key: \"Shift-Alt-ArrowUp\", run: copyLineUp },\n    { key: \"Alt-ArrowDown\", run: moveLineDown },\n    { key: \"Shift-Alt-ArrowDown\", run: copyLineDown },\n    { key: \"Escape\", run: simplifySelection },\n    { key: \"Mod-Enter\", run: insertBlankLine },\n    { key: \"Alt-l\", mac: \"Ctrl-l\", run: selectLine },\n    { key: \"Mod-i\", run: selectParentSyntax, preventDefault: true },\n    { key: \"Mod-[\", run: indentLess },\n    { key: \"Mod-]\", run: indentMore },\n    { key: \"Mod-Alt-\\\\\", run: indentSelection },\n    { key: \"Shift-Mod-k\", run: deleteLine },\n    { key: \"Shift-Mod-\\\\\", run: cursorMatchingBracket },\n    { key: \"Mod-/\", run: toggleComment },\n    { key: \"Alt-A\", run: toggleBlockComment },\n    { key: \"Ctrl-m\", mac: \"Shift-Alt-m\", run: toggleTabFocusMode },\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\nconst indentWithTab = { key: \"Tab\", run: indentMore, shift: indentLess };\n\nexport { blockComment, blockUncomment, copyLineDown, copyLineUp, cursorCharBackward, cursorCharBackwardLogical, cursorCharForward, cursorCharForwardLogical, cursorCharLeft, cursorCharRight, cursorDocEnd, cursorDocStart, cursorGroupBackward, cursorGroupForward, cursorGroupLeft, cursorGroupRight, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorLineBoundaryLeft, cursorLineBoundaryRight, cursorLineDown, cursorLineEnd, cursorLineStart, cursorLineUp, cursorMatchingBracket, cursorPageDown, cursorPageUp, cursorSubwordBackward, cursorSubwordForward, cursorSyntaxLeft, cursorSyntaxRight, defaultKeymap, deleteCharBackward, deleteCharBackwardStrict, deleteCharForward, deleteGroupBackward, deleteGroupForward, deleteLine, deleteLineBoundaryBackward, deleteLineBoundaryForward, deleteToLineEnd, deleteToLineStart, deleteTrailingWhitespace, emacsStyleKeymap, history, historyField, historyKeymap, indentLess, indentMore, indentSelection, indentWithTab, insertBlankLine, insertNewline, insertNewlineAndIndent, insertNewlineKeepIndent, insertTab, invertedEffects, isolateHistory, lineComment, lineUncomment, moveLineDown, moveLineUp, redo, redoDepth, redoSelection, selectAll, selectCharBackward, selectCharBackwardLogical, selectCharForward, selectCharForwardLogical, selectCharLeft, selectCharRight, selectDocEnd, selectDocStart, selectGroupBackward, selectGroupForward, selectGroupLeft, selectGroupRight, selectLine, selectLineBoundaryBackward, selectLineBoundaryForward, selectLineBoundaryLeft, selectLineBoundaryRight, selectLineDown, selectLineEnd, selectLineStart, selectLineUp, selectMatchingBracket, selectPageDown, selectPageUp, selectParentSyntax, selectSubwordBackward, selectSubwordForward, selectSyntaxLeft, selectSyntaxRight, simplifySelection, splitLine, standardKeymap, temporarilySetTabFocusMode, toggleBlockComment, toggleBlockCommentByLine, toggleComment, toggleLineComment, toggleTabFocusMode, transposeChars, undo, undoDepth, undoSelection };\n"]},"metadata":{},"sourceType":"module"}