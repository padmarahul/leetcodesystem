{"ast":null,"code":"import _toConsumableArray from \"/Users/sairahulpadma/Desktop/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/sairahulpadma/Desktop/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sairahulpadma/Desktop/leetcodeUI/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nvar C = \"\\u037C\";\nvar COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C);\nvar SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\");\nvar top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}; // :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\n\nexport var StyleModule = /*#__PURE__*/function () {\n  // :: (Object<Style>, ?{finish: ?(string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  function StyleModule(spec, options) {\n    _classCallCheck(this, StyleModule);\n\n    this.rules = [];\n\n    var _ref = options || {},\n        finish = _ref.finish;\n\n    function splitSelector(selector) {\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/);\n    }\n\n    function render(selectors, spec, target, isKeyframes) {\n      var local = [],\n          isAt = /^@(\\w+)\\b/.exec(selectors[0]),\n          keyframes = isAt && isAt[1] == \"keyframes\";\n      if (isAt && spec == null) return target.push(selectors[0] + \";\");\n\n      for (var prop in spec) {\n        var value = spec[prop];\n\n        if (/&/.test(prop)) {\n          render(prop.split(/,\\s*/).map(function (part) {\n            return selectors.map(function (sel) {\n              return part.replace(/&/, sel);\n            });\n          }).reduce(function (a, b) {\n            return a.concat(b);\n          }), value, target);\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\");\n          render(splitSelector(prop), value, local, keyframes);\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, function (l) {\n            return \"-\" + l.toLowerCase();\n          }) + \": \" + value + \";\");\n        }\n      }\n\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") + \" {\" + local.join(\" \") + \"}\");\n      }\n    }\n\n    for (var prop in spec) {\n      render(splitSelector(prop), spec[prop], this.rules);\n    }\n  } // :: () → string\n  // Returns a string containing the module's CSS rules.\n\n\n  _createClass(StyleModule, [{\n    key: \"getRules\",\n    value: function getRules() {\n      return this.rules.join(\"\\n\");\n    } // :: () → string\n    // Generate a new unique CSS class name.\n\n  }], [{\n    key: \"newName\",\n    value: function newName() {\n      var id = top[COUNT] || 1;\n      top[COUNT] = id + 1;\n      return C + id.toString(36);\n    } // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})\n    //\n    // Mount the given set of modules in the given DOM root, which ensures\n    // that the CSS rules defined by the module are available in that\n    // context.\n    //\n    // Rules are only added to the document once per root.\n    //\n    // Rule order will follow the order of the modules, so that rules from\n    // modules later in the array take precedence of those from earlier\n    // modules. If you call this function multiple times for the same root\n    // in a way that changes the order of already mounted modules, the old\n    // order will be changed.\n    //\n    // If a Content Security Policy nonce is provided, it is added to\n    // the `<style>` tag generated by the library.\n\n  }, {\n    key: \"mount\",\n    value: function mount(root, modules, options) {\n      var set = root[SET],\n          nonce = options && options.nonce;\n      if (!set) set = new StyleSet(root, nonce);else if (nonce) set.setNonce(nonce);\n      set.mount(Array.isArray(modules) ? modules : [modules], root);\n    }\n  }]);\n\n  return StyleModule;\n}();\nvar adoptedSet = new Map(); //<Document, StyleSet>\n\nvar StyleSet = /*#__PURE__*/function () {\n  function StyleSet(root, nonce) {\n    _classCallCheck(this, StyleSet);\n\n    var doc = root.ownerDocument || root,\n        win = doc.defaultView;\n\n    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {\n      var adopted = adoptedSet.get(doc);\n      if (adopted) return root[SET] = adopted;\n      this.sheet = new win.CSSStyleSheet();\n      adoptedSet.set(doc, this);\n    } else {\n      this.styleTag = doc.createElement(\"style\");\n      if (nonce) this.styleTag.setAttribute(\"nonce\", nonce);\n    }\n\n    this.modules = [];\n    root[SET] = this;\n  }\n\n  _createClass(StyleSet, [{\n    key: \"mount\",\n    value: function mount(modules, root) {\n      var sheet = this.sheet;\n      var pos = 0\n      /* Current rule offset */\n      ,\n          j = 0;\n      /* Index into this.modules */\n\n      for (var i = 0; i < modules.length; i++) {\n        var mod = modules[i],\n            index = this.modules.indexOf(mod);\n\n        if (index < j && index > -1) {\n          // Ordering conflict\n          this.modules.splice(index, 1);\n          j--;\n          index = -1;\n        }\n\n        if (index == -1) {\n          this.modules.splice(j++, 0, mod);\n          if (sheet) for (var k = 0; k < mod.rules.length; k++) {\n            sheet.insertRule(mod.rules[k], pos++);\n          }\n        } else {\n          while (j < index) {\n            pos += this.modules[j++].rules.length;\n          }\n\n          pos += mod.rules.length;\n          j++;\n        }\n      }\n\n      if (sheet) {\n        if (root.adoptedStyleSheets.indexOf(this.sheet) < 0) root.adoptedStyleSheets = [this.sheet].concat(_toConsumableArray(root.adoptedStyleSheets));\n      } else {\n        var text = \"\";\n\n        for (var _i = 0; _i < this.modules.length; _i++) {\n          text += this.modules[_i].getRules() + \"\\n\";\n        }\n\n        this.styleTag.textContent = text;\n        var target = root.head || root;\n        if (this.styleTag.parentNode != target) target.insertBefore(this.styleTag, target.firstChild);\n      }\n    }\n  }, {\n    key: \"setNonce\",\n    value: function setNonce(nonce) {\n      if (this.styleTag && this.styleTag.getAttribute(\"nonce\") != nonce) this.styleTag.setAttribute(\"nonce\", nonce);\n    }\n  }]);\n\n  return StyleSet;\n}(); // Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.","map":{"version":3,"sources":["/Users/sairahulpadma/Desktop/leetcodeUI/frontend/node_modules/style-mod/src/style-mod.js"],"names":["C","COUNT","Symbol","for","SET","Math","floor","random","top","globalThis","window","StyleModule","spec","options","rules","finish","splitSelector","selector","test","split","render","selectors","target","isKeyframes","local","isAt","exec","keyframes","push","prop","value","map","part","sel","replace","reduce","a","b","concat","RangeError","l","toLowerCase","length","join","id","toString","root","modules","set","nonce","StyleSet","setNonce","mount","Array","isArray","adoptedSet","Map","doc","ownerDocument","win","defaultView","head","adoptedStyleSheets","CSSStyleSheet","adopted","get","sheet","styleTag","createElement","setAttribute","pos","j","i","mod","index","indexOf","splice","k","insertRule","text","getRules","textContent","parentNode","insertBefore","firstChild","getAttribute"],"mappings":"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","sourcesContent":["const C = \"\\u037c\"\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C)\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\")\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}\n\n// :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nexport class StyleModule {\n  // :: (Object<Style>, ?{finish: ?(string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  constructor(spec, options) {\n    this.rules = []\n    let {finish} = options || {}\n\n    function splitSelector(selector) {\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/)\n    }\n\n    function render(selectors, spec, target, isKeyframes) {\n      let local = [], isAt = /^@(\\w+)\\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == \"keyframes\"\n      if (isAt && spec == null) return target.push(selectors[0] + \";\")\n      for (let prop in spec) {\n        let value = spec[prop]\n        if (/&/.test(prop)) {\n          render(prop.split(/,\\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),\n                 value, target)\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n          render(splitSelector(prop), value, local, keyframes)\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\")\n        }\n      }\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") +\n                    \" {\" + local.join(\" \") + \"}\")\n      }\n    }\n\n    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)\n  }\n\n  // :: () → string\n  // Returns a string containing the module's CSS rules.\n  getRules() { return this.rules.join(\"\\n\") }\n\n  // :: () → string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let id = top[COUNT] || 1\n    top[COUNT] = id + 1\n    return C + id.toString(36)\n  }\n\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  //\n  // If a Content Security Policy nonce is provided, it is added to\n  // the `<style>` tag generated by the library.\n  static mount(root, modules, options) {\n    let set = root[SET], nonce = options && options.nonce\n    if (!set) set = new StyleSet(root, nonce)\n    else if (nonce) set.setNonce(nonce)\n    set.mount(Array.isArray(modules) ? modules : [modules], root)\n  }\n}\n\nlet adoptedSet = new Map //<Document, StyleSet>\n\nclass StyleSet {\n  constructor(root, nonce) {\n    let doc = root.ownerDocument || root, win = doc.defaultView\n    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {\n      let adopted = adoptedSet.get(doc)\n      if (adopted) return root[SET] = adopted\n      this.sheet = new win.CSSStyleSheet\n      adoptedSet.set(doc, this)\n    } else {\n      this.styleTag = doc.createElement(\"style\")\n      if (nonce) this.styleTag.setAttribute(\"nonce\", nonce)\n    }\n    this.modules = []\n    root[SET] = this\n  }\n\n  mount(modules, root) {\n    let sheet = this.sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (sheet) for (let k = 0; k < mod.rules.length; k++)\n          sheet.insertRule(mod.rules[k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length\n        pos += mod.rules.length\n        j++\n      }\n    }\n\n    if (sheet) {\n      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)\n        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets]\n    } else {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i].getRules() + \"\\n\"\n      this.styleTag.textContent = text\n      let target = root.head || root\n      if (this.styleTag.parentNode != target)\n        target.insertBefore(this.styleTag, target.firstChild)\n    }\n  }\n\n  setNonce(nonce) {\n    if (this.styleTag && this.styleTag.getAttribute(\"nonce\") != nonce)\n      this.styleTag.setAttribute(\"nonce\", nonce)\n  }\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n"]},"metadata":{},"sourceType":"module"}